(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.chrono = f()}})(function(){var define,module,exports;return (function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
//! moment.js locale configuration
//! locale : French [fr]
//! author : John Fischer : https://github.com/jfroffice

;(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined'
       && typeof require === 'function' ? factory(require('../moment')) :
   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
   factory(global.moment)
}(this, (function (moment) { 'use strict';


var fr = moment.defineLocale('fr', {
    months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
    monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
    monthsParseExact : true,
    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin : 'di_lu_ma_me_je_ve_sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Aujourd’hui à] LT',
        nextDay : '[Demain à] LT',
        nextWeek : 'dddd [à] LT',
        lastDay : '[Hier à] LT',
        lastWeek : 'dddd [dernier à] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dans %s',
        past : 'il y a %s',
        s : 'quelques secondes',
        ss : '%d secondes',
        m : 'une minute',
        mm : '%d minutes',
        h : 'une heure',
        hh : '%d heures',
        d : 'un jour',
        dd : '%d jours',
        M : 'un mois',
        MM : '%d mois',
        y : 'un an',
        yy : '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
    ordinal : function (number, period) {
        switch (period) {
            // TODO: Return 'e' when day of month > 1. Move this case inside
            // block for masculine words below.
            // See https://github.com/moment/moment/issues/3375
            case 'D':
                return number + (number === 1 ? 'er' : '');

            // Words with masculine grammatical gender: mois, trimestre, jour
            default:
            case 'M':
            case 'Q':
            case 'DDD':
            case 'd':
                return number + (number === 1 ? 'er' : 'e');

            // Words with feminine grammatical gender: semaine
            case 'w':
            case 'W':
                return number + (number === 1 ? 're' : 'e');
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

return fr;

})));

},{"../moment":2}],2:[function(require,module,exports){
//! moment.js
//! version : 2.20.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
        return (Object.getOwnPropertyNames(obj).length === 0);
    } else {
        var k;
        for (k in obj) {
            if (obj.hasOwnProperty(k)) {
                return false;
            }
        }
        return true;
    }
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.weekdayMismatch &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
        if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
        }
        else {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function mod(n, x) {
    return ((n % x) + x) % x;
}

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
        return NaN;
    }
    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            var aliasedRequire = require;
            aliasedRequire('./locale/' + name);
            getSetGlobalLocale(oldLocale);
        } catch (e) {}
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, tmpLocale, parentConfig = baseConfig;
        // MERGE
        tmpLocale = loadLocale(name);
        if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, expectedWeekday, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }

    // check for mismatching day of week
    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
    ];

    if (secondStr) {
        result.push(parseInt(secondStr, 10));
    }

    return result;
}

function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);
    if (year <= 49) {
        return 2000 + year;
    } else if (year <= 999) {
        return 1900 + year;
    }
    return year;
}

function preprocessRFC2822(s) {
    // Remove comments and folding whitespace and replace multiple-spaces with a single space
    return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').trim();
}

function checkWeekday(weekdayStr, parsedInput, config) {
    if (weekdayStr) {
        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
            weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
        if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
        }
    }
    return true;
}

var obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
};

function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
        return obsOffsets[obsOffset];
    } else if (militaryOffset) {
        // the only allowed military tz is Z
        return 0;
    } else {
        var hm = parseInt(numOffset, 10);
        var m = hm % 100, h = (hm - m) / 100;
        return h * 60 + m;
    }
}

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var match = rfc2822.exec(preprocessRFC2822(config._i));
    if (match) {
        var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
        if (!checkWeekday(match[1], parsedArray, config)) {
            return;
        }

        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);

        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible to translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    switch (units) {
        case 'year': output = monthDiff(this, that) / 12; break;
        case 'month': output = monthDiff(this, that); break;
        case 'quarter': output = monthDiff(this, that) / 3; break;
        case 'second': output = (this - that) / 1e3; break; // 1000
        case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
        case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
        case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
        case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
        default: output = this - that;
    }

    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString(keepOffset) {
    if (!this.isValid()) {
        return null;
    }
    var utc = keepOffset !== true;
    var m = utc ? this.clone().utc() : this;
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        if (utc) {
            return this.toDate().toISOString();
        } else {
            return new Date(this._d.valueOf()).toISOString().replace('Z', formatMoment(m, 'Z'));
        }
    }
    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0]);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function clone$1 () {
    return createDuration(this);
}

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function sign(x) {
    return ((x > 0) - (x < 0)) || +x;
}

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    var totalSign = total < 0 ? '-' : '';
    var ymSign = sign(this._months) !== sign(total) ? '-' : '';
    var daysSign = sign(this._days) !== sign(total) ? '-' : '';
    var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

    return totalSign + 'P' +
        (Y ? ymSign + Y + 'Y' : '') +
        (M ? ymSign + M + 'M' : '') +
        (D ? daysSign + D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? hmsSign + h + 'H' : '') +
        (m ? hmsSign + m + 'M' : '') +
        (s ? hmsSign + s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.clone          = clone$1;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.20.1';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

// currently HTML5 input type only supports 24-hour formats
hooks.HTML5_FMT = {
    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
    DATE: 'YYYY-MM-DD',                             // <input type="date" />
    TIME: 'HH:mm',                                  // <input type="time" />
    TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
    TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
    WEEK: 'YYYY-[W]WW',                             // <input type="week" />
    MONTH: 'YYYY-MM'                                // <input type="month" />
};

return hooks;

})));

},{}],3:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
var options = require("./options");
exports.options = options;
var options_1 = require("./options");
var parser_1 = require("./parsers/parser"),
    parser = parser_1;
exports.Parser = parser_1.default;
exports.parser = parser;
var refiner_1 = require("./refiners/refiner"),
    refiner = refiner_1;
exports.Refiner = refiner_1.default;
exports.refiner = refiner;
var refiner_2 = require("./refiners/refiner");
exports.Filter = refiner_2.Filter;
var result_1 = require("./result");
exports.ParsedResult = result_1.ParsedResult;
exports.ParsedComponents = result_1.ParsedComponents;
var DEFAULT_PARSE_OPTIONS = {
    forwardDate: false,
    afternoon: 15,
    evening: 18,
    morning: 6,
    noon: 12
};

var Chrono = function () {
    function Chrono() {
        var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : options_1.casualOption();

        _classCallCheck(this, Chrono);

        this.option = option;
        this.parsers = option.parsers || [];
        this.refiners = option.refiners || [];
    }

    _createClass(Chrono, [{
        key: "parse",
        value: function parse(text) {
            var refDate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();
            var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

            var mergedOptions = Object.assign({}, DEFAULT_PARSE_OPTIONS, opt);
            var allResults = [];
            this.parsers.forEach(function (parser) {
                var _allResults;

                return (_allResults = allResults).push.apply(_allResults, _toConsumableArray(parser.execute(text, refDate, mergedOptions)));
            });
            allResults.sort(function (a, b) {
                return a.index - b.index;
            });
            this.refiners.forEach(function (refiner) {
                return allResults = refiner.refine(text, allResults, mergedOptions);
            });
            return allResults;
        }
    }, {
        key: "parseDate",
        value: function parseDate(text) {
            var refDate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();
            var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

            var results = this.parse(text, refDate, opt);
            if (results.length > 0) {
                return results[0].start.date();
            }
            return null;
        }
    }]);

    return Chrono;
}();

exports.Chrono = Chrono;
exports.default = Chrono;
exports.strict = new Chrono(options_1.strictOption());
exports.casual = new Chrono(options_1.casualOption());
exports.en = new Chrono(options_1.mergeOptions([options_1.en.casual, options_1.commonPostProcessing]));
exports.en_GB = new Chrono(options_1.mergeOptions([options_1.en_GB.casual, options_1.commonPostProcessing]));
exports.de = new Chrono(options_1.mergeOptions([options_1.de.casual, options_1.en, options_1.commonPostProcessing]));
exports.es = new Chrono(options_1.mergeOptions([options_1.es.casual, options_1.en, options_1.commonPostProcessing]));
exports.fr = new Chrono(options_1.mergeOptions([options_1.fr.casual, options_1.en, options_1.commonPostProcessing]));
exports.ja = new Chrono(options_1.mergeOptions([options_1.ja.casual, options_1.en, options_1.commonPostProcessing]));
exports.parse = function (text, ref, opt) {
    return exports.casual.parse.call(exports.casual, text, ref, opt);
};
exports.parseDate = function (text, ref, opt) {
    return exports.casual.parseDate.call(exports.casual, text, ref, opt);
};

},{"./options":5,"./parsers/parser":51,"./refiners/refiner":65,"./result":66}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HOUR = 'hour';
exports.MINUTE = 'minute';
exports.SECOND = 'second';
exports.MILLISECOND = 'millisecond';
exports.MERIDIEM = 'meridiem';
exports.DAY = 'day';
exports.MONTH = 'month';
exports.YEAR = 'year';
exports.WEEKDAY = 'weekday';
exports.TIMEZONE_OFFSET = 'timezoneOffset';
exports.WEEK = 'week';

},{}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("./parsers/parser");
var refiner_1 = require("./refiners/refiner");
function isResolver(test) {
    return test.call !== undefined;
}
exports.mergeOptions = function (options) {
    var addedTypes = {};
    var mergedOption = {
        parsers: [],
        refiners: []
    };
    options.forEach(function (maybeOption) {
        var option = isResolver(maybeOption) ? maybeOption.call(maybeOption) : maybeOption;
        if (option.parsers) {
            option.parsers.forEach(function (parser) {
                if (!addedTypes[parser.constructor.name]) {
                    mergedOption.parsers.push(parser);
                    addedTypes[parser.constructor.name] = true;
                }
            });
        }
        if (option.refiners) {
            option.refiners.forEach(function (refiner) {
                if (!addedTypes[refiner.constructor.name]) {
                    mergedOption.refiners.push(refiner);
                    addedTypes[refiner.constructor.name] = true;
                }
            });
        }
    });
    return mergedOption;
};
exports.commonPostProcessing = function () {
    return {
        refiners: [
        // These should be after all other refiners
        new refiner_1.ExtractTimezoneOffsetRefiner(), new refiner_1.ExtractTimezoneAbbrRefiner(), new refiner_1.UnlikelyFormatFilter()]
    };
};
// -------------------------------------------------------------
exports.strictOption = function () {
    var strictConfig = {
        strict: true
    };
    return exports.mergeOptions([en(strictConfig), de(strictConfig), es(strictConfig), fr(strictConfig), ja(), zh(), exports.commonPostProcessing]);
};
exports.casualOption = function () {
    return exports.mergeOptions([en.casual,
    // Some German abbreviate overlap with common English
    de({ strict: true }), es.casual, fr.casual, ja.casual, zh, exports.commonPostProcessing]);
};
// -------------------------------------------------------------
var de = function de(config) {
    return {
        parsers: [new parser_1.DEDeadlineFormatParser(config), new parser_1.DEMonthNameLittleEndianParser(config), new parser_1.DEMonthNameParser(config), new parser_1.DESlashDateFormatParser(config), new parser_1.DETimeAgoFormatParser(config), new parser_1.DETimeExpressionParser(config)],
        refiners: [new refiner_1.OverlapRemovalRefiner(), new refiner_1.ForwardDateRefiner(), new refiner_1.DEMergeDateTimeRefiner(), new refiner_1.DEMergeDateRangeRefiner()]
    };
};
exports.de = de;
de.casual = function () {
    var options = de({ strict: false });
    options.parsers.unshift(new parser_1.DECasualDateParser());
    options.parsers.unshift(new parser_1.DEWeekdayParser());
    return options;
};
// -------------------------------------------------------------
var en = function en(config) {
    return {
        parsers: [new parser_1.ENISOFormatParser(config), new parser_1.ENDeadlineFormatParser(config), new parser_1.ENMonthNameLittleEndianParser(config), new parser_1.ENMonthNameMiddleEndianParser(config), new parser_1.ENMonthNameParser(config), new parser_1.ENSlashDateFormatParser(config), new parser_1.ENSlashDateFormatStartWithYearParser(config), new parser_1.ENSlashMonthFormatParser(config), new parser_1.ENTimeAgoFormatParser(config), new parser_1.ENTimeLaterFormatParser(config), new parser_1.ENTimeExpressionParser(config)],
        refiners: [new refiner_1.OverlapRemovalRefiner(), new refiner_1.ForwardDateRefiner(),
        // English
        new refiner_1.ENMergeDateTimeRefiner(), new refiner_1.ENMergeDateRangeRefiner(), new refiner_1.ENPrioritizeSpecificDateRefiner()]
    };
};
exports.en = en;
en.casual = function () {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var options = en(Object.assign({}, config, { strict: false }));
    // EN
    options.parsers.unshift(new parser_1.ENCasualDateParser());
    options.parsers.unshift(new parser_1.ENCasualTimeParser());
    options.parsers.unshift(new parser_1.ENWeekdayParser());
    options.parsers.unshift(new parser_1.ENRelativeDateFormatParser());
    return options;
};
var en_GB = function en_GB() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return en(Object.assign({}, config, { littleEndian: true }));
};
exports.en_GB = en_GB;
en_GB.casual = function () {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return en.casual(Object.assign({}, config, { littleEndian: true }));
};
// -------------------------------------------------------------
var ja = function ja() {
    return {
        parsers: [new parser_1.JPStandardParser()],
        refiners: [new refiner_1.OverlapRemovalRefiner(), new refiner_1.ForwardDateRefiner(), new refiner_1.JPMergeDateRangeRefiner()]
    };
};
exports.ja = ja;
ja.casual = function () {
    var options = ja();
    options.parsers.unshift(new parser_1.JPCasualDateParser());
    return options;
};
// -------------------------------------------------------------
var es = function es(config) {
    return {
        parsers: [new parser_1.ESTimeAgoFormatParser(config), new parser_1.ESDeadlineFormatParser(config), new parser_1.ESTimeExpressionParser(config), new parser_1.ESMonthNameLittleEndianParser(config), new parser_1.ESSlashDateFormatParser(config)],
        refiners: [new refiner_1.OverlapRemovalRefiner(), new refiner_1.ForwardDateRefiner()]
    };
};
exports.es = es;
es.casual = function () {
    var options = es({ strict: false });
    options.parsers.unshift(new parser_1.ESCasualDateParser());
    options.parsers.unshift(new parser_1.ESWeekdayParser());
    return options;
};
// -------------------------------------------------------------
var fr = function fr(config) {
    return {
        parsers: [new parser_1.FRDeadlineFormatParser(config), new parser_1.FRMonthNameLittleEndianParser(config), new parser_1.FRSlashDateFormatParser(config), new parser_1.FRTimeAgoFormatParser(config), new parser_1.FRTimeExpressionParser(config)],
        refiners: [new refiner_1.OverlapRemovalRefiner(), new refiner_1.ForwardDateRefiner(), new refiner_1.FRMergeDateRangeRefiner(), new refiner_1.FRMergeDateTimeRefiner()]
    };
};
exports.fr = fr;
fr.casual = function () {
    var option = fr({ strict: false });
    option.parsers.unshift(new parser_1.FRCasualDateParser());
    option.parsers.unshift(new parser_1.FRWeekdayParser());
    option.parsers.unshift(new parser_1.FRRelativeDateFormatParser());
    return option;
};
// -------------------------------------------------------------
var zh = function zh() {
    return {
        parsers: [new parser_1.ZHHantDateParser(), new parser_1.ZHHantWeekdayParser(), new parser_1.ZHHantTimeExpressionParser(), new parser_1.ZHHantCasualDateParser(), new parser_1.ZHHantDeadlineFormatParser()],
        refiners: [new refiner_1.OverlapRemovalRefiner(), new refiner_1.ForwardDateRefiner()]
    };
};
exports.zh = zh;

},{"./parsers/parser":51,"./refiners/refiner":65}],6:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var moment = require("moment");
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");

var DECasualDateParser = function (_parser_1$default) {
    _inherits(DECasualDateParser, _parser_1$default);

    function DECasualDateParser() {
        _classCallCheck(this, DECasualDateParser);

        var _this = _possibleConstructorReturn(this, (DECasualDateParser.__proto__ || Object.getPrototypeOf(DECasualDateParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\W|^)(' + 'jetzt|' + '(?:heute|diesen)\\s*(morgen|vormittag|mittag|nachmittag|abend)|' + '(?:heute|diese)\\s*nacht|' + 'heute|' + '(?:(?:ü|ue)ber)?morgen(?:\\s*(morgen|vormittag|mittag|nachmittag|abend|nacht))?|' + '(?:vor)?gestern(?:\\s*(morgen|vormittag|mittag|nachmittag|abend|nacht))?|' + 'letzte\\s*nacht' + ')(?=\\W|$)', 'i');
        _this.OTHER_PATTERNS = [/(?:heute|diese)\s*nacht/, /^(?:ü|ue)bermorgen/, /^morgen/, /^gestern/, /^vorgestern/, /letzte\s*nacht/];
        _this.TAG = 'DECasualDateParser';
        return _this;
    }

    _createClass(DECasualDateParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length),
                index: index,
                ref: ref
            });
            var matchedText = result.text.toLowerCase();
            var refMoment = moment(ref);
            var startMoment = refMoment.clone();
            if (this.OTHER_PATTERNS[0].test(matchedText)) {
                // Normally means this coming midnight
                result.start.imply(constants_1.HOUR, 22);
                result.start.imply(constants_1.MERIDIEM, 1);
            } else if (this.OTHER_PATTERNS[1].test(matchedText)) {
                startMoment.add(refMoment.hour() > 1 ? 2 : 1, 'day');
            } else if (this.OTHER_PATTERNS[2].test(matchedText)) {
                // Check not "Tomorrow" on late night
                if (refMoment.hour() > 1) {
                    startMoment.add(1, 'day');
                }
            } else if (this.OTHER_PATTERNS[3].test(matchedText)) {
                startMoment.add(-1, 'day');
            } else if (this.OTHER_PATTERNS[4].test(matchedText)) {
                startMoment.add(-2, 'day');
            } else if (this.OTHER_PATTERNS[5].test(matchedText)) {
                result.start.imply(constants_1.HOUR, 0);
                if (refMoment.hour() > 6) {
                    startMoment.add(-1, 'day');
                }
            } else if (matchedText === 'jetzt') {
                result.start.imply(constants_1.HOUR, refMoment.hour());
                result.start.imply(constants_1.MINUTE, refMoment.minute());
                result.start.imply(constants_1.SECOND, refMoment.second());
                result.start.imply(constants_1.MILLISECOND, refMoment.millisecond());
            }
            var secondMatch = match[3] || match[4] || match[5];
            if (secondMatch) {
                switch (secondMatch.toLowerCase()) {
                    case 'morgen':
                        result.start.imply(constants_1.HOUR, 6);
                        break;
                    case 'vormittag':
                        result.start.imply(constants_1.HOUR, 9);
                        break;
                    case 'mittag':
                        result.start.imply(constants_1.HOUR, 12);
                        break;
                    case 'nachmittag':
                        result.start.imply(constants_1.HOUR, 15);
                        result.start.imply(constants_1.MERIDIEM, 1);
                        break;
                    case 'abend':
                        result.start.imply(constants_1.HOUR, 18);
                        result.start.imply(constants_1.MERIDIEM, 1);
                        break;
                    case 'nacht':
                        result.start.imply(constants_1.HOUR, 0);
                        break;
                }
            }
            result.start.assign(constants_1.DAY, startMoment.date());
            result.start.assign(constants_1.MONTH, startMoment.month() + 1);
            result.start.assign(constants_1.YEAR, startMoment.year());
            result.tags[this.TAG] = true;
            return result;
        }
    }]);

    return DECasualDateParser;
}(parser_1.default);

exports.default = DECasualDateParser;

},{"../../constants":4,"../../result":66,"../parser":51,"moment":2}],7:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var moment = require("moment");
var parser_1 = require("../parser");
var result_1 = require("../../result");
var DE_1 = require("../../utils/DE");
var general_1 = require("../../utils/general");

var DEDeadlineFormatParser = function (_parser_1$default) {
    _inherits(DEDeadlineFormatParser, _parser_1$default);

    function DEDeadlineFormatParser() {
        _classCallCheck(this, DEDeadlineFormatParser);

        var _this = _possibleConstructorReturn(this, (DEDeadlineFormatParser.__proto__ || Object.getPrototypeOf(DEDeadlineFormatParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\W|^)' + '(in|nach)\\s*' + '(' + DE_1.INTEGER_WORDS_PATTERN + '|[0-9]+|einigen|eine[rm]\\s*halben|eine[rm])\\s*' + '(sekunden?|min(?:ute)?n?|stunden?|tag(?:en)?|wochen?|monat(?:en)?|jahr(?:en)?)\\s*' + '(?=\\W|$)', 'i');
        _this.STRICT_PATTERN = new RegExp('(\\W|^)' + '(in|nach)\\s*' + '(' + DE_1.INTEGER_WORDS_PATTERN + '|[0-9]+|eine(?:r|m)?)\\s*' + '(sekunden?|minuten?|stunden?|tag(?:en)?)\\s*' + '(?=\\W|$)', 'i');
        _this.TAG = 'DEDeadlineFormatParser';
        return _this;
    }

    _createClass(DEDeadlineFormatParser, [{
        key: "pattern",
        value: function pattern() {
            return this.isStrictMode() ? this.STRICT_PATTERN : this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var matchedText = match[0].substr(match[1].length, match[0].length - match[1].length);
            var result = new result_1.ParsedResult({
                text: matchedText,
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var num = DE_1.matchInteger(match[3].toLowerCase());
            var matchedUnit = DE_1.matchUnit(match[4].toLowerCase());
            if (num && matchedUnit && general_1.deadlineCalculations(num, matchedUnit, result, moment(ref))) {
                return result;
            }
            return null;
        }
    }]);

    return DEDeadlineFormatParser;
}(parser_1.default);

exports.default = DEDeadlineFormatParser;

},{"../../result":66,"../../utils/DE":67,"../../utils/general":73,"../parser":51,"moment":2}],8:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
var DE_1 = require("../../utils/DE");
var general_1 = require("../../utils/general");

var DEMonthNameLittleEndianParser = function (_parser_1$default) {
    _inherits(DEMonthNameLittleEndianParser, _parser_1$default);

    function DEMonthNameLittleEndianParser() {
        _classCallCheck(this, DEMonthNameLittleEndianParser);

        var _this = _possibleConstructorReturn(this, (DEMonthNameLittleEndianParser.__proto__ || Object.getPrototypeOf(DEMonthNameLittleEndianParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\W|^)' + '(?:am\\s*?)?' + '(?:(Sonntag|Montag|Dienstag|Mittwoch|Donnerstag|Freitag|Samstag|So|Mo|Di|Mi|Do|Fr|Sa)\\s*,?\\s*)?' + '(?:den\\s*)?' + '([0-9]{1,2})\\.' + '(?:\\s*(?:bis(?:\\s*(?:am|zum))?|\\-|\\–|\\s)\\s*([0-9]{1,2})\\.)?\\s*' + '(Jan(?:uar|\\.)?|Feb(?:ruar|\\.)?|Mär(?:z|\\.)?|Maerz|Mrz\\.?|Apr(?:il|\\.)?|Mai|Jun(?:i|\\.)?|Jul(?:i|\\.)?|Aug(?:ust|\\.)?|Sep(?:t|t\\.|tember|\\.)?|Okt(?:ober|\\.)?|Nov(?:ember|\\.)?|Dez(?:ember|\\.)?)' + '(?:' + ',?\\s*([0-9]{1,4}(?![^\\s]\\d))' + '(\\s*[vn]\\.?\\s*C(?:hr)?\\.?)?' + ')?' + '(?=\\W|$)', 'i');
        _this.WEEKDAY_GROUP = 2;
        _this.DATE_GROUP = 3;
        _this.DATE_TO_GROUP = 4;
        _this.MONTH_NAME_GROUP = 5;
        _this.YEAR_GROUP = 6;
        _this.YEAR_BE_GROUP = 7;
        _this.TAG = 'DEMonthNameLittleEndianParser';
        return _this;
    }

    _createClass(DEMonthNameLittleEndianParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length, match[0].length - match[1].length),
                index: match.index + match[1].length,
                ref: ref
            });
            var month = DE_1.MONTH_OFFSET[match[this.MONTH_NAME_GROUP].toLowerCase()];
            var day = parseInt(match[this.DATE_GROUP], 10);
            result.start.assign(constants_1.DAY, day);
            result.start.assign(constants_1.MONTH, month);
            var year = DE_1.yearCalculation(match[this.YEAR_GROUP], match[this.YEAR_BE_GROUP]);
            if (year !== null) {
                result.start.assign(constants_1.YEAR, year);
            } else {
                general_1.getAppropriateYear(result.start, ref);
            }
            // Weekday component
            if (match[this.WEEKDAY_GROUP]) {
                result.start.assign(constants_1.WEEKDAY, DE_1.WEEKDAY_OFFSET[match[this.WEEKDAY_GROUP].toLowerCase()]);
            }
            // Text can be 'range' value. Such as '12 - 13 January 2012'
            if (match[this.DATE_TO_GROUP]) {
                result.end = result.start.clone();
                result.end.assign(constants_1.DAY, parseInt(match[this.DATE_TO_GROUP], 10));
            }
            result.tags[this.TAG] = true;
            return result;
        }
    }]);

    return DEMonthNameLittleEndianParser;
}(parser_1.default);

exports.default = DEMonthNameLittleEndianParser;

},{"../../constants":4,"../../result":66,"../../utils/DE":67,"../../utils/general":73,"../parser":51}],9:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
var DE_1 = require("../../utils/DE");
var general_1 = require("../../utils/general");

var DEMonthNameParser = function (_parser_1$default) {
    _inherits(DEMonthNameParser, _parser_1$default);

    function DEMonthNameParser() {
        _classCallCheck(this, DEMonthNameParser);

        var _this = _possibleConstructorReturn(this, (DEMonthNameParser.__proto__ || Object.getPrototypeOf(DEMonthNameParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(^|\\D\\s+|[^\\w\\s])' + '(Jan\\.?|Januar|Feb\\.?|Februar|Mär\\.?|M(?:ä|ae)rz|Mrz\\.?|Apr\\.?|April|Mai\\.?|Jun\\.?|Juni|Jul\\.?|Juli|Aug\\.?|August|Sep\\.?|Sept\\.?|September|Okt\\.?|Oktober|Nov\\.?|November|Dez\\.?|Dezember)' + '\\s*' + '(?:' + ',?\\s*(?:([0-9]{4})(\\s*[vn]\\.?\\s*C(?:hr)?\\.?)?|([0-9]{1,4})\\s*([vn]\\.?\\s*C(?:hr)?\\.?))' + ')?' + '(?=[^\\s\\w]|$)', 'i');
        _this.MONTH_NAME_GROUP = 2;
        _this.YEAR_GROUP = 3;
        _this.YEAR_BE_GROUP = 4;
        _this.YEAR_GROUP2 = 5;
        _this.YEAR_BE_GROUP2 = 6;
        _this.TAG = 'DEMonthNameParser';
        return _this;
    }

    _createClass(DEMonthNameParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length, match[0].length - match[1].length),
                index: match.index + match[1].length,
                ref: ref
            });
            var month = DE_1.MONTH_OFFSET[match[this.MONTH_NAME_GROUP].toLowerCase()];
            result.start.imply(constants_1.DAY, 1);
            result.start.assign(constants_1.MONTH, month);
            var year = DE_1.yearCalculation(match[this.YEAR_GROUP] || match[this.YEAR_GROUP2], match[this.YEAR_BE_GROUP] || match[this.YEAR_BE_GROUP2]);
            if (year !== null) {
                result.start.assign(constants_1.YEAR, year);
            } else {
                general_1.getAppropriateYear(result.start, ref);
            }
            result.tags[this.TAG] = true;
            return result;
        }
    }]);

    return DEMonthNameParser;
}(parser_1.default);

exports.default = DEMonthNameParser;

},{"../../constants":4,"../../result":66,"../../utils/DE":67,"../../utils/general":73,"../parser":51}],10:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
/*
    Date format with slash "/" (also "-" and ".") between numbers
    - Tuesday 11/3/2015
    - 11/3/2015
    - 11/3
*/
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
var DE_1 = require("../../utils/DE");
var moment = require("moment");

var DESlashDateFormatParser = function (_parser_1$default) {
    _inherits(DESlashDateFormatParser, _parser_1$default);

    function DESlashDateFormatParser() {
        _classCallCheck(this, DESlashDateFormatParser);

        var _this = _possibleConstructorReturn(this, (DESlashDateFormatParser.__proto__ || Object.getPrototypeOf(DESlashDateFormatParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\W|^)' + '(?:' + '(?:am\\s*?)?' + '((?:sonntag|so|montag|mo|dienstag|di|mittwoch|mi|donnerstag|do|freitag|fr|samstag|sa))' + '\\s*\\,?\\s*' + '(?:den\\s*)?' + ')?' + '([0-3]{0,1}[0-9]{1})[\\/\\.\\-]([0-3]{0,1}[0-9]{1})' + '(?:' + '[\\/\\.\\-]' + '([0-9]{4}\s*\,?\s*|[0-9]{2}\s*\,?\s*)' + ')?' + '(\\W|$)', 'i');
        _this.OPENING_GROUP = 1;
        _this.WEEKDAY_GROUP = 2;
        _this.DAY_GROUP = 3;
        _this.MONTH_GROUP = 4;
        _this.YEAR_GROUP = 5;
        _this.ENDING_GROUP = 6;
        _this.TAG = 'DESlashDateFormatParser';
        _this.OTHER_PATTERNS = [/^\d\.\d$/, /^\d\.\d{1,2}\.\d{1,2}$/];
        return _this;
    }

    _createClass(DESlashDateFormatParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            if (match[this.OPENING_GROUP] === '/' || match[this.ENDING_GROUP] === '/') {
                // Long skip, if there is some overlapping like:
                // XX[/YY/ZZ]
                // [XX/YY/]ZZ
                match.index += match[0].length;
                return null;
            }
            var index = match.index + match[this.OPENING_GROUP].length;
            var matchedText = match[0].substr(match[this.OPENING_GROUP].length, match[0].length - match[this.ENDING_GROUP].length);
            var result = new result_1.ParsedResult({
                text: matchedText,
                index: index,
                ref: ref
            });
            if (matchedText.match(this.OTHER_PATTERNS[0]) || matchedText.match(this.OTHER_PATTERNS[1])) return null;
            // MM/dd -> OK
            // MM.dd -> NG
            if (!match[this.YEAR_GROUP] && match[0].indexOf('/') < 0) return null;
            var year = parseInt(match[this.YEAR_GROUP] || moment(ref).year() + '', 10);
            var month = parseInt(match[this.MONTH_GROUP], 10);
            var day = parseInt(match[this.DAY_GROUP], 10);
            if (month < 1 || month > 12 || day < 1 || day > 31) return null;
            if (year < 100) {
                if (year > 50) {
                    year = year + 1900;
                } else {
                    year = year + 2000;
                }
            }
            result.start.assign(constants_1.DAY, day);
            result.start.assign(constants_1.MONTH, month);
            result.start.assign(constants_1.YEAR, year);
            // Day of week
            if (match[this.WEEKDAY_GROUP]) {
                result.start.assign(constants_1.WEEKDAY, DE_1.WEEKDAY_OFFSET[match[this.WEEKDAY_GROUP].toLowerCase()]);
            }
            result.tags[this.TAG] = true;
            return result;
        }
    }]);

    return DESlashDateFormatParser;
}(parser_1.default);

exports.default = DESlashDateFormatParser;

},{"../../constants":4,"../../result":66,"../../utils/DE":67,"../parser":51,"moment":2}],11:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
var DE_1 = require("../../utils/DE");
var moment = require("moment");
var MODE;
(function (MODE) {
    MODE[MODE["TIME"] = 0] = "TIME";
    MODE[MODE["DATE"] = 1] = "DATE";
    MODE[MODE["WEEK"] = 2] = "WEEK";
    MODE[MODE["NONE"] = 3] = "NONE";
})(MODE || (MODE = {}));

var DETimeAgoFormatParser = function (_parser_1$default) {
    _inherits(DETimeAgoFormatParser, _parser_1$default);

    function DETimeAgoFormatParser() {
        _classCallCheck(this, DETimeAgoFormatParser);

        var _this = _possibleConstructorReturn(this, (DETimeAgoFormatParser.__proto__ || Object.getPrototypeOf(DETimeAgoFormatParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('' + '(\\W|^)vor\\s*' + '(' + DE_1.INTEGER_WORDS_PATTERN + '|[0-9]+|einigen|eine[rm]\\s*halben|eine[rm])\\s*' + '(sekunden?|min(?:ute)?n?|stunden?|wochen?|tag(?:en)?|monat(?:en)?|jahr(?:en)?)\\s*' + '(?=(?:\\W|$))', 'i');
        _this.STRICT_PATTERN = new RegExp('' + '(\\W|^)vor\\s*' + '([0-9]+|eine(?:r|m))\\s*' + '(sekunden?|minuten?|stunden?|tag(?:en)?)' + '(?=(?:\\W|$))', 'i');
        _this.TAG = 'DETimeAgoFormatParser';
        return _this;
    }

    _createClass(DETimeAgoFormatParser, [{
        key: "pattern",
        value: function pattern() {
            return this.isStrictMode() ? this.STRICT_PATTERN : this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            if (match.index > 0 && text[match.index - 1].match(/\w/)) return null;
            var matchedText = match[0].substr(match[1].length, match[0].length - match[1].length);
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: matchedText,
                index: index,
                ref: ref
            });
            var matchedUnit = DE_1.matchUnit(match[3].toLowerCase());
            if (matchedUnit) {
                var num = DE_1.matchInteger(match[2].toLowerCase());
                var momentRef = moment(ref);
                var mode = MODE.NONE;
                switch (matchedUnit) {
                    case constants_1.HOUR:
                        momentRef.add(-num, 'hour');
                        mode = MODE.TIME;
                        break;
                    case constants_1.MINUTE:
                        momentRef.add(-num, 'minute');
                        mode = MODE.TIME;
                        break;
                    case constants_1.SECOND:
                        momentRef.add(-num, 'second');
                        mode = MODE.TIME;
                        break;
                    case constants_1.DAY:
                        momentRef.add(-num, 'd');
                        mode = MODE.DATE;
                        break;
                    case constants_1.MONTH:
                        momentRef.add(-num, 'month');
                        mode = MODE.DATE;
                        break;
                    case constants_1.YEAR:
                        momentRef.add(-num, 'year');
                        mode = MODE.DATE;
                        break;
                    case constants_1.WEEK:
                        momentRef.add(-num, 'week');
                        mode = MODE.WEEK;
                        break;
                }
                if (mode !== MODE.NONE) {
                    result.tags[this.TAG] = true;
                    switch (mode) {
                        case MODE.WEEK:
                            result.start.imply(constants_1.DAY, momentRef.date());
                            result.start.imply(constants_1.MONTH, momentRef.month() + 1);
                            result.start.imply(constants_1.YEAR, momentRef.year());
                            result.start.imply(constants_1.WEEKDAY, momentRef.day());
                            break;
                        case MODE.DATE:
                            result.start.assign(constants_1.DAY, momentRef.date());
                            result.start.assign(constants_1.MONTH, momentRef.month() + 1);
                            result.start.assign(constants_1.YEAR, momentRef.year());
                            break;
                        case MODE.TIME:
                            result.start.imply(constants_1.DAY, momentRef.date());
                            result.start.imply(constants_1.MONTH, momentRef.month() + 1);
                            result.start.imply(constants_1.YEAR, momentRef.year());
                            result.start.assign(constants_1.HOUR, momentRef.hour());
                            result.start.assign(constants_1.MINUTE, momentRef.minute());
                            result.start.assign(constants_1.SECOND, momentRef.second());
                            break;
                    }
                    return result;
                }
            }
            return null;
        }
    }]);

    return DETimeAgoFormatParser;
}(parser_1.default);

exports.default = DETimeAgoFormatParser;

},{"../../constants":4,"../../result":66,"../../utils/DE":67,"../parser":51,"moment":2}],12:[function(require,module,exports){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
var moment = require("moment");

var DETimeExpressionParser = function (_parser_1$default) {
    _inherits(DETimeExpressionParser, _parser_1$default);

    function DETimeExpressionParser() {
        _classCallCheck(this, DETimeExpressionParser);

        var _this = _possibleConstructorReturn(this, (DETimeExpressionParser.__proto__ || Object.getPrototypeOf(DETimeExpressionParser)).apply(this, arguments));

        _this.PATTERN = new RegExp("(^|\\s|T)" + "(?:(?:um|von)\\s*)?" + "(\\d{1,4}|mittags?|mitternachts?)" + "(?:" + "(?:\\.|\\:|\\：)(\\d{1,2})" + "(?:" + "(?:\\:|\\：)(\\d{2})" + ")?" + ")?" + "(?:\\s*uhr)?" + "(?:\\s*(morgens|vormittags|mittags|nachmittags|abends|nachts))?" + "(?=\\W|$)", 'i');
        _this.END_PATTERN = new RegExp("^\\s*" + "(\\-|\\–|\\~|\\〜|bis|\\?)\\s*" + "(\\d{1,4})" + "(?:" + "(?:\\.|\\:|\\：)(\\d{1,2})" + "(?:" + "(?:\\.|\\:|\\：)(\\d{1,2})" + ")?" + ")?" + "(?:\\s*(morgens|vormittags|mittags|nachmittags|abends|nachts))?" + "(?=\\W|$)", 'i');
        _this.HOUR_GROUP = 2;
        _this.MINUTE_GROUP = 3;
        _this.SECOND_GROUP = 4;
        _this.AM_PM_HOUR_GROUP = 5;
        _this.TAG = 'DETimeExpressionParser';
        _this.OTHER_PATTERNS = [/mittags?/i, /mitternachts?/i, /^\s*([+\-])\s*\d{3,4}$/, /^\d+$/];
        return _this;
    }

    _createClass(DETimeExpressionParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            // This pattern can be overlaped Ex. [12] AM, 1[2] AM
            if (match.index > 0 && text[match.index - 1].match(/\w/)) return null;
            var refMoment = moment(ref);
            var result = new result_1.ParsedResult({
                text: match[0].substring(match[1].length),
                index: match.index + match[1].length,
                ref: ref
            });
            result.tags[this.TAG] = true;
            result.start.imply(constants_1.DAY, refMoment.date());
            result.start.imply(constants_1.MONTH, refMoment.month() + 1);
            result.start.imply(constants_1.YEAR, refMoment.year());
            if (!this.extractFirstChunk(result, match)) {
                return null;
            }
            if (!this.extractSecondChunk(text, result) && result.text.match(this.OTHER_PATTERNS[3])) {
                return null;
            }
            return result;
        }
    }, {
        key: "extractFirstChunk",
        value: function extractFirstChunk(result, match) {
            var time = this.getTime(match);
            if (!time) {
                return false;
            }

            var _time = _slicedToArray(time, 4),
                hour = _time[0],
                minute = _time[1],
                second = _time[2],
                meridiem = _time[3];

            if (second > -1) {
                result.start.assign(constants_1.SECOND, second);
            }
            // ----- AM & PM
            if (match[this.AM_PM_HOUR_GROUP]) {
                if (hour > 12) return false;
                var ampm = match[this.AM_PM_HOUR_GROUP].toLowerCase();
                if (ampm === 'morgens' || ampm === 'vormittags') {
                    meridiem = 0;
                    if (hour === 12) hour = 0;
                } else {
                    meridiem = 1;
                    if (hour !== 12) hour += 12;
                }
            }
            result.start.assign(constants_1.HOUR, hour);
            result.start.assign(constants_1.MINUTE, minute);
            if (meridiem >= 0) {
                result.start.assign(constants_1.MERIDIEM, meridiem);
            } else {
                if (hour < 12) {
                    result.start.imply(constants_1.MERIDIEM, 0);
                } else {
                    result.start.imply(constants_1.MERIDIEM, 1);
                }
            }
            return true;
        }
    }, {
        key: "extractSecondChunk",
        value: function extractSecondChunk(text, result) {
            var match = this.END_PATTERN.exec(text.substring(result.index + result.text.length));
            if (!match) {
                return false;
            }
            // Pattern "YY.YY -XXXX" is more like timezone offset
            if (match[0].match(this.OTHER_PATTERNS[2])) {
                return true;
            }
            var time = this.getTime(match);
            if (!time) {
                return true;
            }

            var _time2 = _slicedToArray(time, 4),
                hour = _time2[0],
                minute = _time2[1],
                second = _time2[2],
                meridiem = _time2[3];

            if (!result.end) {
                result.end = new result_1.ParsedComponents(undefined, result.start.date());
            }
            if (second > -1) {
                result.end.assign(constants_1.SECOND, second);
            }
            // ----- AM & PM
            if (match[this.AM_PM_HOUR_GROUP]) {
                if (hour > 12) return false;
                var ampm = match[this.AM_PM_HOUR_GROUP].toLowerCase();
                if (ampm === 'morgens' || ampm === 'vormittags') {
                    meridiem = 0;
                    if (hour === 12) {
                        hour = 0;
                        if (!result.end.isCertain(constants_1.DAY)) {
                            result.end.imply(constants_1.DAY, result.end.get(constants_1.DAY) + 1);
                        }
                    }
                } else {
                    meridiem = 1;
                    if (hour !== 12) hour += 12;
                }
                if (!result.start.isCertain(constants_1.MERIDIEM)) {
                    if (meridiem === 0) {
                        result.start.imply(constants_1.MERIDIEM, 0);
                        if (result.start.get(constants_1.HOUR) === 12) {
                            result.start.assign(constants_1.HOUR, 0);
                        }
                    } else {
                        result.start.imply(constants_1.MERIDIEM, 1);
                        if (result.start.get(constants_1.HOUR) !== 12) {
                            result.start.assign(constants_1.HOUR, result.start.get(constants_1.HOUR) + 12);
                        }
                    }
                }
            }
            result.text = result.text + match[0];
            result.end.assign(constants_1.HOUR, hour);
            result.end.assign(constants_1.MINUTE, minute);
            if (meridiem >= 0) {
                result.end.assign(constants_1.MERIDIEM, meridiem);
            } else {
                var startAtPM = result.start.isCertain(constants_1.MERIDIEM) && result.start.get(constants_1.MERIDIEM) === 1;
                if (startAtPM && result.start.get(constants_1.HOUR) > hour) {
                    // 10pm - 1 (am)
                    result.end.imply(constants_1.MERIDIEM, 0);
                } else if (hour > 12) {
                    result.end.imply(constants_1.MERIDIEM, 1);
                }
            }
            if (result.end.date().getTime() < result.start.date().getTime()) {
                result.end.imply(constants_1.DAY, result.end.get(constants_1.DAY) + 1);
            }
            return true;
        }
    }, {
        key: "getTime",
        value: function getTime(match) {
            var second = -1;
            var hour = 0;
            var minute = 0;
            var meridiem = -1;
            // ----- Second
            if (match[this.SECOND_GROUP]) {
                second = parseInt(match[this.SECOND_GROUP], 10);
                if (second >= 60) return false;
            }
            // ----- Hours
            if (this.OTHER_PATTERNS[0].test(match[this.HOUR_GROUP])) {
                meridiem = 1;
                hour = 12;
            } else if (this.OTHER_PATTERNS[1].test(match[this.HOUR_GROUP])) {
                meridiem = 0;
                hour = 0;
            } else {
                hour = parseInt(match[this.HOUR_GROUP], 10);
            }
            // ----- Minutes
            if (match[this.MINUTE_GROUP]) {
                minute = parseInt(match[this.MINUTE_GROUP], 10);
            } else if (hour > 100) {
                minute = hour % 100;
                hour = Math.floor(hour / 100);
            }
            if (minute >= 60) {
                return false;
            }
            if (hour > 24) {
                return false;
            }
            if (hour >= 12) {
                meridiem = 1;
            }
            return [hour, minute, second, meridiem];
        }
    }]);

    return DETimeExpressionParser;
}(parser_1.default);

exports.default = DETimeExpressionParser;

},{"../../constants":4,"../../result":66,"../parser":51,"moment":2}],13:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var DE_1 = require("../../utils/DE");
var moment = require("moment");
var constants_1 = require("../../constants");

var DEWeekdayParser = function (_parser_1$default) {
    _inherits(DEWeekdayParser, _parser_1$default);

    function DEWeekdayParser() {
        _classCallCheck(this, DEWeekdayParser);

        var _this = _possibleConstructorReturn(this, (DEWeekdayParser.__proto__ || Object.getPrototypeOf(DEWeekdayParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\W|^)' + '(?:(?:\\,|\\(|\\（)\\s*)?' + '(?:a[mn]\\s*?)?' + '(?:(diese[mn]|letzte[mn]|n(?:ä|ae)chste[mn])\\s*)?' + '(' + Object.keys(DE_1.WEEKDAY_OFFSET).join('|') + ')' + '(?:\\s*(?:\\,|\\)|\\）))?' + '(?:\\s*(diese|letzte|n(?:ä|ae)chste)\\s*woche)?' + '(?=\\W|$)', 'i');
        _this.PREFIX_GROUP = 2;
        _this.WEEKDAY_GROUP = 3;
        _this.POSTFIX_GROUP = 4;
        _this.OTHER_PATTERNS = [/letzte/, /n(?:ä|ae)chste/, /diese/];
        _this.TAG = 'DEWeekdayParser';
        return _this;
    }

    _createClass(DEWeekdayParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var matchedText = match[0].substr(match[1].length, match[0].length - match[1].length);
            var result = new result_1.ParsedResult({
                text: matchedText,
                index: index,
                ref: ref
            });
            var offset = DE_1.WEEKDAY_OFFSET[match[this.WEEKDAY_GROUP].toLowerCase()];
            if (offset === undefined) return null;
            var startMoment = moment(ref);
            var prefix = match[this.PREFIX_GROUP];
            var postfix = match[this.POSTFIX_GROUP];
            var refOffset = startMoment.day();
            var norm = (prefix || postfix || '').toLowerCase();
            if (this.OTHER_PATTERNS[0].test(norm)) {
                startMoment.day(offset - 7);
            } else if (this.OTHER_PATTERNS[1].test(norm)) {
                startMoment.day(offset + 7);
            } else if (this.OTHER_PATTERNS[2].test(norm)) {
                if (opt.forwardDate && refOffset > offset) {
                    startMoment.day(offset + 7);
                } else {
                    startMoment.day(offset);
                }
            } else {
                var calcOffset = offset - refOffset;
                var absOffset = Math.abs(calcOffset);
                if (opt.forwardDate && refOffset > offset) {
                    startMoment.day(offset + 7);
                } else if (!opt.forwardDate && Math.abs(calcOffset - 7) < absOffset) {
                    startMoment.day(offset - 7);
                } else if (!opt.forwardDate && Math.abs(calcOffset + 7) < absOffset) {
                    startMoment.day(offset + 7);
                } else {
                    startMoment.day(offset);
                }
            }
            result.tags[this.TAG] = true;
            result.start.assign(constants_1.WEEKDAY, offset);
            result.start.imply(constants_1.DAY, startMoment.date());
            result.start.imply(constants_1.MONTH, startMoment.month() + 1);
            result.start.imply(constants_1.YEAR, startMoment.year());
            return result;
        }
    }]);

    return DEWeekdayParser;
}(parser_1.default);

exports.default = DEWeekdayParser;

},{"../../constants":4,"../../result":66,"../../utils/DE":67,"../parser":51,"moment":2}],14:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var moment = require("moment");
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");

var ENCasualDateParser = function (_parser_1$default) {
    _inherits(ENCasualDateParser, _parser_1$default);

    function ENCasualDateParser() {
        _classCallCheck(this, ENCasualDateParser);

        var _this = _possibleConstructorReturn(this, (ENCasualDateParser.__proto__ || Object.getPrototypeOf(ENCasualDateParser)).apply(this, arguments));

        _this.PATTERN = /(\W|^)(now|today|tonight|last\s*night|(?:tomorrow|tmr|yesterday)\s*|tomorrow|tmr|yesterday)(?=\W|$)/i;
        _this.OTHER_PATTERNS = [/^tomorrow|^tmr/, /^yesterday/, /last\s*night/];
        _this.TAG = 'ENCasualDateParser';
        return _this;
    }

    _createClass(ENCasualDateParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length),
                index: index,
                ref: ref
            });
            var refMoment = moment(ref);
            var startMoment = refMoment.clone();
            var matchedText = result.text.toLowerCase();
            if (matchedText === 'tonight') {
                // Normally means this coming midnight
                result.start.imply(constants_1.HOUR, 22);
                result.start.imply(constants_1.MERIDIEM, 1);
            } else if (this.OTHER_PATTERNS[0].test(matchedText)) {
                // Check not "Tomorrow" on late night
                if (refMoment.hour() > 1) {
                    startMoment.add(1, 'day');
                }
            } else if (this.OTHER_PATTERNS[1].test(matchedText)) {
                startMoment.add(-1, 'day');
            } else if (matchedText.match(this.OTHER_PATTERNS[2])) {
                result.start.imply(constants_1.HOUR, 0);
                if (refMoment.hour() > 6) {
                    startMoment.add(-1, 'day');
                }
            } else if (matchedText.match("now")) {
                result.start.assign(constants_1.HOUR, refMoment.hour());
                result.start.assign(constants_1.MINUTE, refMoment.minute());
                result.start.assign(constants_1.SECOND, refMoment.second());
                result.start.assign(constants_1.MILLISECOND, refMoment.millisecond());
            }
            result.start.assign(constants_1.DAY, startMoment.date());
            result.start.assign(constants_1.MONTH, startMoment.month() + 1);
            result.start.assign(constants_1.YEAR, startMoment.year());
            result.tags[this.TAG] = true;
            return result;
        }
    }]);

    return ENCasualDateParser;
}(parser_1.default);

exports.default = ENCasualDateParser;

},{"../../constants":4,"../../result":66,"../parser":51,"moment":2}],15:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");

var ENCasualTimeParser = function (_parser_1$default) {
    _inherits(ENCasualTimeParser, _parser_1$default);

    function ENCasualTimeParser() {
        _classCallCheck(this, ENCasualTimeParser);

        var _this = _possibleConstructorReturn(this, (ENCasualTimeParser.__proto__ || Object.getPrototypeOf(ENCasualTimeParser)).apply(this, arguments));

        _this.PATTERN = /(\W|^)((this)?\s*(morning|afternoon|evening|noon))/i;
        _this.TIME_MATCH = 4;
        _this.TIME_MATCH_ALT = 3;
        _this.TAG = 'ENCasualTimeParser';
        return _this;
    }

    _createClass(ENCasualTimeParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var matchedText = (match[this.TIME_MATCH] || match[this.TIME_MATCH_ALT]).toLowerCase();
            if (matchedText == "afternoon") {
                result.start.imply(constants_1.HOUR, opt.afternoon);
            } else if (matchedText == "evening") {
                result.start.imply(constants_1.HOUR, opt.evening);
            } else if (matchedText == "morning") {
                result.start.imply(constants_1.HOUR, opt.morning);
            } else if (matchedText == "noon") {
                result.start.imply(constants_1.HOUR, opt.noon);
            }
            return result;
        }
    }]);

    return ENCasualTimeParser;
}(parser_1.default);

exports.default = ENCasualTimeParser;

},{"../../constants":4,"../../result":66,"../parser":51}],16:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var EN_1 = require("../../utils/EN");
var moment = require("moment");
var general_1 = require("../../utils/general");

var ENDeadlineFormatParser = function (_parser_1$default) {
    _inherits(ENDeadlineFormatParser, _parser_1$default);

    function ENDeadlineFormatParser() {
        _classCallCheck(this, ENDeadlineFormatParser);

        var _this = _possibleConstructorReturn(this, (ENDeadlineFormatParser.__proto__ || Object.getPrototypeOf(ENDeadlineFormatParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\W|^)' + '(within|in)\\s*' + '(' + EN_1.INTEGER_WORDS_PATTERN + '|[0-9]+|an?(?:\\s*few)?|half(?:\\s*an?)?)\\s*' + '(seconds?|min(?:ute)?s?|hours?|days?|weeks?|months?|years?)\\s*' + '(?=\\W|$)', 'i');
        _this.STRICT_PATTERN = new RegExp('(\\W|^)' + '(within|in)\\s*' + '(' + EN_1.INTEGER_WORDS_PATTERN + '|[0-9]+|an?)\\s*' + '(seconds?|minutes?|hours?|days?)\\s*' + '(?=\\W|$)', 'i');
        _this.NUM_MATCH = 3;
        _this.UNIT_MATCH = 4;
        _this.TAG = 'ENDeadlineFormatParser';
        return _this;
    }

    _createClass(ENDeadlineFormatParser, [{
        key: "pattern",
        value: function pattern() {
            return this.isStrictMode() ? this.STRICT_PATTERN : this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length, match[0].length - match[1].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var num = EN_1.matchInteger(match[this.NUM_MATCH].toLowerCase());
            var matchedUnit = EN_1.matchUnit(match[this.UNIT_MATCH].toLowerCase());
            if (num && matchedUnit && general_1.deadlineCalculations(num, matchedUnit, result, moment(ref))) {
                return result;
            }
            return null;
        }
    }]);

    return ENDeadlineFormatParser;
}(parser_1.default);

exports.default = ENDeadlineFormatParser;

},{"../../result":66,"../../utils/EN":68,"../../utils/general":73,"../parser":51,"moment":2}],17:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
/*
    ISO 8601
    http://www.w3.org/TR/NOTE-datetime
    - YYYY-MM-DD
    - YYYY-MM-DDThh:mmTZD
    - YYYY-MM-DDThh:mm:ssTZD
    - YYYY-MM-DDThh:mm:ss.sTZD
    - TZD = (Z or +hh:mm or -hh:mm)
*/
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");

var ENISOFormatParser = function (_parser_1$default) {
    _inherits(ENISOFormatParser, _parser_1$default);

    function ENISOFormatParser() {
        _classCallCheck(this, ENISOFormatParser);

        var _this = _possibleConstructorReturn(this, (ENISOFormatParser.__proto__ || Object.getPrototypeOf(ENISOFormatParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\W|^)' + '([0-9]{4})\\-([0-9]{1,2})\\-([0-9]{1,2})' + '(?:T' //..
        + '([0-9]{1,2}):([0-9]{1,2})' // hh:mm
        + '(?::([0-9]{1,2})(?:\\.(\\d{1,4}))?)?' // :ss.s
        + '(?:Z|([+-]\\d{2}):?(\\d{2})?)?' // TZD (Z or ±hh:mm or ±hhmm or ±hh)
        + ')?' //..
        + '(?=\\W|$)', 'i');
        _this.YEAR_NUMBER_GROUP = 2;
        _this.MONTH_NUMBER_GROUP = 3;
        _this.DATE_NUMBER_GROUP = 4;
        _this.HOUR_NUMBER_GROUP = 5;
        _this.MINUTE_NUMBER_GROUP = 6;
        _this.SECOND_NUMBER_GROUP = 7;
        _this.MILLISECOND_NUMBER_GROUP = 8;
        _this.TZD_HOUR_OFFSET_GROUP = 9;
        _this.TZD_MINUTE_OFFSET_GROUP = 10;
        _this.TAG = 'ENISOFormatParser';
        return _this;
    }

    _createClass(ENISOFormatParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            result.start.assign(constants_1.YEAR, parseInt(match[this.YEAR_NUMBER_GROUP], 10));
            result.start.assign(constants_1.MONTH, parseInt(match[this.MONTH_NUMBER_GROUP], 10));
            result.start.assign(constants_1.DAY, parseInt(match[this.DATE_NUMBER_GROUP], 10));
            if (result.start.get(constants_1.MONTH) > 12 || result.start.get(constants_1.MONTH) < 1 || result.start.get(constants_1.DAY) > 31 || result.start.get(constants_1.DAY) < 1) {
                return null;
            }
            if (match[this.HOUR_NUMBER_GROUP] != null) {
                result.start.assign(constants_1.HOUR, parseInt(match[this.HOUR_NUMBER_GROUP], 10));
                result.start.assign(constants_1.MINUTE, parseInt(match[this.MINUTE_NUMBER_GROUP], 10));
                if (match[this.SECOND_NUMBER_GROUP] != null) {
                    result.start.assign(constants_1.SECOND, parseInt(match[this.SECOND_NUMBER_GROUP], 10));
                }
                if (match[this.MILLISECOND_NUMBER_GROUP] != null) {
                    result.start.assign(constants_1.MILLISECOND, parseInt(match[this.MILLISECOND_NUMBER_GROUP], 10));
                }
                if (match[this.TZD_HOUR_OFFSET_GROUP] == null) {
                    result.start.assign(constants_1.TIMEZONE_OFFSET, 0);
                } else {
                    var minuteOffset = 0;
                    var hourOffset = parseInt(match[this.TZD_HOUR_OFFSET_GROUP], 10);
                    if (match[this.TZD_MINUTE_OFFSET_GROUP] != null) minuteOffset = parseInt(match[this.TZD_MINUTE_OFFSET_GROUP], 10);
                    var offset = hourOffset * 60;
                    if (offset < 0) {
                        offset -= minuteOffset;
                    } else {
                        offset += minuteOffset;
                    }
                    result.start.assign(constants_1.TIMEZONE_OFFSET, offset);
                }
            }
            return result;
        }
    }]);

    return ENISOFormatParser;
}(parser_1.default);

exports.default = ENISOFormatParser;

},{"../../constants":4,"../../result":66,"../parser":51}],18:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var EN_1 = require("../../utils/EN");
var constants_1 = require("../../constants");
var general_1 = require("../../utils/general");

var ENMonthNameLittleEndianParser = function (_parser_1$default) {
    _inherits(ENMonthNameLittleEndianParser, _parser_1$default);

    function ENMonthNameLittleEndianParser() {
        _classCallCheck(this, ENMonthNameLittleEndianParser);

        var _this = _possibleConstructorReturn(this, (ENMonthNameLittleEndianParser.__proto__ || Object.getPrototypeOf(ENMonthNameLittleEndianParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\W|^)' + '(?:on\\s*?)?' + '(?:(Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sun|Mon|Tue|Wed|Thu|Fri|Sat)\\s*,?\\s*)?' + '(([0-9]{1,2})(?:st|nd|rd|th)?|' + EN_1.ORDINAL_WORDS_PATTERN + ')' + '(?:\\s*' + '(?:to|\\-|\\–|until|through|till|\\s)\\s*' + '(([0-9]{1,2})(?:st|nd|rd|th)?|' + EN_1.ORDINAL_WORDS_PATTERN + ')' + ')?' + '(?:-|\/|\\s*(?:of)?\\s*)' + '(Jan(?:uary|\\.)?|Feb(?:ruary|\\.)?|Mar(?:ch|\\.)?|Apr(?:il|\\.)?|May|Jun(?:e|\\.)?|Jul(?:y|\\.)?|Aug(?:ust|\\.)?|Sep(?:tember|\\.)?|Oct(?:ober|\\.)?|Nov(?:ember|\\.)?|Dec(?:ember|\\.)?)' + '(?:' + '(?:-|\/|,?\\s*)' + '((?:' + '[1-9][0-9]{0,3}\\s*(?:BE|AD|BC)|' + '[1-2][0-9]{3}' + ')(?![^\\s]\\d))' + ')?' + '(?=\\W|$)', 'i');
        _this.WEEKDAY_GROUP = 2;
        _this.DATE_GROUP = 3;
        _this.DATE_NUM_GROUP = 4;
        _this.DATE_TO_GROUP = 5;
        _this.DATE_TO_NUM_GROUP = 6;
        _this.MONTH_NAME_GROUP = 7;
        _this.YEAR_GROUP = 8;
        _this.TAG = 'ENMonthNameLittleEndianParser';
        return _this;
    }

    _createClass(ENMonthNameLittleEndianParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length, match[0].length - match[1].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var month = EN_1.MONTH_OFFSET[match[this.MONTH_NAME_GROUP].toLowerCase()];
            if (!(month || month === 0)) {
                return null;
            }
            var day = match[this.DATE_NUM_GROUP] ? parseInt(match[this.DATE_NUM_GROUP], 10) : EN_1.ORDINAL_WORDS[match[this.DATE_GROUP].trim().replace('-', ' ').toLowerCase()];
            if (!day) {
                return null;
            }
            result.start.assign(constants_1.DAY, day);
            result.start.assign(constants_1.MONTH, month);
            var year = EN_1.yearCalculation(match[this.YEAR_GROUP]);
            if (year) {
                result.start.assign(constants_1.YEAR, year);
            } else {
                general_1.getAppropriateYear(result.start, ref);
            }
            // Weekday component
            if (match[this.WEEKDAY_GROUP]) {
                var weekday = EN_1.WEEKDAY_OFFSET[match[this.WEEKDAY_GROUP].toLowerCase()];
                if (weekday || weekday === 0) {
                    result.start.assign(constants_1.WEEKDAY, weekday);
                }
            }
            // Text can be 'range' value. Such as '12 - 13 January 2012'
            if (match[this.DATE_TO_GROUP]) {
                var endDate = match[this.DATE_TO_NUM_GROUP] ? parseInt(match[this.DATE_TO_NUM_GROUP], 10) : EN_1.ORDINAL_WORDS[match[this.DATE_TO_GROUP].trim().replace('-', ' ').toLowerCase()];
                if (endDate) {
                    result.end = result.start.clone();
                    result.end.assign(constants_1.DAY, endDate);
                }
            }
            return result;
        }
    }]);

    return ENMonthNameLittleEndianParser;
}(parser_1.default);

exports.default = ENMonthNameLittleEndianParser;

},{"../../constants":4,"../../result":66,"../../utils/EN":68,"../../utils/general":73,"../parser":51}],19:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
/*

    The parser for parsing US's date format that begin with month's name.

    EX.
        - January 13
        - January 13, 2012
        - January 13 - 15, 2012
        - Tuesday, January 13, 2012

    Watch out for:
        - January 12:00
        - January 12.44
        - January 1222344
*/
var parser_1 = require("../parser");
var result_1 = require("../../result");
var EN_1 = require("../../utils/EN");
var constants_1 = require("../../constants");
var general_1 = require("../../utils/general");

var ENMonthNameMiddleEndianParser = function (_parser_1$default) {
    _inherits(ENMonthNameMiddleEndianParser, _parser_1$default);

    function ENMonthNameMiddleEndianParser() {
        _classCallCheck(this, ENMonthNameMiddleEndianParser);

        var _this = _possibleConstructorReturn(this, (ENMonthNameMiddleEndianParser.__proto__ || Object.getPrototypeOf(ENMonthNameMiddleEndianParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\W|^)' + '(?:' + '(?:on\\s*?)?' + '(Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sun\\.?|Mon\\.?|Tue\\.?|Wed\\.?|Thu\\.?|Fri\\.?|Sat\\.?)' + '\\s*,?\\s*)?' + '(Jan\\.?|January|Feb\\.?|February|Mar\\.?|March|Apr\\.?|April|May\\.?|Jun\\.?|June|Jul\\.?|July|Aug\\.?|August|Sep\\.?|Sept\\.?|September|Oct\\.?|October|Nov\\.?|November|Dec\\.?|December)' + '(?:-|\/|\\s*,?\\s*)' + '(([0-9]{1,2})(?:st|nd|rd|th)?|' + EN_1.ORDINAL_WORDS_PATTERN + ')(?!\\s*(?:am|pm))\\s*' + '' + '(?:' + '(?:to|\\-)\\s*' + '(([0-9]{1,2})(?:st|nd|rd|th)?| ' + EN_1.ORDINAL_WORDS_PATTERN + ')\\s*' + ')?' + '(?:' + '(?:-|\/|\\s*,?\\s*)' + '(?:([0-9]{4})\\s*(BE|AD|BC)?|([0-9]{1,4})\\s*(AD|BC))\\s*' + ')?' + '(?=\\W|$)(?!\\:\\d)', 'i');
        _this.WEEKDAY_GROUP = 2;
        _this.MONTH_NAME_GROUP = 3;
        _this.DATE_GROUP = 4;
        _this.DATE_NUM_GROUP = 5;
        _this.DATE_TO_GROUP = 6;
        _this.DATE_TO_NUM_GROUP = 7;
        _this.YEAR_GROUP = 8;
        _this.YEAR_BE_GROUP = 9;
        _this.YEAR_GROUP2 = 10;
        _this.YEAR_BE_GROUP2 = 11;
        _this.TAG = 'ENMonthNameMiddleEndianParser';
        return _this;
    }

    _createClass(ENMonthNameMiddleEndianParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length, match[0].length - match[1].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var month = EN_1.MONTH_OFFSET[match[this.MONTH_NAME_GROUP].toLowerCase()];
            if (!(month || month === 0)) {
                return null;
            }
            var day = match[this.DATE_NUM_GROUP] ? parseInt(match[this.DATE_NUM_GROUP], 10) : EN_1.ORDINAL_WORDS[match[this.DATE_GROUP].trim().replace('-', ' ').toLowerCase()];
            if (!day) {
                return null;
            }
            result.start.assign(constants_1.DAY, day);
            result.start.assign(constants_1.MONTH, month);
            var year = EN_1.yearCalculation(match[this.YEAR_GROUP] || match[this.YEAR_GROUP2], match[this.YEAR_BE_GROUP] || match[this.YEAR_BE_GROUP2]);
            if (year) {
                result.start.assign(constants_1.YEAR, year);
            } else {
                general_1.getAppropriateYear(result.start, ref);
            }
            // Weekday component
            if (match[this.WEEKDAY_GROUP]) {
                var weekday = EN_1.WEEKDAY_OFFSET[match[this.WEEKDAY_GROUP].toLowerCase()];
                if (weekday || weekday === 0) {
                    result.start.assign(constants_1.WEEKDAY, weekday);
                }
            }
            // Text can be 'range' value. Such as '12 - 13 January 2012'
            if (match[this.DATE_TO_GROUP]) {
                var endDate = match[this.DATE_TO_NUM_GROUP] ? parseInt(match[this.DATE_TO_NUM_GROUP], 10) : EN_1.ORDINAL_WORDS[match[this.DATE_TO_GROUP].trim().replace('-', ' ').toLowerCase()];
                if (endDate) {
                    result.end = result.start.clone();
                    result.end.assign(constants_1.DAY, endDate);
                }
            }
            return result;
        }
    }]);

    return ENMonthNameMiddleEndianParser;
}(parser_1.default);

exports.default = ENMonthNameMiddleEndianParser;

},{"../../constants":4,"../../result":66,"../../utils/EN":68,"../../utils/general":73,"../parser":51}],20:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
/*
    
    The parser for parsing month name and year.
    
    EX.
        - January
        - January 2012
        - January, 2012
*/
var parser_1 = require("../parser");
var result_1 = require("../../result");
var EN_1 = require("../../utils/EN");
var constants_1 = require("../../constants");
var general_1 = require("../../utils/general");

var ENMonthNameParser = function (_parser_1$default) {
    _inherits(ENMonthNameParser, _parser_1$default);

    function ENMonthNameParser() {
        _classCallCheck(this, ENMonthNameParser);

        var _this = _possibleConstructorReturn(this, (ENMonthNameParser.__proto__ || Object.getPrototypeOf(ENMonthNameParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(^|\\D\\s+|[^\\w\\s])' + '(Jan\\.?|January|Feb\\.?|February|Mar\\.?|March|Apr\\.?|April|May\\.?|Jun\\.?|June|Jul\\.?|July|Aug\\.?|August|Sep\\.?|Sept\\.?|September|Oct\\.?|October|Nov\\.?|November|Dec\\.?|December)' + '\\s*' + '(?:' + '[,-]?\\s*([0-9]{4})(\\s*BE|AD|BC)?' + ')?' + '(?=[^\\s\\w]|\\s+[^0-9]|\\s+$|$)', 'i');
        _this.MONTH_NAME_GROUP = 2;
        _this.YEAR_GROUP = 3;
        _this.YEAR_BE_GROUP = 4;
        _this.TAG = 'ENMonthNameParser';
        return _this;
    }

    _createClass(ENMonthNameParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length, match[0].length - match[1].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var month = EN_1.MONTH_OFFSET[match[this.MONTH_NAME_GROUP].toLowerCase()];
            if (!(month || month === 0)) {
                return null;
            }
            result.start.assign(constants_1.DAY, 1);
            result.start.assign(constants_1.MONTH, month);
            var year = EN_1.yearCalculation(match[this.YEAR_GROUP], match[this.YEAR_BE_GROUP]);
            if (year) {
                result.start.assign(constants_1.YEAR, year);
            } else {
                general_1.getAppropriateYear(result.start, ref);
            }
            return result;
        }
    }]);

    return ENMonthNameParser;
}(parser_1.default);

exports.default = ENMonthNameParser;

},{"../../constants":4,"../../result":66,"../../utils/EN":68,"../../utils/general":73,"../parser":51}],21:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var EN_1 = require("../../utils/EN");
var moment = require("moment");
var constants_1 = require("../../constants");

var ENRelativeDateFormatParser = function (_parser_1$default) {
    _inherits(ENRelativeDateFormatParser, _parser_1$default);

    function ENRelativeDateFormatParser() {
        _classCallCheck(this, ENRelativeDateFormatParser);

        var _this = _possibleConstructorReturn(this, (ENRelativeDateFormatParser.__proto__ || Object.getPrototypeOf(ENRelativeDateFormatParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\W|^)' + '(this|next|last|past)\\s*' + '(' + EN_1.INTEGER_WORDS_PATTERN + '|[0-9]+|few|half(?:\\s*an?)?)?\\s*' + '(seconds?|min(?:ute)?s?|hours?|days?|weeks?|months?|years?)(?=\\s*)' + '(?=\\W|$)', 'i');
        _this.MODIFIER_WORD_GROUP = 2;
        _this.MULTIPLIER_WORD_GROUP = 3;
        _this.RELATIVE_WORD_GROUP = 4;
        _this.OTHER_PATTERNS = [/^next/, /^this/];
        _this.TAG = 'ENRelativeDateFormatParser';
        return _this;
    }

    _createClass(ENRelativeDateFormatParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length, match[0].length - match[1].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var matchedUnit = match[this.RELATIVE_WORD_GROUP].toLowerCase();
            var unit = EN_1.matchUnit(matchedUnit);
            if (!unit) {
                return null;
            }
            var matchedMultiplier = match[this.MULTIPLIER_WORD_GROUP];
            var matchedModifier = match[this.MODIFIER_WORD_GROUP].toLowerCase();
            var momentRef = moment(ref);
            var num = EN_1.matchInteger(matchedMultiplier);
            if (matchedModifier.match(this.OTHER_PATTERNS[1])) {
                if (matchedMultiplier) {
                    return null;
                }
                switch (unit) {
                    case constants_1.WEEK:
                        momentRef.set('weekday', 0);
                        result.start.imply(constants_1.DAY, momentRef.date());
                        result.start.imply(constants_1.MONTH, momentRef.month() + 1);
                        result.start.imply(constants_1.YEAR, momentRef.year());
                        break;
                    case constants_1.MONTH:
                        momentRef.set('date', 1);
                        result.start.imply(constants_1.DAY, momentRef.date());
                        result.start.assign(constants_1.MONTH, momentRef.month() + 1);
                        result.start.assign(constants_1.YEAR, momentRef.year());
                        break;
                    case constants_1.YEAR:
                        momentRef.set('dayOfYear', 1);
                        result.start.imply(constants_1.DAY, momentRef.date());
                        result.start.imply(constants_1.MONTH, momentRef.month() + 1);
                        result.start.assign(constants_1.YEAR, momentRef.year());
                        break;
                }
            } else {
                var modifier = matchedModifier.match(this.OTHER_PATTERNS[0]) ? 1 : -1;
                var offset = modifier * (num || 1);
                var timeMode = false;
                switch (unit) {
                    case constants_1.SECOND:
                        timeMode = true;
                        momentRef.add(offset, 'second');
                        result.start.imply(constants_1.MINUTE, momentRef.minute());
                        result.start.imply(constants_1.SECOND, momentRef.second());
                        break;
                    case constants_1.MINUTE:
                        timeMode = true;
                        momentRef.add(offset, 'minute');
                        result.start.assign(constants_1.MINUTE, momentRef.minute());
                        result.start.imply(constants_1.SECOND, momentRef.second());
                        break;
                    case constants_1.HOUR:
                        timeMode = true;
                        momentRef.add(offset, 'hour');
                        result.start.imply(constants_1.MINUTE, momentRef.minute());
                        result.start.imply(constants_1.SECOND, momentRef.second());
                        break;
                    case constants_1.DAY:
                        momentRef.add(offset, 'd');
                        result.start.assign(constants_1.YEAR, momentRef.year());
                        result.start.assign(constants_1.MONTH, momentRef.month() + 1);
                        result.start.assign(constants_1.DAY, momentRef.date());
                        break;
                    case constants_1.WEEK:
                        momentRef.add(offset * 7, 'd');
                        result.start.imply(constants_1.MONTH, momentRef.month() + 1);
                        result.start.imply(constants_1.YEAR, momentRef.year());
                        result.start.imply(constants_1.DAY, momentRef.date());
                        break;
                    case constants_1.MONTH:
                        momentRef.add(offset, 'month');
                        momentRef.set('date', 1);
                        result.start.assign(constants_1.YEAR, momentRef.year());
                        result.start.assign(constants_1.MONTH, momentRef.month() + 1);
                        result.start.imply(constants_1.DAY, momentRef.date());
                        break;
                    case constants_1.YEAR:
                        momentRef.add(offset, 'year');
                        momentRef.set('dayOfYear', 1);
                        result.start.imply(constants_1.DAY, momentRef.date());
                        result.start.imply(constants_1.MONTH, momentRef.month() + 1);
                        result.start.assign(constants_1.YEAR, momentRef.year());
                        break;
                    default:
                        return null;
                }
                if (timeMode) {
                    result.start.assign(constants_1.HOUR, momentRef.hour());
                    result.start.assign(constants_1.YEAR, momentRef.year());
                    result.start.assign(constants_1.MONTH, momentRef.month() + 1);
                    result.start.assign(constants_1.DAY, momentRef.date());
                }
            }
            return result;
        }
    }]);

    return ENRelativeDateFormatParser;
}(parser_1.default);

exports.default = ENRelativeDateFormatParser;

},{"../../constants":4,"../../result":66,"../../utils/EN":68,"../parser":51,"moment":2}],22:[function(require,module,exports){
"use strict";
/*
    Date format with slash "/" (also "-" and ".") between numbers
    - Tuesday 11/3/2015
    - 11/3/2015
    - 11/3

    By default the paser us "middle-endien" format (US English),
    then fallback to little-endian if failed.
    - 11/3/2015 = November 3rd, 2015
    - 23/4/2015 = April 23th, 2015

    If "littleEndian" config is set, the parser will try the little-endian first.
    - 11/3/2015 = March 11th, 2015
*/

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var moment = require("moment");
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
var EN_1 = require("../../utils/EN");
var general_1 = require("../../utils/general");

var ENSlashDateFormatParser = function (_parser_1$default) {
    _inherits(ENSlashDateFormatParser, _parser_1$default);

    function ENSlashDateFormatParser() {
        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, ENSlashDateFormatParser);

        var _this = _possibleConstructorReturn(this, (ENSlashDateFormatParser.__proto__ || Object.getPrototypeOf(ENSlashDateFormatParser)).call(this, config));

        _this.PATTERN = new RegExp('(\\W|^)' + '(?:' + '(?:on\\s*?)?' + '((?:sun|mon|tues?|wed(?:nes)?|thu(?:rs?)?|fri|sat(?:ur)?)(?:day)?)' + '\\s*\\,?\\s*' + ')?' + '([0-3]{0,1}[0-9]{1})[\\/\\.\\-]([0-3]{0,1}[0-9]{1})' + '(?:' + '[\\/\\.\\-]' + '([0-9]{4}\s*\,?\s*|[0-9]{2}\s*\,?\s*)' + ')?' + '(\\W|$)', 'i');
        _this.OPENING_GROUP = 1;
        _this.ENDING_GROUP = 6;
        _this.WEEKDAY_GROUP = 2;
        _this.FIRST_NUMBERS_GROUP = 3;
        _this.SECOND_NUMBERS_GROUP = 4;
        _this.YEAR_GROUP = 5;
        _this.TAG = 'ENSlashDateFormatParser';
        _this.OTHER_PATTERNS = [/^\d\.\d$/, /^\d\.\d{1,2}\.\d{1,2}$/];
        if (config.littleEndian) {
            _this.MONTH_GROUP = _this.SECOND_NUMBERS_GROUP;
            _this.DAY_GROUP = _this.FIRST_NUMBERS_GROUP;
        } else {
            _this.DAY_GROUP = _this.SECOND_NUMBERS_GROUP;
            _this.MONTH_GROUP = _this.FIRST_NUMBERS_GROUP;
        }
        return _this;
    }

    _createClass(ENSlashDateFormatParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            if (match[this.OPENING_GROUP] == '/' || match[this.ENDING_GROUP] == '/') {
                // Long skip, if there is some overlapping like:
                // XX[/YY/ZZ]
                // [XX/YY/]ZZ
                match.index += match[0].length;
                return null;
            }
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[this.OPENING_GROUP].length, match[0].length - match[this.ENDING_GROUP].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var matchedText = result.text.toLowerCase();
            if (matchedText.match(this.OTHER_PATTERNS[0]) || matchedText.match(this.OTHER_PATTERNS[1])) {
                return null;
            }
            // MM/dd -> OK
            // MM.dd -> NG
            if (!match[this.YEAR_GROUP] && match[0].indexOf('/') < 0) {
                return null;
            }
            var year = match[this.YEAR_GROUP] ? parseInt(match[this.YEAR_GROUP], 10) : moment(ref).year();
            var month = parseInt(match[this.MONTH_GROUP], 10);
            var day = parseInt(match[this.DAY_GROUP], 10);
            if (month < 1 || day < 1 || day > 31) {
                return null;
            }
            if (year < 100) {
                if (year > 50) {
                    year = year + 1900;
                } else {
                    year = year + 2000;
                }
            }
            if (month > 12) {
                if (month <= 31 && day <= 12 && general_1.checkMonthDaysValid(month, day, year)) {
                    var _ref = [day, month];
                    month = _ref[0];
                    day = _ref[1];
                } else {
                    return null;
                }
            }
            result.start.assign(constants_1.DAY, day);
            result.start.assign(constants_1.MONTH, month);
            if (match[this.YEAR_GROUP]) {
                result.start.assign(constants_1.YEAR, year);
            } else {
                result.start.imply(constants_1.YEAR, year);
            }
            if (match[this.WEEKDAY_GROUP]) {
                result.start.assign(constants_1.WEEKDAY, EN_1.WEEKDAY_OFFSET[match[this.WEEKDAY_GROUP].toLowerCase()]);
            }
            return result;
        }
    }]);

    return ENSlashDateFormatParser;
}(parser_1.default);

exports.default = ENSlashDateFormatParser;

},{"../../constants":4,"../../result":66,"../../utils/EN":68,"../../utils/general":73,"../parser":51,"moment":2}],23:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
/*
    Date format with slash "/" between numbers like ENSlashDateFormatParser,
    but this parser expect year before month and date.
    - YYYY/MM/DD
    - YYYY-MM-DD
    - YYYY.MM.DD
*/
var parser_1 = require("../parser");
var result_1 = require("../../result");
var general_1 = require("../../utils/general");
var constants_1 = require("../../constants");

var ENSlashDateFormatStartWithYearParser = function (_parser_1$default) {
    _inherits(ENSlashDateFormatStartWithYearParser, _parser_1$default);

    function ENSlashDateFormatStartWithYearParser() {
        _classCallCheck(this, ENSlashDateFormatStartWithYearParser);

        var _this = _possibleConstructorReturn(this, (ENSlashDateFormatStartWithYearParser.__proto__ || Object.getPrototypeOf(ENSlashDateFormatStartWithYearParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\W|^)' + '([0-9]{4})[\\-\\.\\/]([0-9]{1,2})[\\-\\.\\/]([0-9]{1,2})' + '(?=\\W|$)', 'i');
        _this.YEAR_NUMBER_GROUP = 2;
        _this.MONTH_NUMBER_GROUP = 3;
        _this.DATE_NUMBER_GROUP = 4;
        _this.TAG = 'ENSlashDateFormatStartWithYearParser';
        return _this;
    }

    _createClass(ENSlashDateFormatStartWithYearParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var year = parseInt(match[this.YEAR_NUMBER_GROUP], 10);
            var month = parseInt(match[this.MONTH_NUMBER_GROUP], 10);
            var day = parseInt(match[this.DATE_NUMBER_GROUP], 10);
            if (month > 12 || month < 1 || day > 31 || day < 1 || !general_1.checkMonthDaysValid(day, month, year)) {
                return null;
            }
            result.start.assign(constants_1.YEAR, year);
            result.start.assign(constants_1.MONTH, month);
            result.start.assign(constants_1.DAY, day);
            return result;
        }
    }]);

    return ENSlashDateFormatStartWithYearParser;
}(parser_1.default);

exports.default = ENSlashDateFormatStartWithYearParser;

},{"../../constants":4,"../../result":66,"../../utils/general":73,"../parser":51}],24:[function(require,module,exports){
"use strict";
/*
    Month/Year date format with slash "/" (also "-" and ".") between numbers
    - 11/05
    - 06/2005
*/

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");

var ENSlashMonthFormatParser = function (_parser_1$default) {
    _inherits(ENSlashMonthFormatParser, _parser_1$default);

    function ENSlashMonthFormatParser() {
        _classCallCheck(this, ENSlashMonthFormatParser);

        var _this = _possibleConstructorReturn(this, (ENSlashMonthFormatParser.__proto__ || Object.getPrototypeOf(ENSlashMonthFormatParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(^|[^\\d/]\\s+|[^\\w\\s])' + '([0-9]|0[1-9]|1[012])/([0-9]{4})' + '([^\\d/]|$)', 'i');
        _this.OPENING_GROUP = 1;
        _this.ENDING_GROUP = 4;
        _this.MONTH_GROUP = 2;
        _this.YEAR_GROUP = 3;
        _this.TAG = 'ENSlashMonthFormatParser';
        return _this;
    }

    _createClass(ENSlashMonthFormatParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[this.OPENING_GROUP].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[this.OPENING_GROUP].length, match[0].length - (1 + match[this.ENDING_GROUP].length)).trim(),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            result.start.imply(constants_1.DAY, 1);
            result.start.assign(constants_1.MONTH, parseInt(match[this.MONTH_GROUP], 10));
            result.start.assign(constants_1.YEAR, parseInt(match[this.YEAR_GROUP], 10));
            return result;
        }
    }]);

    return ENSlashMonthFormatParser;
}(parser_1.default);

exports.default = ENSlashMonthFormatParser;

},{"../../constants":4,"../../result":66,"../parser":51}],25:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
var EN_1 = require("../../utils/EN");
var moment = require("moment");

var ENTimeAgoFormatParser = function (_parser_1$default) {
    _inherits(ENTimeAgoFormatParser, _parser_1$default);

    function ENTimeAgoFormatParser() {
        _classCallCheck(this, ENTimeAgoFormatParser);

        var _this = _possibleConstructorReturn(this, (ENTimeAgoFormatParser.__proto__ || Object.getPrototypeOf(ENTimeAgoFormatParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('' + '(\\W|^)' + '(?:within\\s*)?' + '(' + EN_1.TIME_UNIT_PATTERN + ')' + '(?:ago|before|earlier)(?=(?:\\W|$))', 'i');
        _this.STRICT_PATTERN = new RegExp('' + '(\\W|^)' + '(?:within\\s*)?' + '(' + EN_1.TIME_UNIT_STRICT_PATTERN + ')' + 'ago(?=(?:\\W|$))', 'i');
        _this.TAG = 'ENTimeAgoFormatParser';
        _this.OTHER_PATTERNS = [/\w/];
        return _this;
    }

    _createClass(ENTimeAgoFormatParser, [{
        key: "pattern",
        value: function pattern() {
            return this.isStrictMode() ? this.STRICT_PATTERN : this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            if (match.index > 0 && text[match.index - 1].match(this.OTHER_PATTERNS[0])) return null;
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length, match[0].length - match[1].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var fragments = EN_1.extractDateTimeUnitFragments(match[2]);
            var momentRef = moment(ref);
            Object.keys(fragments).forEach(function (fragment) {
                momentRef.add(-fragments[fragment], fragment);
            });
            if ((fragments['hour'] || 0) > 0 || (fragments['minute'] || 0) > 0 || (fragments['second'] || 0) > 0) {
                result.start.assign(constants_1.HOUR, momentRef.hour());
                result.start.assign(constants_1.MINUTE, momentRef.minute());
                result.start.assign(constants_1.SECOND, momentRef.second());
            }
            if ((fragments['d'] || 0) > 0 || (fragments['month'] || 0) > 0 || (fragments['year'] || 0) > 0) {
                result.start.assign(constants_1.DAY, momentRef.date());
                result.start.assign(constants_1.MONTH, momentRef.month() + 1);
                result.start.assign(constants_1.YEAR, momentRef.year());
            } else {
                if ((fragments['week'] || 0) > 0) {
                    result.start.imply(constants_1.WEEKDAY, momentRef.day());
                }
                result.start.imply(constants_1.DAY, momentRef.date());
                result.start.imply(constants_1.MONTH, momentRef.month() + 1);
                result.start.imply(constants_1.YEAR, momentRef.year());
            }
            return result;
        }
    }]);

    return ENTimeAgoFormatParser;
}(parser_1.default);

exports.default = ENTimeAgoFormatParser;

},{"../../constants":4,"../../result":66,"../../utils/EN":68,"../parser":51,"moment":2}],26:[function(require,module,exports){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
var moment = require("moment");

var ENTimeExpressionParser = function (_parser_1$default) {
    _inherits(ENTimeExpressionParser, _parser_1$default);

    function ENTimeExpressionParser() {
        _classCallCheck(this, ENTimeExpressionParser);

        var _this = _possibleConstructorReturn(this, (ENTimeExpressionParser.__proto__ || Object.getPrototypeOf(ENTimeExpressionParser)).apply(this, arguments));

        _this.PATTERN = new RegExp("(^|\\s|T)" + "(?:(?:at|from)\\s*)??" + "(\\d{1,4}|noon|midnight)" + "(?:" + "(?:\\.|\\:|\\：)(\\d{1,2})" + "(?:" + "(?:\\:|\\：)(\\d{2})(?:\\.(\\d{1,6}))?" + ")?" + ")?" + "(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?|O\\W*CLOCK))?" + "(?=\\W|$)", 'i');
        _this.END_PATTERN = new RegExp("^\\s*" + "(\\-|\\–|\\~|\\〜|to|(?:un)?till?|\\?)\\s*" + "(\\d{1,4})" + "(?:" + "(?:\\.|\\:|\\：)(\\d{1,2})" + "(?:" + "(?:\\.|\\:|\\：)(\\d{1,2})(?:\\.(\\d{1,6}))?" + ")?" + ")?" + "(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?|O\\W*CLOCK))?" + "(?=\\W|$)", 'i');
        _this.HOUR_GROUP = 2;
        _this.MINUTE_GROUP = 3;
        _this.SECOND_GROUP = 4;
        _this.MILLI_SECOND_GROUP = 5;
        _this.AM_PM_HOUR_GROUP = 6;
        _this.TAG = 'ENTimeExpressionParser';
        _this.OTHER_PATTERNS = [/\w/, /^\s*([+\-])\d{3,4}$/, /^\d+$/];
        return _this;
    }

    _createClass(ENTimeExpressionParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            // This pattern can be overlaped Ex. [12] AM, 1[2] AM
            if (match.index > 0 && text[match.index - 1].match(this.OTHER_PATTERNS[0])) return null;
            var refMoment = moment(ref);
            var result = new result_1.ParsedResult({
                text: match[0].substring(match[1].length),
                index: match.index + match[1].length,
                ref: ref
            });
            result.tags[this.TAG] = true;
            result.start.imply(constants_1.DAY, refMoment.date());
            result.start.imply(constants_1.MONTH, refMoment.month() + 1);
            result.start.imply(constants_1.YEAR, refMoment.year());
            if (!this.extractFirstChunk(result, match)) {
                return null;
            }
            if (!this.extractSecondChunk(text, result) && result.text.match(this.OTHER_PATTERNS[2])) {
                return null;
            }
            return result;
        }
    }, {
        key: "extractFirstChunk",
        value: function extractFirstChunk(result, match) {
            var time = this.getTime(match);
            if (!time) {
                return false;
            }

            var _time = _slicedToArray(time, 5),
                hour = _time[0],
                minute = _time[1],
                second = _time[2],
                millisecond = _time[3],
                meridiem = _time[4];

            if (second > -1) {
                result.start.assign(constants_1.SECOND, second);
            }
            if (millisecond > -1) {
                result.start.assign(constants_1.MILLISECOND, millisecond);
            }
            // ----- AM & PM
            if (match[this.AM_PM_HOUR_GROUP]) {
                if (hour > 12) return false;
                var ampm = match[this.AM_PM_HOUR_GROUP][0].toLowerCase();
                if (ampm === 'a') {
                    meridiem = 0;
                    if (hour === 12) hour = 0;
                } else if (ampm === 'p') {
                    meridiem = 1;
                    if (hour !== 12) hour += 12;
                }
            }
            result.start.assign(constants_1.HOUR, hour);
            result.start.assign(constants_1.MINUTE, minute);
            if (meridiem >= 0) {
                result.start.assign(constants_1.MERIDIEM, meridiem);
            } else {
                if (hour < 12) {
                    result.start.imply(constants_1.MERIDIEM, 0);
                } else {
                    result.start.imply(constants_1.MERIDIEM, 1);
                }
            }
            return true;
        }
    }, {
        key: "extractSecondChunk",
        value: function extractSecondChunk(text, result) {
            var match = this.END_PATTERN.exec(text.substring(result.index + result.text.length));
            if (!match) {
                return false;
            }
            // Pattern "YY.YY -XXXX" is more like timezone offset
            if (match[0].match(this.OTHER_PATTERNS[1])) {
                return true;
            }
            var time = this.getTime(match);
            if (!time) {
                return true;
            }

            var _time2 = _slicedToArray(time, 5),
                hour = _time2[0],
                minute = _time2[1],
                second = _time2[2],
                millisecond = _time2[3],
                meridiem = _time2[4];

            if (!result.end) {
                result.end = new result_1.ParsedComponents(undefined, result.start.date());
            }
            if (second > -1) {
                result.end.assign(constants_1.SECOND, second);
            }
            if (millisecond > -1) {
                result.end.assign(constants_1.MILLISECOND, millisecond);
            }
            // ----- AM & PM
            if (match[this.AM_PM_HOUR_GROUP]) {
                if (hour > 12) return false;
                var ampm = match[this.AM_PM_HOUR_GROUP][0].toLowerCase();
                if (ampm === 'a') {
                    meridiem = 0;
                    if (hour === 12) {
                        hour = 0;
                        if (!result.end.isCertain(constants_1.DAY)) {
                            result.end.imply(constants_1.DAY, result.end.get(constants_1.DAY) + 1);
                        }
                    }
                }
                if (ampm === 'p') {
                    meridiem = 1;
                    if (hour !== 12) hour += 12;
                }
                if (!result.start.isCertain(constants_1.MERIDIEM)) {
                    if (meridiem === 0) {
                        result.start.imply(constants_1.MERIDIEM, 0);
                        if (result.start.get(constants_1.HOUR) === 12) {
                            result.start.assign(constants_1.HOUR, 0);
                        }
                    } else {
                        result.start.imply(constants_1.MERIDIEM, 1);
                        if (result.start.get(constants_1.HOUR) !== 12) {
                            result.start.assign(constants_1.HOUR, result.start.get(constants_1.HOUR) + 12);
                        }
                    }
                }
            }
            result.text = result.text + match[0];
            result.end.assign(constants_1.HOUR, hour);
            result.end.assign(constants_1.MINUTE, minute);
            if (meridiem >= 0) {
                result.end.assign(constants_1.MERIDIEM, meridiem);
            } else {
                var startAtPM = result.start.isCertain(constants_1.MERIDIEM) && result.start.get(constants_1.MERIDIEM) === 1;
                if (startAtPM && result.start.get(constants_1.HOUR) > hour) {
                    // 10pm - 1 (am)
                    result.end.imply(constants_1.MERIDIEM, 0);
                } else if (hour > 12) {
                    result.end.imply(constants_1.MERIDIEM, 1);
                }
            }
            if (result.end.date().getTime() < result.start.date().getTime()) {
                result.end.imply(constants_1.DAY, result.end.get(constants_1.DAY) + 1);
            }
            return true;
        }
    }, {
        key: "getTime",
        value: function getTime(match) {
            var millisecond = -1;
            var second = -1;
            var hour = 0;
            var minute = 0;
            var meridiem = -1;
            // ----- Millisecond
            if (match[this.MILLI_SECOND_GROUP]) {
                millisecond = parseInt(match[this.MILLI_SECOND_GROUP].substr(0, 3), 10);
                if (millisecond >= 1000) return false;
            }
            // ----- Second
            if (match[this.SECOND_GROUP]) {
                second = parseInt(match[this.SECOND_GROUP], 10);
                if (second >= 60) return false;
            }
            // ----- Hours
            if (match[this.HOUR_GROUP].toLowerCase() === 'noon') {
                meridiem = 1;
                hour = 12;
            } else if (match[this.HOUR_GROUP].toLowerCase() === 'midnight') {
                meridiem = 0;
                hour = 0;
            } else {
                hour = parseInt(match[this.HOUR_GROUP], 10);
            }
            // ----- Minutes
            if (match[this.MINUTE_GROUP]) {
                minute = parseInt(match[this.MINUTE_GROUP], 10);
            } else if (hour > 100) {
                minute = hour % 100;
                hour = Math.floor(hour / 100);
            }
            if (minute >= 60) {
                return false;
            }
            if (hour > 24) {
                return false;
            }
            if (hour >= 12) {
                meridiem = 1;
            }
            return [hour, minute, second, millisecond, meridiem];
        }
    }]);

    return ENTimeExpressionParser;
}(parser_1.default);

exports.default = ENTimeExpressionParser;

},{"../../constants":4,"../../result":66,"../parser":51,"moment":2}],27:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
var EN_1 = require("../../utils/EN");
var moment = require("moment");

var ENTimeLaterFormatParser = function (_parser_1$default) {
    _inherits(ENTimeLaterFormatParser, _parser_1$default);

    function ENTimeLaterFormatParser() {
        _classCallCheck(this, ENTimeLaterFormatParser);

        var _this = _possibleConstructorReturn(this, (ENTimeLaterFormatParser.__proto__ || Object.getPrototypeOf(ENTimeLaterFormatParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('' + '(\\W|^)' + '(' + EN_1.TIME_UNIT_PATTERN + ')' + '(?:later|after|from now|henceforth|forward|out)(?=(?:\\W|$))', 'i');
        _this.STRICT_PATTERN = new RegExp('' + '(\\W|^)' + '(' + EN_1.TIME_UNIT_STRICT_PATTERN + ')' + '(?:later|from now)(?=(?:\\W|$))', 'i');
        _this.TAG = 'ENTimeLaterFormatParser';
        _this.OTHER_PATTERNS = [/\w/];
        return _this;
    }

    _createClass(ENTimeLaterFormatParser, [{
        key: "pattern",
        value: function pattern() {
            return this.isStrictMode() ? this.STRICT_PATTERN : this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            if (match.index > 0 && text[match.index - 1].match(this.OTHER_PATTERNS[0])) return null;
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length, match[0].length - match[1].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var momentRef = moment(ref);
            var fragments = EN_1.extractDateTimeUnitFragments(match[2]);
            Object.keys(fragments).forEach(function (fragment) {
                momentRef.add(fragments[fragment], fragment);
            });
            if ((fragments['hour'] || 0) > 0 || (fragments['minute'] || 0) > 0 || (fragments['second'] || 0) > 0) {
                result.start.assign(constants_1.HOUR, momentRef.hour());
                result.start.assign(constants_1.MINUTE, momentRef.minute());
                result.start.assign(constants_1.SECOND, momentRef.second());
            }
            if ((fragments['d'] || 0) > 0 || (fragments['month'] || 0) > 0 || (fragments['year'] || 0) > 0) {
                result.start.assign(constants_1.DAY, momentRef.date());
                result.start.assign(constants_1.MONTH, momentRef.month() + 1);
                result.start.assign(constants_1.YEAR, momentRef.year());
            } else {
                if ((fragments['week'] || 0) > 0) {
                    result.start.imply(constants_1.WEEKDAY, momentRef.day());
                }
                result.start.imply(constants_1.DAY, momentRef.date());
                result.start.imply(constants_1.MONTH, momentRef.month() + 1);
                result.start.imply(constants_1.YEAR, momentRef.year());
            }
            return result;
        }
    }]);

    return ENTimeLaterFormatParser;
}(parser_1.default);

exports.default = ENTimeLaterFormatParser;

},{"../../constants":4,"../../result":66,"../../utils/EN":68,"../parser":51,"moment":2}],28:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var EN_1 = require("../../utils/EN");
var general_1 = require("../../utils/general");

var ENWeekdayParser = function (_parser_1$default) {
    _inherits(ENWeekdayParser, _parser_1$default);

    function ENWeekdayParser() {
        _classCallCheck(this, ENWeekdayParser);

        var _this = _possibleConstructorReturn(this, (ENWeekdayParser.__proto__ || Object.getPrototypeOf(ENWeekdayParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\W|^)' + '(?:(?:\\,|\\(|\\（)\\s*)?' + '(?:on\\s*?)?' + '(?:(this|last|past|next)\\s*)?' + '(' + Object.keys(EN_1.WEEKDAY_OFFSET).join('|') + ')' + '(?:\\s*(?:\\,|\\)|\\）))?' + '(?:\\s*(this|last|past|next)\\s*week)?' + '(?=\\W|$)', 'i');
        _this.PREFIX_GROUP = 2;
        _this.WEEKDAY_GROUP = 3;
        _this.POSTFIX_GROUP = 4;
        _this.TAG = 'ENWeekdayParser';
        return _this;
    }

    _createClass(ENWeekdayParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var matchedText = match[0].substr(match[1].length, match[0].length - match[1].length);
            var result = new result_1.ParsedResult({
                text: matchedText,
                index: index,
                ref: ref
            });
            var offset = EN_1.WEEKDAY_OFFSET[match[this.WEEKDAY_GROUP].toLowerCase()];
            if (offset === undefined) return null;
            var prefix = match[this.PREFIX_GROUP];
            var postfix = match[this.POSTFIX_GROUP];
            var norm = (prefix || postfix || '').toLowerCase();
            var modifier = general_1.Modifier.UNKNOWN;
            if (norm === 'this') {
                modifier = general_1.Modifier.THIS;
            } else if (norm === 'last' || norm === 'past') {
                modifier = general_1.Modifier.LAST;
            } else if (norm === 'next') {
                modifier = general_1.Modifier.NEXT;
            }
            result.tags[this.TAG] = true;
            general_1.updateParsedComponent(result, ref, offset, modifier);
            return result;
        }
    }]);

    return ENWeekdayParser;
}(parser_1.default);

exports.default = ENWeekdayParser;

},{"../../result":66,"../../utils/EN":68,"../../utils/general":73,"../parser":51}],29:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var moment = require("moment");
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
/*
  Valid patterns:
  - esta mañana -> today in the morning
  - esta tarde -> today in the afternoon/evening
  - esta noche -> tonight
  - ayer por la mañana -> yesterday in the morning
  - ayer por la tarde -> yesterday in the afternoon/evening
  - ayer por la noche -> yesterday at night
  - mañana por la mañana -> tomorrow in the morning
  - mañana por la tarde -> tomorrow in the afternoon/evening
  - mañana por la noche -> tomorrow at night
  - anoche -> tomorrow at night
  - hoy -> today
  - ayer -> yesterday
  - mañana -> tomorrow
 */

var ESCasualDateParser = function (_parser_1$default) {
    _inherits(ESCasualDateParser, _parser_1$default);

    function ESCasualDateParser() {
        _classCallCheck(this, ESCasualDateParser);

        var _this = _possibleConstructorReturn(this, (ESCasualDateParser.__proto__ || Object.getPrototypeOf(ESCasualDateParser)).apply(this, arguments));

        _this.PATTERN = /(\W|^)(ahora|esta\s*(mañana|tarde|noche)|(ayer|mañana)\s*por\s*la\s*(mañana|tarde|noche)|hoy|mañana|ayer|anoche)(?=\W|$)/i;
        _this.OTHER_PATTERNS = [/por\s*la/, /ahora/];
        _this.TAG = 'ESCasualDateParser';
        return _this;
    }

    _createClass(ESCasualDateParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length),
                index: index,
                ref: ref
            });
            var refMoment = moment(ref);
            var startMoment = refMoment.clone();
            var matchedText = result.text.toLowerCase();
            if (matchedText === 'mañana') {
                // Check not "Tomorrow" on late night
                if (refMoment.hour() > 1) {
                    startMoment.add(1, 'day');
                }
            } else if (matchedText === 'ayer') {
                startMoment.add(-1, 'day');
            } else if (matchedText === 'anoche') {
                result.start.imply(constants_1.HOUR, 0);
                if (refMoment.hour() > 6) {
                    startMoment.add(-1, 'day');
                }
            } else if (matchedText.match("esta")) {
                var secondMatch = match[3].toLowerCase();
                if (secondMatch === "tarde") {
                    result.start.imply(constants_1.HOUR, 18);
                } else if (secondMatch === "mañana") {
                    result.start.imply(constants_1.HOUR, 6);
                } else if (secondMatch === "noche") {
                    // Normally means this coming midnight
                    result.start.imply(constants_1.HOUR, 22);
                    result.start.imply(constants_1.MERIDIEM, 1);
                }
            } else if (matchedText.match(this.OTHER_PATTERNS[0])) {
                var firstMatch = match[4].toLowerCase();
                if (firstMatch === 'ayer') {
                    startMoment.add(-1, 'day');
                } else if (firstMatch === 'mañana') {
                    startMoment.add(1, 'day');
                }
                var _secondMatch = match[5].toLowerCase();
                if (_secondMatch === "tarde") {
                    result.start.imply(constants_1.HOUR, 18);
                } else if (_secondMatch === "mañana") {
                    result.start.imply(constants_1.HOUR, 9);
                } else if (_secondMatch === "noche") {
                    // Normally means this coming midnight
                    result.start.imply(constants_1.HOUR, 22);
                    result.start.imply(constants_1.MERIDIEM, 1);
                }
            } else if (matchedText.match(this.OTHER_PATTERNS[1])) {
                result.start.imply(constants_1.HOUR, refMoment.hour());
                result.start.imply(constants_1.MINUTE, refMoment.minute());
                result.start.imply(constants_1.SECOND, refMoment.second());
                result.start.imply(constants_1.MILLISECOND, refMoment.millisecond());
            }
            result.start.assign(constants_1.DAY, startMoment.date());
            result.start.assign(constants_1.MONTH, startMoment.month() + 1);
            result.start.assign(constants_1.YEAR, startMoment.year());
            result.tags[this.TAG] = true;
            return result;
        }
    }]);

    return ESCasualDateParser;
}(parser_1.default);

exports.default = ESCasualDateParser;

},{"../../constants":4,"../../result":66,"../parser":51,"moment":2}],30:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var moment = require("moment");
var general_1 = require("../../utils/general");
var ES_1 = require("../../utils/ES");

var ESDeadlineFormatParser = function (_parser_1$default) {
    _inherits(ESDeadlineFormatParser, _parser_1$default);

    function ESDeadlineFormatParser() {
        _classCallCheck(this, ESDeadlineFormatParser);

        var _this = _possibleConstructorReturn(this, (ESDeadlineFormatParser.__proto__ || Object.getPrototypeOf(ESDeadlineFormatParser)).apply(this, arguments));

        _this.PATTERN = /(\W|^)(dentro\s*de|en)\s*([0-9]+|medi[oa]|una?)\s*(minutos?|horas?|d[ií]as?)\s*(?=(?:\W|$))/i;
        _this.NUM_MATCH = 3;
        _this.UNIT_MATCH = 4;
        _this.TAG = 'ESDeadlineFormatParser';
        return _this;
    }

    _createClass(ESDeadlineFormatParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length, match[0].length - match[1].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var num = ES_1.matchNumber(match[this.NUM_MATCH].toLowerCase());
            var matchedUnit = ES_1.matchUnit(match[this.UNIT_MATCH].toLowerCase());
            if (num && matchedUnit && general_1.deadlineCalculations(num, matchedUnit, result, moment(ref))) {
                return result;
            }
            return null;
        }
    }]);

    return ESDeadlineFormatParser;
}(parser_1.default);

exports.default = ESDeadlineFormatParser;

},{"../../result":66,"../../utils/ES":69,"../../utils/general":73,"../parser":51,"moment":2}],31:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var ES_1 = require("../../utils/ES");
var constants_1 = require("../../constants");
var general_1 = require("../../utils/general");

var ESMonthNameLittleEndianParser = function (_parser_1$default) {
    _inherits(ESMonthNameLittleEndianParser, _parser_1$default);

    function ESMonthNameLittleEndianParser() {
        _classCallCheck(this, ESMonthNameLittleEndianParser);

        var _this = _possibleConstructorReturn(this, (ESMonthNameLittleEndianParser.__proto__ || Object.getPrototypeOf(ESMonthNameLittleEndianParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\W|^)' + '(?:(Domingo|Lunes|Martes|Miércoles|Miercoles|Jueves|Viernes|Sábado|Sabado|Dom|Lun|Mar|Mie|Jue|Vie|Sab)\\s*,?\\s*)?' + '([0-9]{1,2})(?:º|ª|°)?' + '(?:\\s*(?:desde|de|\\-|\\–|al?|hasta|\\s)\\s*([0-9]{1,2})(?:º|ª|°)?)?\\s*(?:de)?\\s*' + '(Ene(?:ro|\\.)?|Feb(?:rero|\\.)?|Mar(?:zo|\\.)?|Abr(?:il|\\.)?|May(?:o|\\.)?|Jun(?:io|\\.)?|Jul(?:io|\\.)?|Ago(?:sto|\\.)?|Sep(?:tiembre|\\.)?|Set(?:iembre|\\.)?|Oct(?:ubre|\\.)?|Nov(?:iembre|\\.)?|Dic(?:iembre|\\.)?)' + '(?:\\s*(?:del?)?(\\s*[0-9]{1,4}(?![^\\s]\\d))(\\s*[ad]\\.?\\s*c\\.?|a\\.?\\s*d\\.?)?)?' + '(?=\\W|$)', 'i');
        _this.WEEKDAY_GROUP = 2;
        _this.DATE_GROUP = 3;
        _this.DATE_TO_GROUP = 4;
        _this.MONTH_NAME_GROUP = 5;
        _this.YEAR_GROUP = 6;
        _this.YEAR_BE_GROUP = 7;
        _this.TAG = 'ESMonthNameLittleEndianParser';
        return _this;
    }

    _createClass(ESMonthNameLittleEndianParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length, match[0].length - match[1].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var month = ES_1.MONTH_OFFSET[match[this.MONTH_NAME_GROUP].toLowerCase()];
            if (!(month || month === 0)) {
                return null;
            }
            var day = parseInt(match[this.DATE_GROUP], 10);
            if (!day) {
                return null;
            }
            result.start.assign(constants_1.DAY, day);
            result.start.assign(constants_1.MONTH, month);
            var year = ES_1.yearCalculation(match[this.YEAR_GROUP], match[this.YEAR_BE_GROUP]);
            if (year) {
                result.start.assign(constants_1.YEAR, year);
            } else {
                general_1.getAppropriateYear(result.start, ref);
            }
            // Weekday component
            if (match[this.WEEKDAY_GROUP]) {
                var weekday = ES_1.WEEKDAY_OFFSET[match[this.WEEKDAY_GROUP].toLowerCase()];
                if (weekday || weekday === 0) {
                    result.start.assign(constants_1.WEEKDAY, weekday);
                }
            }
            // Text can be 'range' value. Such as '12 - 13 January 2012'
            if (match[this.DATE_TO_GROUP]) {
                var endDate = parseInt(match[this.DATE_TO_GROUP], 10);
                if (endDate) {
                    result.end = result.start.clone();
                    result.end.assign(constants_1.DAY, endDate);
                }
            }
            return result;
        }
    }]);

    return ESMonthNameLittleEndianParser;
}(parser_1.default);

exports.default = ESMonthNameLittleEndianParser;

},{"../../constants":4,"../../result":66,"../../utils/ES":69,"../../utils/general":73,"../parser":51}],32:[function(require,module,exports){
"use strict";
/*
    Date format with slash "/" (also "-" and ".") between numbers
    - Martes 3/11/2015
    - 3/11/2015
    - 3/11
*/

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
var ES_1 = require("../../utils/ES");
var general_1 = require("../../utils/general");
var moment = require("moment");

var ESSlashDateFormatParser = function (_parser_1$default) {
    _inherits(ESSlashDateFormatParser, _parser_1$default);

    function ESSlashDateFormatParser() {
        _classCallCheck(this, ESSlashDateFormatParser);

        var _this = _possibleConstructorReturn(this, (ESSlashDateFormatParser.__proto__ || Object.getPrototypeOf(ESSlashDateFormatParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\W|^)' + '(?:' + '((?:domingo|dom|lunes|lun|martes|mar|mi[ée]rcoles|mie|jueves|jue|viernes|vie|s[áa]bado|sab))' + '\\s*\\,?\\s*' + ')?' + '([0-1]{0,1}[0-9]{1})[\\/\\.\\-]([0-3]{0,1}[0-9]{1})' + '(?:' + '[\\/\\.\\-]' + '([0-9]{4}\s*\,?\s*|[0-9]{2}\s*\,?\s*)' + ')?' + '(\\W|$)', 'i');
        _this.OPENING_GROUP = 1;
        _this.ENDING_GROUP = 6;
        _this.WEEKDAY_GROUP = 2;
        _this.MONTH_GROUP = 4;
        _this.DAY_GROUP = 3;
        _this.YEAR_GROUP = 5;
        _this.TAG = 'ESSlashDateFormatParser';
        _this.OTHER_PATTERNS = [/^\d\.\d$/, /^\d\.\d{1,2}\.\d{1,2}$/];
        return _this;
    }

    _createClass(ESSlashDateFormatParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            if (match[this.OPENING_GROUP] == '/' || match[this.ENDING_GROUP] == '/') {
                // Long skip, if there is some overlapping like:
                // XX[/YY/ZZ]
                // [XX/YY/]ZZ
                match.index += match[0].length;
                return null;
            }
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[this.OPENING_GROUP].length, match[0].length - match[this.ENDING_GROUP].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var matchedText = result.text.toLowerCase();
            if (matchedText.match(this.OTHER_PATTERNS[0]) || matchedText.match(this.OTHER_PATTERNS[1])) {
                return null;
            }
            // MM/dd -> OK
            // MM.dd -> NG
            if (!match[this.YEAR_GROUP] && match[0].indexOf('/') < 0) {
                return null;
            }
            var year = match[this.YEAR_GROUP] ? parseInt(match[this.YEAR_GROUP], 10) : moment(ref).year();
            var month = parseInt(match[this.MONTH_GROUP], 10);
            var day = parseInt(match[this.DAY_GROUP], 10);
            if (month < 1 || day < 1 || day > 31) {
                return null;
            }
            if (year < 100) {
                if (year > 50) {
                    year = year + 1900;
                } else {
                    year = year + 2000;
                }
            }
            if (month > 12) {
                if (month <= 31 && day <= 12 && general_1.checkMonthDaysValid(month, day, year)) {
                    var _ref = [day, month];
                    month = _ref[0];
                    day = _ref[1];
                } else {
                    return null;
                }
            }
            result.start.assign(constants_1.DAY, day);
            result.start.assign(constants_1.MONTH, month);
            if (match[this.YEAR_GROUP]) {
                result.start.assign(constants_1.YEAR, year);
            } else {
                result.start.imply(constants_1.YEAR, year);
            }
            if (match[this.WEEKDAY_GROUP]) {
                result.start.assign(constants_1.WEEKDAY, ES_1.WEEKDAY_OFFSET[match[this.WEEKDAY_GROUP].toLowerCase()]);
            }
            return result;
        }
    }]);

    return ESSlashDateFormatParser;
}(parser_1.default);

exports.default = ESSlashDateFormatParser;

},{"../../constants":4,"../../result":66,"../../utils/ES":69,"../../utils/general":73,"../parser":51,"moment":2}],33:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
var ES_1 = require("../../utils/ES");
var moment = require("moment");
var Mode;
(function (Mode) {
    Mode[Mode["NONE"] = 0] = "NONE";
    Mode[Mode["TIME"] = 1] = "TIME";
    Mode[Mode["WEEK"] = 2] = "WEEK";
    Mode[Mode["DATE"] = 3] = "DATE";
})(Mode || (Mode = {}));

var ESTimeAgoFormatParser = function (_parser_1$default) {
    _inherits(ESTimeAgoFormatParser, _parser_1$default);

    function ESTimeAgoFormatParser() {
        _classCallCheck(this, ESTimeAgoFormatParser);

        var _this = _possibleConstructorReturn(this, (ESTimeAgoFormatParser.__proto__ || Object.getPrototypeOf(ESTimeAgoFormatParser)).apply(this, arguments));

        _this.PATTERN = /(\W|^)hace\s*([0-9]+|medi[oa]|una?)\s*(minutos?|horas?|semanas?|d[ií]as?|mes(es)?|años?)(?=(?:\W|$))/i;
        _this.TAG = 'ESTimeAgoFormatParser';
        _this.OTHER_PATTERNS = [/\w/];
        _this.NUM_MATCH = 2;
        _this.UNIT_MATCH = 3;
        return _this;
    }

    _createClass(ESTimeAgoFormatParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            if (match.index > 0 && text[match.index - 1].match(this.OTHER_PATTERNS[0])) return null;
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length, match[0].length - match[1].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var num = ES_1.matchNumber(match[this.NUM_MATCH]);
            var matchedUnit = ES_1.matchUnit(match[this.UNIT_MATCH].toLowerCase());
            var mode = Mode.NONE;
            var momentRef = moment(ref);
            switch (matchedUnit) {
                case constants_1.HOUR:
                    momentRef.add(-num, 'hour');
                    mode = Mode.TIME;
                    break;
                case constants_1.MINUTE:
                    momentRef.add(-num, 'minute');
                    mode = Mode.TIME;
                    break;
                case constants_1.WEEK:
                    momentRef.add(-num, 'week');
                    mode = Mode.WEEK;
                    break;
                case constants_1.DAY:
                    momentRef.add(-num, 'd');
                    mode = Mode.DATE;
                    break;
                case constants_1.MONTH:
                    momentRef.add(-num, 'month');
                    mode = Mode.DATE;
                    break;
                case constants_1.YEAR:
                    momentRef.add(-num, 'year');
                    mode = Mode.DATE;
                    break;
                default:
                    return null;
            }
            switch (mode) {
                case Mode.TIME:
                    result.start.imply(constants_1.DAY, momentRef.date());
                    result.start.imply(constants_1.MONTH, momentRef.month() + 1);
                    result.start.imply(constants_1.YEAR, momentRef.year());
                    result.start.assign(constants_1.HOUR, momentRef.hour());
                    result.start.assign(constants_1.MINUTE, momentRef.minute());
                    break;
                case Mode.DATE:
                    result.start.assign(constants_1.DAY, momentRef.date());
                    result.start.assign(constants_1.MONTH, momentRef.month() + 1);
                    result.start.assign(constants_1.YEAR, momentRef.year());
                    break;
                case Mode.WEEK:
                    result.start.imply(constants_1.DAY, momentRef.date());
                    result.start.imply(constants_1.MONTH, momentRef.month() + 1);
                    result.start.imply(constants_1.YEAR, momentRef.year());
                    result.start.imply(constants_1.WEEKDAY, momentRef.day());
                    break;
                default:
                    return null;
            }
            return result;
        }
    }]);

    return ESTimeAgoFormatParser;
}(parser_1.default);

exports.default = ESTimeAgoFormatParser;

},{"../../constants":4,"../../result":66,"../../utils/ES":69,"../parser":51,"moment":2}],34:[function(require,module,exports){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
var moment = require("moment");

var ESTimeExpressionParser = function (_parser_1$default) {
    _inherits(ESTimeExpressionParser, _parser_1$default);

    function ESTimeExpressionParser() {
        _classCallCheck(this, ESTimeExpressionParser);

        var _this = _possibleConstructorReturn(this, (ESTimeExpressionParser.__proto__ || Object.getPrototypeOf(ESTimeExpressionParser)).apply(this, arguments));

        _this.PATTERN = new RegExp("(^|\\s|T)" + "(?:(?:a las?|al?|desde|de)\\s*)?" + "(\\d{1,4}|mediod[ií]a|medianoche)" + "(?:" + "(?:\\.|\\:|\\：)(\\d{1,2})" + "(?:" + "(?:\\:|\\：)(\\d{2})" + ")?" + ")?" + "(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?" + "(?=\\W|$)", 'i');
        _this.END_PATTERN = new RegExp("^\\s*" + "(\\-|\\–|\\~|\\〜|a(?:\s*las)?|\\?)\\s*" + "(\\d{1,4})" + "(?:" + "(?:\\.|\\:|\\：)(\\d{1,2})" + "(?:" + "(?:\\.|\\:|\\：)(\\d{1,2})" + ")?" + ")?" + "(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?" + "(?=\\W|$)", 'i');
        _this.HOUR_GROUP = 2;
        _this.MINUTE_GROUP = 3;
        _this.SECOND_GROUP = 4;
        _this.AM_PM_HOUR_GROUP = 5;
        _this.TAG = 'ESTimeExpressionParser';
        _this.OTHER_PATTERNS = [/\w/, /^\s*([+\-])\s*\d{3,4}$/, /^\d+$/, /mediod/];
        return _this;
    }

    _createClass(ESTimeExpressionParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            // This pattern can be overlaped Ex. [12] AM, 1[2] AM
            if (match.index > 0 && text[match.index - 1].match(this.OTHER_PATTERNS[0])) return null;
            var refMoment = moment(ref);
            var result = new result_1.ParsedResult({
                text: match[0].substring(match[1].length),
                index: match.index + match[1].length,
                ref: ref
            });
            result.tags[this.TAG] = true;
            result.start.imply(constants_1.DAY, refMoment.date());
            result.start.imply(constants_1.MONTH, refMoment.month() + 1);
            result.start.imply(constants_1.YEAR, refMoment.year());
            if (!this.extractFirstChunk(result, match)) {
                return null;
            }
            if (!this.extractSecondChunk(text, result) && result.text.match(this.OTHER_PATTERNS[2])) {
                return null;
            }
            return result;
        }
    }, {
        key: "extractFirstChunk",
        value: function extractFirstChunk(result, match) {
            var time = this.getTime(match);
            if (!time) {
                return false;
            }

            var _time = _slicedToArray(time, 4),
                hour = _time[0],
                minute = _time[1],
                second = _time[2],
                meridiem = _time[3];

            if (second > -1) {
                result.start.assign(constants_1.SECOND, second);
            }
            // ----- AM & PM
            if (match[this.AM_PM_HOUR_GROUP]) {
                if (hour > 12) return false;
                var ampm = match[this.AM_PM_HOUR_GROUP][0].toLowerCase();
                if (ampm === 'a') {
                    meridiem = 0;
                    if (hour === 12) hour = 0;
                } else if (ampm === 'p') {
                    meridiem = 1;
                    if (hour !== 12) hour += 12;
                }
            }
            result.start.assign(constants_1.HOUR, hour);
            result.start.assign(constants_1.MINUTE, minute);
            if (meridiem >= 0) {
                result.start.assign(constants_1.MERIDIEM, meridiem);
            } else {
                if (hour < 12) {
                    result.start.imply(constants_1.MERIDIEM, 0);
                } else {
                    result.start.imply(constants_1.MERIDIEM, 1);
                }
            }
            return true;
        }
    }, {
        key: "extractSecondChunk",
        value: function extractSecondChunk(text, result) {
            var match = this.END_PATTERN.exec(text.substring(result.index + result.text.length));
            if (!match) {
                return false;
            }
            // Pattern "YY.YY -XXXX" is more like timezone offset
            if (match[0].match(this.OTHER_PATTERNS[1])) {
                return true;
            }
            var time = this.getTime(match);
            if (!time) {
                return true;
            }

            var _time2 = _slicedToArray(time, 4),
                hour = _time2[0],
                minute = _time2[1],
                second = _time2[2],
                meridiem = _time2[3];

            if (!result.end) {
                result.end = new result_1.ParsedComponents(undefined, result.start.date());
            }
            if (second > -1) {
                result.end.assign(constants_1.SECOND, second);
            }
            // ----- AM & PM
            if (match[this.AM_PM_HOUR_GROUP]) {
                if (hour > 12) return false;
                var ampm = match[this.AM_PM_HOUR_GROUP][0].toLowerCase();
                if (ampm === 'a') {
                    meridiem = 0;
                    if (hour === 12) {
                        hour = 0;
                        if (!result.end.isCertain(constants_1.DAY)) {
                            result.end.imply(constants_1.DAY, result.end.get(constants_1.DAY) + 1);
                        }
                    }
                }
                if (ampm === 'p') {
                    meridiem = 1;
                    if (hour !== 12) hour += 12;
                }
                if (!result.start.isCertain(constants_1.MERIDIEM)) {
                    if (meridiem === 0) {
                        result.start.imply(constants_1.MERIDIEM, 0);
                        if (result.start.get(constants_1.HOUR) === 12) {
                            result.start.assign(constants_1.HOUR, 0);
                        }
                    } else {
                        result.start.imply(constants_1.MERIDIEM, 1);
                        if (result.start.get(constants_1.HOUR) !== 12) {
                            result.start.assign(constants_1.HOUR, result.start.get(constants_1.HOUR) + 12);
                        }
                    }
                }
            }
            result.text = result.text + match[0];
            result.end.assign(constants_1.HOUR, hour);
            result.end.assign(constants_1.MINUTE, minute);
            if (meridiem >= 0) {
                result.end.assign(constants_1.MERIDIEM, meridiem);
            }
            if (result.end.date().getTime() < result.start.date().getTime()) {
                result.end.imply(constants_1.DAY, result.end.get(constants_1.DAY) + 1);
            }
            return true;
        }
    }, {
        key: "getTime",
        value: function getTime(match) {
            var second = -1;
            var hour = 0;
            var minute = 0;
            var meridiem = -1;
            // ----- Second
            if (match[this.SECOND_GROUP]) {
                second = parseInt(match[this.SECOND_GROUP], 10);
                if (second >= 60) return false;
            }
            // ----- Hours
            if (match[this.HOUR_GROUP].toLowerCase().match(this.OTHER_PATTERNS[3])) {
                meridiem = 1;
                hour = 12;
            } else if (match[this.HOUR_GROUP].toLowerCase() === 'medianoche') {
                meridiem = 0;
                hour = 0;
            } else {
                hour = parseInt(match[this.HOUR_GROUP], 10);
            }
            // ----- Minutes
            if (match[this.MINUTE_GROUP]) {
                minute = parseInt(match[this.MINUTE_GROUP], 10);
            } else if (hour > 100) {
                minute = hour % 100;
                hour = Math.floor(hour / 100);
            }
            if (minute >= 60) {
                return false;
            }
            if (hour > 24) {
                return false;
            }
            if (hour >= 12) {
                meridiem = 1;
            }
            return [hour, minute, second, meridiem];
        }
    }]);

    return ESTimeExpressionParser;
}(parser_1.default);

exports.default = ESTimeExpressionParser;

},{"../../constants":4,"../../result":66,"../parser":51,"moment":2}],35:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var ES_1 = require("../../utils/ES");
var general_1 = require("../../utils/general");

var ESWeekdayParser = function (_parser_1$default) {
    _inherits(ESWeekdayParser, _parser_1$default);

    function ESWeekdayParser() {
        _classCallCheck(this, ESWeekdayParser);

        var _this = _possibleConstructorReturn(this, (ESWeekdayParser.__proto__ || Object.getPrototypeOf(ESWeekdayParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\W|^)' + '(?:(?:\\,|\\(|\\（)\\s*)?' + '(?:(este|pasado|pr[oó]ximo)\\s*)?' + '(' + Object.keys(ES_1.WEEKDAY_OFFSET).join('|') + ')' + '(?:\\s*(?:\\,|\\)|\\）))?' + '(?:\\s*(este|pasado|pr[óo]ximo)\\s*week)?' + '(?=\\W|$)', 'i');
        _this.PREFIX_GROUP = 2;
        _this.WEEKDAY_GROUP = 3;
        _this.POSTFIX_GROUP = 4;
        _this.TAG = 'ESWeekdayParser';
        return _this;
    }

    _createClass(ESWeekdayParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var matchedText = match[0].substr(match[1].length, match[0].length - match[1].length);
            var result = new result_1.ParsedResult({
                text: matchedText,
                index: index,
                ref: ref
            });
            var offset = ES_1.WEEKDAY_OFFSET[match[this.WEEKDAY_GROUP].toLowerCase()];
            if (offset === undefined) return null;
            var prefix = match[this.PREFIX_GROUP];
            var postfix = match[this.POSTFIX_GROUP];
            var norm = (prefix || postfix || '').toLowerCase();
            var modifier = general_1.Modifier.UNKNOWN;
            if (norm == 'este') {
                modifier = general_1.Modifier.THIS;
            } else if (norm === 'pasado') {
                modifier = general_1.Modifier.LAST;
            } else if (norm == 'próximo' || norm == 'proximo') {
                modifier = general_1.Modifier.NEXT;
            }
            result.tags[this.TAG] = true;
            general_1.updateParsedComponent(result, ref, offset, modifier);
            return result;
        }
    }]);

    return ESWeekdayParser;
}(parser_1.default);

exports.default = ESWeekdayParser;

},{"../../result":66,"../../utils/ES":69,"../../utils/general":73,"../parser":51}],36:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var moment = require("moment");
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");

var FRCasualDateParser = function (_parser_1$default) {
    _inherits(FRCasualDateParser, _parser_1$default);

    function FRCasualDateParser() {
        _classCallCheck(this, FRCasualDateParser);

        var _this = _possibleConstructorReturn(this, (FRCasualDateParser.__proto__ || Object.getPrototypeOf(FRCasualDateParser)).apply(this, arguments));

        _this.PATTERN = /(\W|^)(maintenant|aujourd'hui|ajd|cette\s*nuit|la\s*veille|(demain|hier)(\s*(matin|soir|aprem|après-midi))?|ce\s*(matin|soir)|cet\s*(après-midi|aprem))(?=\W|$)/i;
        _this.OTHER_PATTERNS = [/demain/, /hier/, /cette\s*nuit/, /la\s*veille/, /après-midi|aprem/, /soir/, /matin/, /maintenant/];
        _this.TAG = 'FRCasualDateParser';
        return _this;
    }

    _createClass(FRCasualDateParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length),
                index: index,
                ref: ref
            });
            var refMoment = moment(ref);
            var startMoment = refMoment.clone();
            var matchedText = result.text.toLowerCase();
            if (matchedText.match(this.OTHER_PATTERNS[0])) {
                if (refMoment.hour() > 1) {
                    startMoment.add(1, 'day');
                }
            } else if (matchedText.match(this.OTHER_PATTERNS[1])) {
                startMoment.add(-1, 'day');
            } else if (matchedText.match(this.OTHER_PATTERNS[2])) {
                result.start.imply(constants_1.HOUR, 22);
                result.start.imply(constants_1.MERIDIEM, 1);
            } else if (matchedText.match(this.OTHER_PATTERNS[3])) {
                result.start.imply(constants_1.HOUR, 0);
                if (refMoment.hour() > 6) {
                    startMoment.add(-1, 'day');
                }
            } else if (matchedText.match(this.OTHER_PATTERNS[4])) {
                result.start.imply(constants_1.HOUR, 14);
            } else if (matchedText.match(this.OTHER_PATTERNS[5])) {
                result.start.imply(constants_1.HOUR, 18);
            } else if (matchedText.match(this.OTHER_PATTERNS[6])) {
                result.start.imply(constants_1.HOUR, 8);
            } else if (matchedText.match(this.OTHER_PATTERNS[7])) {
                result.start.assign(constants_1.HOUR, refMoment.hour());
                result.start.assign(constants_1.MINUTE, refMoment.minute());
                result.start.assign(constants_1.SECOND, refMoment.second());
                result.start.assign(constants_1.MILLISECOND, refMoment.millisecond());
            }
            result.start.assign(constants_1.DAY, startMoment.date());
            result.start.assign(constants_1.MONTH, startMoment.month() + 1);
            result.start.assign(constants_1.YEAR, startMoment.year());
            result.tags[this.TAG] = true;
            return result;
        }
    }]);

    return FRCasualDateParser;
}(parser_1.default);

exports.default = FRCasualDateParser;

},{"../../constants":4,"../../result":66,"../parser":51,"moment":2}],37:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var moment = require("moment");
var general_1 = require("../../utils/general");
var FR_1 = require("../../utils/FR");

var FRDeadlineFormatParser = function (_parser_1$default) {
    _inherits(FRDeadlineFormatParser, _parser_1$default);

    function FRDeadlineFormatParser() {
        _classCallCheck(this, FRDeadlineFormatParser);

        var _this = _possibleConstructorReturn(this, (FRDeadlineFormatParser.__proto__ || Object.getPrototypeOf(FRDeadlineFormatParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\W|^)' + '(dans|en)\\s*' + '(' + FR_1.INTEGER_WORDS_PATTERN + '|[0-9]+|une?|(?:\\s*quelques)?|demi(?:\\s*|-?)?)\\s*' + '(secondes?|min(?:ute)?s?|heures?|jours?|semaines?|mois|années?)\\s*' + '(?=\\W|$)', 'i');
        _this.STRICT_PATTERN = new RegExp('(\\W|^)' + '(dans|en)\\s*' + '(' + FR_1.INTEGER_WORDS_PATTERN + '|[0-9]+|un?)\\s*' + '(secondes?|minutes?|heures?|jours?)\\s*' + '(?=\\W|$)', 'i');
        _this.NUM_MATCH = 3;
        _this.UNIT_MATCH = 4;
        _this.TAG = 'FRDeadlineFormatParser';
        return _this;
    }

    _createClass(FRDeadlineFormatParser, [{
        key: "pattern",
        value: function pattern() {
            return this.isStrictMode() ? this.STRICT_PATTERN : this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length, match[0].length - match[1].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var num = FR_1.matchNumber(match[this.NUM_MATCH].toLowerCase());
            var matchedUnit = FR_1.matchUnit(match[this.UNIT_MATCH].toLowerCase());
            if (num && matchedUnit && general_1.deadlineCalculations(num, matchedUnit, result, moment(ref))) {
                return result;
            }
            return null;
        }
    }]);

    return FRDeadlineFormatParser;
}(parser_1.default);

exports.default = FRDeadlineFormatParser;

},{"../../result":66,"../../utils/FR":70,"../../utils/general":73,"../parser":51,"moment":2}],38:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var FR_1 = require("../../utils/FR");
var constants_1 = require("../../constants");
var general_1 = require("../../utils/general");

var FRMonthNameLittleEndianParser = function (_parser_1$default) {
    _inherits(FRMonthNameLittleEndianParser, _parser_1$default);

    function FRMonthNameLittleEndianParser() {
        _classCallCheck(this, FRMonthNameLittleEndianParser);

        var _this = _possibleConstructorReturn(this, (FRMonthNameLittleEndianParser.__proto__ || Object.getPrototypeOf(FRMonthNameLittleEndianParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\W|^)' + '(?:(Dimanche|Lundi|Mardi|mercredi|Jeudi|Vendredi|Samedi|Dim|Lun|Mar|Mer|Jeu|Ven|Sam)\\s*,?\\s*)?' + '([0-9]{1,2}|1er)' + '(?:\\s*(?:au|\\-|\\–|jusqu\'au?|\\s)\\s*([0-9]{1,2})(?:er)?)?\\s*(?:de)?\\s*' + '(Jan(?:vier|\\.)?|F[ée]v(?:rier|\\.)?|Mars|Avr(?:il|\\.)?|Mai|Juin|Juil(?:let|\\.)?|Ao[uû]t|Sept(?:embre|\\.)?|Oct(?:obre|\\.)?|Nov(?:embre|\\.)?|d[ée]c(?:embre|\\.)?)' + '(?:\\s*(\\s*[0-9]{1,4}(?![^\\s]\\d))(?:\\s*(AC|[ap]\\.?\\s*c(?:h(?:r)?)?\\.?\\s*n\\.?))?)?' + '(?=\\W|$)', 'i');
        _this.WEEKDAY_GROUP = 2;
        _this.DATE_GROUP = 3;
        _this.DATE_TO_GROUP = 4;
        _this.MONTH_NAME_GROUP = 5;
        _this.YEAR_GROUP = 6;
        _this.YEAR_BE_GROUP = 7;
        _this.TAG = 'FRMonthNameLittleEndianParser';
        return _this;
    }

    _createClass(FRMonthNameLittleEndianParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length, match[0].length - match[1].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var month = FR_1.MONTH_OFFSET[match[this.MONTH_NAME_GROUP].toLowerCase()];
            if (!(month || month === 0)) {
                return null;
            }
            var day = parseInt(match[this.DATE_GROUP], 10);
            if (!day) {
                return null;
            }
            result.start.assign(constants_1.DAY, day);
            result.start.assign(constants_1.MONTH, month);
            var year = FR_1.yearCalculation(match[this.YEAR_GROUP], match[this.YEAR_BE_GROUP]);
            if (year) {
                result.start.assign(constants_1.YEAR, year);
            } else {
                general_1.getAppropriateYear(result.start, ref);
            }
            // Weekday component
            if (match[this.WEEKDAY_GROUP]) {
                var weekday = FR_1.WEEKDAY_OFFSET[match[this.WEEKDAY_GROUP].toLowerCase()];
                if (weekday || weekday === 0) {
                    result.start.assign(constants_1.WEEKDAY, weekday);
                }
            }
            // Text can be 'range' value. Such as '12 - 13 January 2012'
            if (match[this.DATE_TO_GROUP]) {
                var endDate = parseInt(match[this.DATE_TO_GROUP], 10);
                if (endDate) {
                    result.end = result.start.clone();
                    result.end.assign(constants_1.DAY, endDate);
                }
            }
            return result;
        }
    }]);

    return FRMonthNameLittleEndianParser;
}(parser_1.default);

exports.default = FRMonthNameLittleEndianParser;

},{"../../constants":4,"../../result":66,"../../utils/FR":70,"../../utils/general":73,"../parser":51}],39:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var moment = require("moment");
var parser_1 = require("../parser");
var result_1 = require("../../result");
var FR_1 = require("../../utils/FR");
var constants_1 = require("../../constants");
// Force load fr localization data from moment for the locale files to be linkded durning browserify.
// NOTE: The function moment.defineLocale() also has a side effect that it change global locale
//  We also need to save and restore the previous locale (see. moment.js, loadLocale)
var originalLocale = moment.locale();
var ignored = require('moment/locale/fr');
moment.locale(originalLocale);

var FRRelativeDateFormatParser = function (_parser_1$default) {
    _inherits(FRRelativeDateFormatParser, _parser_1$default);

    function FRRelativeDateFormatParser() {
        _classCallCheck(this, FRRelativeDateFormatParser);

        var _this = _possibleConstructorReturn(this, (FRRelativeDateFormatParser.__proto__ || Object.getPrototypeOf(FRRelativeDateFormatParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\W|^)' + '(?:les?|la|l\'|du|des?)\\s*' + '(' + FR_1.INTEGER_WORDS_PATTERN + '|\\d+)?\\s*' + '(prochaine?s?|derni[eè]re?s?|pass[ée]e?s?|pr[ée]c[ée]dents?|suivante?s?)?\\s*' + '(secondes?|min(?:ute)?s?|heures?|jours?|semaines?|mois|trimestres?|années?)\\s*' + '(prochaine?s?|derni[eè]re?s?|pass[ée]e?s?|pr[ée]c[ée]dents?|suivante?s?)?' + '(?=\\W|$)', 'i');
        _this.MULTIPLIER_GROUP = 2;
        _this.MODIFIER_1_GROUP = 3;
        _this.RELATIVE_WORD_GROUP = 4;
        _this.MODIFIER_2_GROUP = 5;
        _this.OTHER_PATTERNS = [/prochaine?s?|suivants?/, /derni[eè]re?s?|pass[ée]e?s?|pr[ée]c[ée]dents?/];
        _this.TAG = 'FRRelativeDateFormatParser';
        return _this;
    }

    _createClass(FRRelativeDateFormatParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length, match[0].length - match[1].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var matchedMultiplier = match[this.MULTIPLIER_GROUP];
            var num = FR_1.matchNumber(matchedMultiplier);
            var matchedModifier = (match[this.MODIFIER_1_GROUP] || match[this.MODIFIER_2_GROUP] || '').toLowerCase();
            if (!matchedModifier) {
                return null;
            }
            var modifierFactor = void 0;
            if (this.OTHER_PATTERNS[0].test(matchedModifier)) {
                modifierFactor = 1;
            } else if (this.OTHER_PATTERNS[1].test(matchedModifier)) {
                modifierFactor = -1;
            } else {
                return null;
            }
            var total = modifierFactor * (num || 1);
            var dateFrom = moment(ref).locale('fr');
            var dateTo = dateFrom.clone();
            var unit = FR_1.matchUnit((match[this.RELATIVE_WORD_GROUP] || '').toLowerCase());
            if (!unit) {
                return null;
            }
            var startOf = void 0;
            switch (unit) {
                case constants_1.SECOND:
                    dateFrom.add(total, 's');
                    dateTo.add(modifierFactor, 's');
                    startOf = 'second';
                    break;
                case constants_1.MINUTE:
                    dateFrom.add(total, 'm');
                    dateTo.add(modifierFactor, 'm');
                    startOf = 'minute';
                    break;
                case constants_1.HOUR:
                    dateFrom.add(total, 'h');
                    dateTo.add(modifierFactor, 'h');
                    startOf = 'hour';
                    break;
                case constants_1.DAY:
                    dateFrom.add(total, 'd');
                    dateTo.add(modifierFactor, 'd');
                    startOf = 'day';
                    break;
                case constants_1.WEEK:
                    dateFrom.add(total, 'w');
                    dateTo.add(modifierFactor, 'w');
                    startOf = 'week';
                    break;
                case constants_1.MONTH:
                    dateFrom.add(total, 'M');
                    dateTo.add(modifierFactor, 'M');
                    startOf = 'month';
                    break;
                case constants_1.YEAR:
                    dateFrom.add(total, 'y');
                    dateTo.add(modifierFactor, 'y');
                    startOf = 'year';
                    break;
                default:
                    return null;
            }
            if (modifierFactor > 0) {
                var _ref = [dateTo, dateFrom];
                dateFrom = _ref[0];
                dateTo = _ref[1];
            }
            // Get start and end of dates
            dateFrom.startOf(startOf);
            dateTo.endOf(startOf);
            result.start.assign(constants_1.YEAR, dateFrom.year());
            result.start.assign(constants_1.MONTH, dateFrom.month() + 1);
            result.start.assign(constants_1.DAY, dateFrom.date());
            result.start.assign(constants_1.MINUTE, dateFrom.minute());
            result.start.assign(constants_1.SECOND, dateFrom.second());
            result.start.assign(constants_1.HOUR, dateFrom.hour());
            result.start.assign(constants_1.MILLISECOND, dateFrom.millisecond());
            result.end = result.start.clone();
            result.end.assign(constants_1.YEAR, dateTo.year());
            result.end.assign(constants_1.MONTH, dateTo.month() + 1);
            result.end.assign(constants_1.DAY, dateTo.date());
            result.end.assign(constants_1.MINUTE, dateTo.minute());
            result.end.assign(constants_1.SECOND, dateTo.second());
            result.end.assign(constants_1.HOUR, dateTo.hour());
            result.end.assign(constants_1.MILLISECOND, dateTo.millisecond());
            return result;
        }
    }]);

    return FRRelativeDateFormatParser;
}(parser_1.default);

exports.default = FRRelativeDateFormatParser;

},{"../../constants":4,"../../result":66,"../../utils/FR":70,"../parser":51,"moment":2,"moment/locale/fr":1}],40:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
/*
    Date format with slash "/" (also "-" and ".") between numbers
    - Martes 3/11/2015
    - 3/11/2015
    - 3/11
*/
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
var FR_1 = require("../../utils/FR");
var general_1 = require("../../utils/general");
var moment = require("moment");

var FRSlashDateFormatParser = function (_parser_1$default) {
    _inherits(FRSlashDateFormatParser, _parser_1$default);

    function FRSlashDateFormatParser() {
        _classCallCheck(this, FRSlashDateFormatParser);

        var _this = _possibleConstructorReturn(this, (FRSlashDateFormatParser.__proto__ || Object.getPrototypeOf(FRSlashDateFormatParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\W|^)' + '(?:' + '((?:dimanche|dim|lundi|lun|mardi|mar|mercredi|mer|jeudi|jeu|vendredi|ven|samedi|sam|le))' + '\\s*\\,?\\s*' + ')?' + '([0-3]{0,1}[0-9]{1})[\\/\\.\\-]([0-3]{0,1}[0-9]{1})' + '(?:' + '[\\/\\.\\-]' + '([0-9]{4}\s*\,?\s*|[0-9]{2}\s*\,?\s*)' + ')?' + '(\\W|$)', 'i');
        _this.OPENING_GROUP = 1;
        _this.ENDING_GROUP = 6;
        _this.WEEKDAY_GROUP = 2;
        _this.MONTH_GROUP = 4;
        _this.DAY_GROUP = 3;
        _this.YEAR_GROUP = 5;
        _this.TAG = 'FRSlashDateFormatParser';
        _this.OTHER_PATTERNS = [/^\d\.\d$/, /^\d\.\d{1,2}\.\d{1,2}$/];
        return _this;
    }

    _createClass(FRSlashDateFormatParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            if (match[this.OPENING_GROUP] == '/' || match[this.ENDING_GROUP] == '/') {
                // Long skip, if there is some overlapping like:
                // XX[/YY/ZZ]
                // [XX/YY/]ZZ
                match.index += match[0].length;
                return null;
            }
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[this.OPENING_GROUP].length, match[0].length - match[this.ENDING_GROUP].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var matchedText = result.text.toLowerCase();
            if (matchedText.match(this.OTHER_PATTERNS[0]) || matchedText.match(this.OTHER_PATTERNS[1])) {
                return null;
            }
            // MM/dd -> OK
            // MM.dd -> NG
            if (!match[this.YEAR_GROUP] && match[0].indexOf('/') < 0) {
                return null;
            }
            var year = match[this.YEAR_GROUP] ? parseInt(match[this.YEAR_GROUP], 10) : moment(ref).year();
            var month = parseInt(match[this.MONTH_GROUP], 10);
            var day = parseInt(match[this.DAY_GROUP], 10);
            if (month < 1 || day < 1 || day > 31) {
                return null;
            }
            if (year < 100) {
                year = year + 2000;
            }
            if (month > 12) {
                if (month <= 31 && day <= 12 && general_1.checkMonthDaysValid(month, day, year)) {
                    var _ref = [day, month];
                    month = _ref[0];
                    day = _ref[1];
                } else {
                    return null;
                }
            }
            result.start.assign(constants_1.DAY, day);
            result.start.assign(constants_1.MONTH, month);
            if (match[this.YEAR_GROUP]) {
                result.start.assign(constants_1.YEAR, year);
            } else {
                general_1.getAppropriateYear(result.start, ref);
            }
            if (match[this.WEEKDAY_GROUP]) {
                result.start.assign(constants_1.WEEKDAY, FR_1.WEEKDAY_OFFSET[match[this.WEEKDAY_GROUP].toLowerCase()]);
            }
            return result;
        }
    }]);

    return FRSlashDateFormatParser;
}(parser_1.default);

exports.default = FRSlashDateFormatParser;

},{"../../constants":4,"../../result":66,"../../utils/FR":70,"../../utils/general":73,"../parser":51,"moment":2}],41:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
var FR_1 = require("../../utils/FR");
var moment = require("moment");
var Mode;
(function (Mode) {
    Mode[Mode["NONE"] = 0] = "NONE";
    Mode[Mode["TIME"] = 1] = "TIME";
    Mode[Mode["WEEK"] = 2] = "WEEK";
    Mode[Mode["DATE"] = 3] = "DATE";
})(Mode || (Mode = {}));

var FRTimeAgoFormatParser = function (_parser_1$default) {
    _inherits(FRTimeAgoFormatParser, _parser_1$default);

    function FRTimeAgoFormatParser() {
        _classCallCheck(this, FRTimeAgoFormatParser);

        var _this = _possibleConstructorReturn(this, (FRTimeAgoFormatParser.__proto__ || Object.getPrototypeOf(FRTimeAgoFormatParser)).apply(this, arguments));

        _this.PATTERN = /(\W|^)il y a\s*([0-9]+|une?)\s*(minutes?|heures?|semaines?|jours?|mois|années?|ans?)(?=(?:\W|$))/i;
        _this.TAG = 'FRTimeAgoFormatParser';
        _this.OTHER_PATTERNS = [/\w/];
        _this.NUM_MATCH = 2;
        _this.UNIT_MATCH = 3;
        return _this;
    }

    _createClass(FRTimeAgoFormatParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            if (match.index > 0 && text[match.index - 1].match(this.OTHER_PATTERNS[0])) return null;
            var index = match.index + match[1].length;
            var result = new result_1.ParsedResult({
                text: match[0].substr(match[1].length, match[0].length - match[1].length),
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var num = FR_1.matchNumber(match[this.NUM_MATCH]);
            var matchedUnit = FR_1.matchUnit(match[this.UNIT_MATCH].toLowerCase());
            var mode = Mode.NONE;
            var momentRef = moment(ref);
            switch (matchedUnit) {
                case constants_1.HOUR:
                    momentRef.add(-num, 'hour');
                    mode = Mode.TIME;
                    break;
                case constants_1.MINUTE:
                    momentRef.add(-num, 'minute');
                    mode = Mode.TIME;
                    break;
                case constants_1.WEEK:
                    momentRef.add(-num, 'week');
                    mode = Mode.WEEK;
                    break;
                case constants_1.DAY:
                    momentRef.add(-num, 'd');
                    mode = Mode.DATE;
                    break;
                case constants_1.MONTH:
                    momentRef.add(-num, 'month');
                    mode = Mode.DATE;
                    break;
                case constants_1.YEAR:
                    momentRef.add(-num, 'year');
                    mode = Mode.DATE;
                    break;
                default:
                    return null;
            }
            switch (mode) {
                case Mode.TIME:
                    result.start.imply(constants_1.DAY, momentRef.date());
                    result.start.imply(constants_1.MONTH, momentRef.month() + 1);
                    result.start.imply(constants_1.YEAR, momentRef.year());
                    result.start.assign(constants_1.HOUR, momentRef.hour());
                    result.start.assign(constants_1.MINUTE, momentRef.minute());
                    break;
                case Mode.DATE:
                    result.start.assign(constants_1.DAY, momentRef.date());
                    result.start.assign(constants_1.MONTH, momentRef.month() + 1);
                    result.start.assign(constants_1.YEAR, momentRef.year());
                    break;
                case Mode.WEEK:
                    result.start.imply(constants_1.DAY, momentRef.date());
                    result.start.imply(constants_1.MONTH, momentRef.month() + 1);
                    result.start.imply(constants_1.YEAR, momentRef.year());
                    result.start.imply(constants_1.WEEKDAY, momentRef.day());
                    break;
                default:
                    return null;
            }
            return result;
        }
    }]);

    return FRTimeAgoFormatParser;
}(parser_1.default);

exports.default = FRTimeAgoFormatParser;

},{"../../constants":4,"../../result":66,"../../utils/FR":70,"../parser":51,"moment":2}],42:[function(require,module,exports){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
var moment = require("moment");

var FRTimeExpressionParser = function (_parser_1$default) {
    _inherits(FRTimeExpressionParser, _parser_1$default);

    function FRTimeExpressionParser() {
        _classCallCheck(this, FRTimeExpressionParser);

        var _this = _possibleConstructorReturn(this, (FRTimeExpressionParser.__proto__ || Object.getPrototypeOf(FRTimeExpressionParser)).apply(this, arguments));

        _this.PATTERN = new RegExp("(^|\\s|T)" + "(?:(?:[àa])\\s*)?" + "(\\d{1,2}(?:h)?|midi|minuit)" + "(?:" + "(?:\\.|\\:|\\：|h)(\\d{1,2})(?:m)?" + "(?:" + "(?:\\:|\\：|m)(\\d{0,2})(?:s)?" + ")?" + ")?" + "(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?" + "(?=\\W|$)", 'i');
        _this.END_PATTERN = new RegExp("^\\s*" + "(\\-|\\–|\\~|\\〜|[àa]|\\?)\\s*" + "(\\d{1,2}(?:h)?)" + "(?:" + "(?:\\.|\\:|\\：|h)(\\d{1,2})(?:m)?" + "(?:" + "(?:\\.|\\:|\\：|m)(\\d{1,2})(?:s)?" + ")?" + ")?" + "(?:\\s*(A\\.M\\.|P\\.M\\.|AM?|PM?))?" + "(?=\\W|$)", 'i');
        _this.HOUR_GROUP = 2;
        _this.MINUTE_GROUP = 3;
        _this.SECOND_GROUP = 4;
        _this.AM_PM_HOUR_GROUP = 5;
        _this.TAG = 'FRTimeExpressionParser';
        _this.OTHER_PATTERNS = [/\w/, /^\s*([+\-])\s*\d{3,4}$/, /^\d+$/];
        return _this;
    }

    _createClass(FRTimeExpressionParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            // This pattern can be overlaped Ex. [12] AM, 1[2] AM
            if (match.index > 0 && text[match.index - 1].match(this.OTHER_PATTERNS[0])) return null;
            var refMoment = moment(ref);
            var result = new result_1.ParsedResult({
                text: match[0].substring(match[1].length),
                index: match.index + match[1].length,
                ref: ref
            });
            result.tags[this.TAG] = true;
            result.start.imply(constants_1.DAY, refMoment.date());
            result.start.imply(constants_1.MONTH, refMoment.month() + 1);
            result.start.imply(constants_1.YEAR, refMoment.year());
            if (!this.extractFirstChunk(result, match)) {
                return null;
            }
            if (!this.extractSecondChunk(text, result) && result.text.match(this.OTHER_PATTERNS[2])) {
                return null;
            }
            return result;
        }
    }, {
        key: "extractFirstChunk",
        value: function extractFirstChunk(result, match) {
            var time = this.getTime(match);
            if (!time) {
                return false;
            }

            var _time = _slicedToArray(time, 4),
                hour = _time[0],
                minute = _time[1],
                second = _time[2],
                meridiem = _time[3];

            if (second > -1) {
                result.start.assign(constants_1.SECOND, second);
            }
            // ----- AM & PM
            if (match[this.AM_PM_HOUR_GROUP]) {
                if (hour > 12) return false;
                var ampm = match[this.AM_PM_HOUR_GROUP][0].toLowerCase();
                if (ampm === 'a') {
                    meridiem = 0;
                    if (hour === 12) hour = 0;
                } else if (ampm === 'p') {
                    meridiem = 1;
                    if (hour !== 12) hour += 12;
                }
            }
            result.start.assign(constants_1.HOUR, hour);
            result.start.assign(constants_1.MINUTE, minute);
            if (meridiem >= 0) {
                result.start.assign(constants_1.MERIDIEM, meridiem);
            } else {
                if (hour < 12) {
                    result.start.imply(constants_1.MERIDIEM, 0);
                } else {
                    result.start.imply(constants_1.MERIDIEM, 1);
                }
            }
            return true;
        }
    }, {
        key: "extractSecondChunk",
        value: function extractSecondChunk(text, result) {
            var match = this.END_PATTERN.exec(text.substring(result.index + result.text.length));
            if (!match) {
                return false;
            }
            // Pattern "YY.YY -XXXX" is more like timezone offset
            if (match[0].match(this.OTHER_PATTERNS[1])) {
                return true;
            }
            var time = this.getTime(match);
            if (!time) {
                return true;
            }

            var _time2 = _slicedToArray(time, 4),
                hour = _time2[0],
                minute = _time2[1],
                second = _time2[2],
                meridiem = _time2[3];

            if (!result.end) {
                result.end = new result_1.ParsedComponents(undefined, result.start.date());
            }
            if (second > -1) {
                result.end.assign(constants_1.SECOND, second);
            }
            // ----- AM & PM
            if (match[this.AM_PM_HOUR_GROUP]) {
                if (hour > 12) return false;
                var ampm = match[this.AM_PM_HOUR_GROUP][0].toLowerCase();
                if (ampm === 'a') {
                    meridiem = 0;
                    if (hour === 12) {
                        hour = 0;
                        if (!result.end.isCertain(constants_1.DAY)) {
                            result.end.imply(constants_1.DAY, result.end.get(constants_1.DAY) + 1);
                        }
                    }
                }
                if (ampm === 'p') {
                    meridiem = 1;
                    if (hour !== 12) hour += 12;
                }
                if (!result.start.isCertain(constants_1.MERIDIEM)) {
                    if (meridiem === 0) {
                        result.start.imply(constants_1.MERIDIEM, 0);
                        if (result.start.get(constants_1.HOUR) === 12) {
                            result.start.assign(constants_1.HOUR, 0);
                        }
                    } else {
                        result.start.imply(constants_1.MERIDIEM, 1);
                        if (result.start.get(constants_1.HOUR) !== 12) {
                            result.start.assign(constants_1.HOUR, result.start.get(constants_1.HOUR) + 12);
                        }
                    }
                }
            }
            result.text = result.text + match[0];
            result.end.assign(constants_1.HOUR, hour);
            result.end.assign(constants_1.MINUTE, minute);
            if (meridiem >= 0) {
                result.end.assign(constants_1.MERIDIEM, meridiem);
            } else {
                var startAtPM = result.start.isCertain(constants_1.MERIDIEM) && result.start.get(constants_1.MERIDIEM) === 1;
                if (startAtPM && result.start.get(constants_1.HOUR) > hour) {
                    // 10pm - 1 (am)
                    result.end.imply(constants_1.MERIDIEM, 0);
                } else if (hour > 12) {
                    result.end.imply(constants_1.MERIDIEM, 1);
                }
            }
            if (result.end.date().getTime() < result.start.date().getTime()) {
                result.end.imply(constants_1.DAY, result.end.get(constants_1.DAY) + 1);
            }
            return true;
        }
    }, {
        key: "getTime",
        value: function getTime(match) {
            var second = -1;
            var hour = 0;
            var minute = 0;
            var meridiem = -1;
            // ----- Second
            if (match[this.SECOND_GROUP]) {
                second = parseInt(match[this.SECOND_GROUP], 10);
                if (second >= 60) return false;
            }
            // ----- Hours
            if (match[this.HOUR_GROUP].toLowerCase() === 'midi') {
                meridiem = 1;
                hour = 12;
            } else if (match[this.HOUR_GROUP].toLowerCase() === 'minuit') {
                meridiem = 0;
                hour = 0;
            } else {
                hour = parseInt(match[this.HOUR_GROUP], 10);
            }
            // ----- Minutes
            if (match[this.MINUTE_GROUP]) {
                minute = parseInt(match[this.MINUTE_GROUP], 10);
            } else if (hour > 100) {
                minute = hour % 100;
                hour = Math.floor(hour / 100);
            }
            if (minute >= 60) {
                return false;
            }
            if (hour > 24) {
                return false;
            }
            if (hour >= 12) {
                meridiem = 1;
            }
            return [hour, minute, second, meridiem];
        }
    }]);

    return FRTimeExpressionParser;
}(parser_1.default);

exports.default = FRTimeExpressionParser;

},{"../../constants":4,"../../result":66,"../parser":51,"moment":2}],43:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var FR_1 = require("../../utils/FR");
var general_1 = require("../../utils/general");

var FRWeekdayParser = function (_parser_1$default) {
    _inherits(FRWeekdayParser, _parser_1$default);

    function FRWeekdayParser() {
        _classCallCheck(this, FRWeekdayParser);

        var _this = _possibleConstructorReturn(this, (FRWeekdayParser.__proto__ || Object.getPrototypeOf(FRWeekdayParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\s|^)' + '(?:(?:\\,|\\(|\\（)\\s*)?' + '(?:(ce)\\s*)?' + '(' + Object.keys(FR_1.WEEKDAY_OFFSET).join('|') + ')' + '(?:\\s*(?:\\,|\\)|\\）))?' + '(?:\\s*(dernier|prochain)\\s*)?' + '(?=\\W|$)', 'i');
        _this.PREFIX_GROUP = 2;
        _this.WEEKDAY_GROUP = 3;
        _this.POSTFIX_GROUP = 4;
        _this.TAG = 'FRWeekdayParser';
        return _this;
    }

    _createClass(FRWeekdayParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index + match[1].length;
            var matchedText = match[0].substr(match[1].length, match[0].length - match[1].length);
            var result = new result_1.ParsedResult({
                text: matchedText,
                index: index,
                ref: ref
            });
            var offset = FR_1.WEEKDAY_OFFSET[match[this.WEEKDAY_GROUP].toLowerCase()];
            if (offset === undefined) return null;
            var prefix = match[this.PREFIX_GROUP];
            var postfix = match[this.POSTFIX_GROUP];
            var norm = (prefix || postfix || '').toLowerCase();
            var modifier = general_1.Modifier.UNKNOWN;
            if (norm == 'ce') {
                modifier = general_1.Modifier.THIS;
            } else if (norm === 'dernier') {
                modifier = general_1.Modifier.LAST;
            } else if (norm == 'prochain') {
                modifier = general_1.Modifier.NEXT;
            }
            result.tags[this.TAG] = true;
            general_1.updateParsedComponent(result, ref, offset, modifier);
            return result;
        }
    }]);

    return FRWeekdayParser;
}(parser_1.default);

exports.default = FRWeekdayParser;

},{"../../result":66,"../../utils/FR":70,"../../utils/general":73,"../parser":51}],44:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var moment = require("moment");
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");

var JPCasualDateParser = function (_parser_1$default) {
    _inherits(JPCasualDateParser, _parser_1$default);

    function JPCasualDateParser() {
        _classCallCheck(this, JPCasualDateParser);

        var _this = _possibleConstructorReturn(this, (JPCasualDateParser.__proto__ || Object.getPrototypeOf(JPCasualDateParser)).apply(this, arguments));

        _this.PATTERN = /今日|当日|昨日|明日|今夜|今夕|今晩|今朝/i;
        _this.TAG = 'JPCasualDateParser';
        return _this;
    }

    _createClass(JPCasualDateParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index;
            var result = new result_1.ParsedResult({
                text: match[0],
                index: index,
                ref: ref
            });
            var refMoment = moment(ref);
            var startMoment = refMoment.clone();
            var matchedText = result.text;
            if (matchedText === '今夜' || matchedText === '今夕' || matchedText === '今晩') {
                // Normally means this coming midnight
                result.start.imply(constants_1.HOUR, 22);
                result.start.imply(constants_1.MERIDIEM, 1);
            } else if (matchedText === '明日') {
                // Check not "Tomorrow" on late night
                if (refMoment.hour() > 4) {
                    startMoment.add(1, 'day');
                }
            } else if (matchedText === '昨日') {
                startMoment.add(-1, 'day');
            } else if (matchedText.match("今朝")) {
                result.start.imply(constants_1.HOUR, 6);
                result.start.imply(constants_1.MERIDIEM, 0);
            }
            result.start.assign(constants_1.DAY, startMoment.date());
            result.start.assign(constants_1.MONTH, startMoment.month() + 1);
            result.start.assign(constants_1.YEAR, startMoment.year());
            result.tags[this.TAG] = true;
            return result;
        }
    }]);

    return JPCasualDateParser;
}(parser_1.default);

exports.default = JPCasualDateParser;

},{"../../constants":4,"../../result":66,"../parser":51,"moment":2}],45:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var moment = require("moment");
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
var JP_1 = require("../../utils/JP");
var general_1 = require("../../utils/general");

var JPStandardParser = function (_parser_1$default) {
    _inherits(JPStandardParser, _parser_1$default);

    function JPStandardParser() {
        _classCallCheck(this, JPStandardParser);

        var _this = _possibleConstructorReturn(this, (JPStandardParser.__proto__ || Object.getPrototypeOf(JPStandardParser)).apply(this, arguments));

        _this.PATTERN = /(?:(同|((昭和|平成)?([0-9０-９]{2,4})))年\s*)?([0-9０-９]{1,2})月\s*([0-9０-９]{1,2})日/i;
        _this.YEAR_GROUP = 2;
        _this.ERA_GROUP = 3;
        _this.YEAR_NUMBER_GROUP = 4;
        _this.MONTH_GROUP = 5;
        _this.DAY_GROUP = 6;
        _this.OTHER_PATTERNS = [/同年/];
        _this.TAG = 'JPStandardParser';
        return _this;
    }

    _createClass(JPStandardParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index;
            var result = new result_1.ParsedResult({
                text: match[0],
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var startMoment = moment(ref);
            var month = parseInt(JP_1.toHankaku(match[this.MONTH_GROUP]), 10);
            var day = parseInt(JP_1.toHankaku(match[this.DAY_GROUP]), 10);
            startMoment.set('date', day);
            startMoment.set('month', month - 1);
            result.start.assign(constants_1.DAY, startMoment.date());
            result.start.assign(constants_1.MONTH, startMoment.month() + 1);
            var matchedYear = match[this.YEAR_GROUP] || '';
            if (matchedYear.match(this.OTHER_PATTERNS[0])) {
                result.start.assign(constants_1.YEAR, startMoment.year());
            } else if (matchedYear) {
                var year = parseInt(JP_1.toHankaku(match[this.YEAR_NUMBER_GROUP]), 10);
                if (match[this.ERA_GROUP] === '平成') {
                    year += 1988;
                } else if (match[this.ERA_GROUP] === '昭和') {
                    year += 1925;
                }
                result.start.assign(constants_1.YEAR, year);
            } else {
                general_1.getAppropriateYear(result.start, ref);
            }
            return result;
        }
    }]);

    return JPStandardParser;
}(parser_1.default);

exports.default = JPStandardParser;

},{"../../constants":4,"../../result":66,"../../utils/JP":71,"../../utils/general":73,"../parser":51,"moment":2}],46:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var moment = require("moment");
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");

var ZHHantCasualDateParser = function (_parser_1$default) {
    _inherits(ZHHantCasualDateParser, _parser_1$default);

    function ZHHantCasualDateParser() {
        _classCallCheck(this, ZHHantCasualDateParser);

        var _this = _possibleConstructorReturn(this, (ZHHantCasualDateParser.__proto__ || Object.getPrototypeOf(ZHHantCasualDateParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(而家|立(?:刻|即)|即刻)|' + '(今|明|聽|昨|尋|琴)(早|朝|晚)|' + '(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|' + '(今|明|聽|昨|尋|琴)(?:日|天)' + '(?:[\\s|,|，]*)' + '(?:(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?', 'i');
        _this.NOW_GROUP = 1;
        _this.DAY_GROUP_1 = 2;
        _this.TIME_GROUP_1 = 3;
        _this.TIME_GROUP_2 = 4;
        _this.DAY_GROUP_3 = 5;
        _this.TIME_GROUP_3 = 6;
        _this.TAG = 'ZHCasualDateParser';
        return _this;
    }

    _createClass(ZHHantCasualDateParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index;
            var result = new result_1.ParsedResult({
                text: match[0],
                index: index,
                ref: ref
            });
            var refMoment = moment(ref);
            var startMoment = refMoment.clone();
            if (match[this.NOW_GROUP]) {
                result.start.imply(constants_1.HOUR, refMoment.hour());
                result.start.imply(constants_1.MINUTE, refMoment.minute());
                result.start.imply(constants_1.SECOND, refMoment.second());
                result.start.imply(constants_1.MILLISECOND, refMoment.millisecond());
            } else if (match[this.DAY_GROUP_1]) {
                var day1 = match[this.DAY_GROUP_1];
                var time1 = match[this.TIME_GROUP_1];
                if (day1 === '明' || day1 === '聽') {
                    // Check not "Tomorrow" on late night
                    if (refMoment.hour() > 1) {
                        startMoment.add(1, 'day');
                    }
                } else if (day1 === '昨' || day1 === '尋' || day1 === '琴') {
                    startMoment.add(-1, 'day');
                }
                if (time1 === '早' || time1 === '朝') {
                    result.start.imply(constants_1.HOUR, 6);
                } else if (time1 === '晚') {
                    result.start.imply(constants_1.HOUR, 22);
                    result.start.imply(constants_1.MERIDIEM, 1);
                }
            } else if (match[this.TIME_GROUP_2]) {
                var timeString2 = match[this.TIME_GROUP_2];
                var time2 = timeString2[0];
                if (time2 === '早' || time2 === '朝' || time2 === '上') {
                    result.start.imply(constants_1.HOUR, 6);
                } else if (time2 === '下' || time2 === '晏') {
                    result.start.imply(constants_1.HOUR, 15);
                    result.start.imply(constants_1.MERIDIEM, 1);
                } else if (time2 === '中') {
                    result.start.imply(constants_1.HOUR, 12);
                    result.start.imply(constants_1.MERIDIEM, 1);
                } else if (time2 === '夜' || time2 === '晚') {
                    result.start.imply(constants_1.HOUR, 22);
                    result.start.imply(constants_1.MERIDIEM, 1);
                } else if (time2 === '凌') {
                    result.start.imply(constants_1.HOUR, 0);
                }
            } else if (match[this.DAY_GROUP_3]) {
                var day3 = match[this.DAY_GROUP_3];
                if (day3 === '明' || day3 === '聽') {
                    // Check not "Tomorrow" on late night
                    if (refMoment.hour() > 1) {
                        startMoment.add(1, 'day');
                    }
                } else if (day3 === '昨' || day3 === '尋' || day3 === '琴') {
                    startMoment.add(-1, 'day');
                }
                var timeString3 = match[this.TIME_GROUP_3];
                if (timeString3) {
                    var time3 = timeString3[0];
                    if (time3 === '早' || time3 === '朝' || time3 === '上') {
                        result.start.imply(constants_1.HOUR, 6);
                    } else if (time3 === '下' || time3 === '晏') {
                        result.start.imply(constants_1.HOUR, 15);
                        result.start.imply(constants_1.MERIDIEM, 1);
                    } else if (time3 === '中') {
                        result.start.imply(constants_1.HOUR, 12);
                        result.start.imply(constants_1.MERIDIEM, 1);
                    } else if (time3 === '夜' || time3 === '晚') {
                        result.start.imply(constants_1.HOUR, 22);
                        result.start.imply(constants_1.MERIDIEM, 1);
                    } else if (time3 === '凌') {
                        result.start.imply(constants_1.HOUR, 0);
                    }
                }
            }
            result.start.assign(constants_1.DAY, startMoment.date());
            result.start.assign(constants_1.MONTH, startMoment.month() + 1);
            result.start.assign(constants_1.YEAR, startMoment.year());
            result.tags[this.TAG] = true;
            return result;
        }
    }]);

    return ZHHantCasualDateParser;
}(parser_1.default);

exports.default = ZHHantCasualDateParser;

},{"../../constants":4,"../../result":66,"../parser":51,"moment":2}],47:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var moment = require("moment");
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
var ZH_Hant_1 = require("../../utils/ZH-Hant");

var ZHHantDateParser = function (_parser_1$default) {
    _inherits(ZHHantDateParser, _parser_1$default);

    function ZHHantDateParser() {
        _classCallCheck(this, ZHHantDateParser);

        var _this = _possibleConstructorReturn(this, (ZHHantDateParser.__proto__ || Object.getPrototypeOf(ZHHantDateParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\d{2,4}|[' + Object.keys(ZH_Hant_1.NUMBER).join('') + ']{2,4})?' + '(?:\\s*)' + '(?:年)?' + '(?:[\\s|,|，]*)' + '(\\d{1,2}|[' + Object.keys(ZH_Hant_1.NUMBER).join('') + ']{1,2})' + '(?:\\s*)' + '(?:月)' + '(?:\\s*)' + '(\\d{1,2}|[' + Object.keys(ZH_Hant_1.NUMBER).join('') + ']{1,2})?' + '(?:\\s*)' + '(?:日|號)?');
        _this.YEAR_GROUP = 1;
        _this.MONTH_GROUP = 2;
        _this.DAY_GROUP = 3;
        _this.TAG = 'ZHDateParser';
        return _this;
    }

    _createClass(ZHHantDateParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index;
            var result = new result_1.ParsedResult({
                text: match[0],
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var startMoment = moment(ref);
            var matchedMonth = match[this.MONTH_GROUP];
            var matchedDay = match[this.DAY_GROUP];
            var matchedYear = match[this.YEAR_GROUP];
            var month = parseInt(matchedMonth, 10);
            if (isNaN(month)) {
                month = ZH_Hant_1.zhStringToNumber(matchedMonth);
            }
            result.start.assign(constants_1.MONTH, month);
            if (matchedDay) {
                var day = parseInt(matchedDay, 10);
                if (isNaN(day)) {
                    day = ZH_Hant_1.zhStringToNumber(matchedDay);
                }
                result.start.assign(constants_1.DAY, day);
            } else {
                result.start.assign(constants_1.DAY, startMoment.date());
            }
            if (matchedYear) {
                var year = parseInt(matchedYear, 10);
                if (isNaN(year)) {
                    year = ZH_Hant_1.zhStringToYear(matchedYear);
                }
                result.start.assign(constants_1.YEAR, year);
            } else {
                result.start.assign(constants_1.YEAR, startMoment.year());
            }
            return result;
        }
    }]);

    return ZHHantDateParser;
}(parser_1.default);

exports.default = ZHHantDateParser;

},{"../../constants":4,"../../result":66,"../../utils/ZH-Hant":72,"../parser":51,"moment":2}],48:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var moment = require("moment");
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
var ZH_Hant_1 = require("../../utils/ZH-Hant");

var ZHHantDeadlineFormatParser = function (_parser_1$default) {
    _inherits(ZHHantDeadlineFormatParser, _parser_1$default);

    function ZHHantDeadlineFormatParser() {
        _classCallCheck(this, ZHHantDeadlineFormatParser);

        var _this = _possibleConstructorReturn(this, (ZHHantDeadlineFormatParser.__proto__ || Object.getPrototypeOf(ZHHantDeadlineFormatParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(\\d+|[' + Object.keys(ZH_Hant_1.NUMBER).join('') + ']+|半|幾)(?:\\s*)' + '(?:個)?' + '(秒(?:鐘)?|分鐘|小時|鐘|日|天|星期|禮拜|月|年)' + '(?:(?:之|過)?後|(?:之)?內)', 'i');
        _this.NUMBER_GROUP = 1;
        _this.UNIT_GROUP = 2;
        _this.TAG = 'ZHDeadlineFormatParser';
        return _this;
    }

    _createClass(ZHHantDeadlineFormatParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index;
            var result = new result_1.ParsedResult({
                text: match[0],
                index: index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            var matchedNumber = match[this.NUMBER_GROUP];
            var number = parseInt(matchedNumber, 10);
            if (isNaN(number)) {
                number = ZH_Hant_1.zhStringToNumber(matchedNumber);
                if (isNaN(number)) {
                    if (matchedNumber === '幾') {
                        number = 3;
                    } else if (matchedNumber === '半') {
                        number = 0.5;
                    } else {
                        return null;
                    }
                }
            }
            var date = moment(ref);
            var unitAbbr = match[this.UNIT_GROUP][0];
            var dateMode = false;
            switch (unitAbbr) {
                case '日':
                case '天':
                    date.add(number, 'd');
                    dateMode = true;
                    break;
                case '星':
                case '禮':
                    date.add(number * 7, 'd');
                    dateMode = true;
                    break;
                case '月':
                    date.add(number, 'month');
                    dateMode = true;
                    break;
                case '年':
                    date.add(number, 'year');
                    dateMode = true;
                    break;
                case '秒':
                    date.add(number, 'second');
                    break;
                case '分':
                    date.add(number, 'minute');
                    break;
                case '小':
                case '鐘':
                    date.add(number, 'hour');
                    break;
                default:
                    return null;
            }
            if (dateMode) {
                result.start.assign(constants_1.YEAR, date.year());
                result.start.assign(constants_1.MONTH, date.month() + 1);
                result.start.assign(constants_1.DAY, date.date());
            } else {
                result.start.imply(constants_1.YEAR, date.year());
                result.start.imply(constants_1.MONTH, date.month() + 1);
                result.start.imply(constants_1.DAY, date.date());
                result.start.assign(constants_1.HOUR, date.hour());
                result.start.assign(constants_1.MINUTE, date.minute());
                result.start.assign(constants_1.SECOND, date.second());
            }
            return result;
        }
    }]);

    return ZHHantDeadlineFormatParser;
}(parser_1.default);

exports.default = ZHHantDeadlineFormatParser;

},{"../../constants":4,"../../result":66,"../../utils/ZH-Hant":72,"../parser":51,"moment":2}],49:[function(require,module,exports){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var constants_1 = require("../../constants");
var moment = require("moment");
var ZH_Hant_1 = require("../../utils/ZH-Hant");

var ZHHantTimeExpressionParser = function (_parser_1$default) {
    _inherits(ZHHantTimeExpressionParser, _parser_1$default);

    function ZHHantTimeExpressionParser() {
        _classCallCheck(this, ZHHantTimeExpressionParser);

        var _this = _possibleConstructorReturn(this, (ZHHantTimeExpressionParser.__proto__ || Object.getPrototypeOf(ZHHantTimeExpressionParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(?:由|從|自)?' + '(?:' + '(今|明|聽|昨|尋|琴)(早|朝|晚)|' + '(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|' + '(今|明|聽|昨|尋|琴)(?:日|天)' + '(?:[\\s,，]*)' + '(?:(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?' + ')?' + '(?:[\\s,，]*)' + '(?:(\\d+|[' + Object.keys(ZH_Hant_1.NUMBER).join('') + ']+)(?:\\s*)(?:點|時|:|：)' + '(?:\\s*)' + '(\\d+|半|正|整|[' + Object.keys(ZH_Hant_1.NUMBER).join('') + ']+)?(?:\\s*)(?:分|:|：)?' + '(?:\\s*)' + '(\\d+|[' + Object.keys(ZH_Hant_1.NUMBER).join('') + ']+)?(?:\\s*)(?:秒)?)' + '(?:\\s*(A\.M\.|P\.M\.|AM?|PM?))?', 'i');
        _this.END_PATTERN = new RegExp('(?:\\s*(?:到|至|\\-|\\–|\\~|\\〜)\\s*)' + '(?:' + '(今|明|聽|昨|尋|琴)(早|朝|晚)|' + '(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨))|' + '(今|明|聽|昨|尋|琴)(?:日|天)' + '(?:[\\s,，]*)' + '(?:(上(?:午|晝)|朝(?:早)|早(?:上)|下(?:午|晝)|晏(?:晝)|晚(?:上)|夜(?:晚)?|中(?:午)|凌(?:晨)))?' + ')?' + '(?:[\\s,，]*)' + '(?:(\\d+|[' + Object.keys(ZH_Hant_1.NUMBER).join('') + ']+)(?:\\s*)(?:點|時|:|：)' + '(?:\\s*)' + '(\\d+|半|正|整|[' + Object.keys(ZH_Hant_1.NUMBER).join('') + ']+)?(?:\\s*)(?:分|:|：)?' + '(?:\\s*)' + '(\\d+|[' + Object.keys(ZH_Hant_1.NUMBER).join('') + ']+)?(?:\\s*)(?:秒)?)' + '(?:\\s*(A\.M\.|P\.M\.|AM?|PM?))?', 'i');
        _this.DAY_GROUP_1 = 1;
        _this.ZH_AM_PM_HOUR_GROUP_1 = 2;
        _this.ZH_AM_PM_HOUR_GROUP_2 = 3;
        _this.DAY_GROUP_3 = 4;
        _this.ZH_AM_PM_HOUR_GROUP_3 = 5;
        _this.HOUR_GROUP = 6;
        _this.MINUTE_GROUP = 7;
        _this.SECOND_GROUP = 8;
        _this.AM_PM_HOUR_GROUP = 9;
        _this.TAG = 'ZHTimeExpressionParser';
        _this.OTHER_PATTERNS = [/\w/, /^\s*([+\-])\s*\d{3,4}$/, /^\d+$/];
        return _this;
    }

    _createClass(ZHHantTimeExpressionParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            // This pattern can be overlaped Ex. [12] AM, 1[2] AM
            if (match.index > 0 && text[match.index - 1].match(this.OTHER_PATTERNS[0])) return null;
            var refMoment = moment(ref);
            var result = new result_1.ParsedResult({
                text: match[0],
                index: match.index,
                ref: ref
            });
            result.tags[this.TAG] = true;
            result.start.imply(constants_1.DAY, refMoment.date());
            result.start.imply(constants_1.MONTH, refMoment.month() + 1);
            result.start.imply(constants_1.YEAR, refMoment.year());
            var startMoment = refMoment.clone();
            if (!this.extractFirstChunk(result, match, refMoment, startMoment)) {
                return null;
            }
            var endMoment = startMoment.clone();
            if (!this.extractSecondChunk(text, result, refMoment, endMoment) && result.text.match(this.OTHER_PATTERNS[2])) {
                return null;
            }
            return result;
        }
    }, {
        key: "extractFirstChunk",
        value: function extractFirstChunk(result, match, refMoment, startMoment) {
            this.getDay(match, result.start, refMoment, startMoment);
            var time = this.getTime(match);
            if (!time) {
                return false;
            }

            var _time = _slicedToArray(time, 4),
                hour = _time[0],
                minute = _time[1],
                second = _time[2],
                meridiem = _time[3];

            if (second > -1) {
                result.start.assign(constants_1.SECOND, second);
            }
            var gotMeridiem = this.getMeridiem(match, meridiem, hour);
            if (!gotMeridiem) {
                return false;
            }

            var _gotMeridiem = _slicedToArray(gotMeridiem, 2);

            meridiem = _gotMeridiem[0];
            hour = _gotMeridiem[1];

            result.start.assign(constants_1.HOUR, hour);
            result.start.assign(constants_1.MINUTE, minute);
            if (meridiem >= 0) {
                result.start.assign(constants_1.MERIDIEM, meridiem);
            } else {
                if (hour < 12) {
                    result.start.imply(constants_1.MERIDIEM, 0);
                } else {
                    result.start.imply(constants_1.MERIDIEM, 1);
                }
            }
            return true;
        }
    }, {
        key: "extractSecondChunk",
        value: function extractSecondChunk(text, result, refMoment, endMoment) {
            var match = this.END_PATTERN.exec(text.substring(result.index + result.text.length));
            if (!match) {
                return false;
            }
            // Pattern "YY.YY -XXXX" is more like timezone offset
            if (match[0].match(this.OTHER_PATTERNS[1])) {
                return true;
            }
            if (!result.end) {
                result.end = new result_1.ParsedComponents(undefined, result.start.date());
            }
            this.getDay(match, result.end, refMoment, endMoment);
            var time = this.getTime(match);
            if (!time) {
                return true;
            }

            var _time2 = _slicedToArray(time, 4),
                hour = _time2[0],
                minute = _time2[1],
                second = _time2[2],
                meridiem = _time2[3];

            if (second > -1) {
                result.end.assign(constants_1.SECOND, second);
            }
            var gotMeridiem = this.getMeridiem(match, meridiem, hour);
            if (!gotMeridiem) {
                return false;
            }

            var _gotMeridiem2 = _slicedToArray(gotMeridiem, 2);

            meridiem = _gotMeridiem2[0];
            hour = _gotMeridiem2[1];

            result.text = result.text + match[0];
            result.end.assign(constants_1.HOUR, hour);
            result.end.assign(constants_1.MINUTE, minute);
            if (meridiem >= 0) {
                result.end.assign(constants_1.MERIDIEM, meridiem);
            } else {
                var startAtPM = result.start.isCertain(constants_1.MERIDIEM) && result.start.get(constants_1.MERIDIEM) === 1;
                if (startAtPM && result.start.get(constants_1.HOUR) > hour) {
                    // 10pm - 1 (am)
                    result.end.imply(constants_1.MERIDIEM, 0);
                } else if (hour > 12) {
                    result.end.imply(constants_1.MERIDIEM, 1);
                }
            }
            if (result.end.date().getTime() < result.start.date().getTime()) {
                result.end.imply(constants_1.DAY, result.end.get(constants_1.DAY) + 1);
            }
            return true;
        }
    }, {
        key: "getTime",
        value: function getTime(match) {
            var second = -1;
            var hour = void 0;
            var minute = 0;
            var meridiem = -1;
            // ----- Second
            if (match[this.SECOND_GROUP]) {
                second = parseInt(match[this.SECOND_GROUP], 10);
                if (isNaN(second)) {
                    second = ZH_Hant_1.zhStringToNumber(match[this.SECOND_GROUP]);
                }
                if (second >= 60) return false;
            }
            // ----- Hours
            hour = parseInt(match[this.HOUR_GROUP], 10);
            if (isNaN(hour)) {
                hour = ZH_Hant_1.zhStringToNumber(match[this.HOUR_GROUP]);
            }
            // ----- Minutes
            if (match[this.MINUTE_GROUP]) {
                if (match[this.MINUTE_GROUP] === '半') {
                    minute = 30;
                } else if (match[this.MINUTE_GROUP] === '正' || match[this.MINUTE_GROUP] === '整') {
                    minute = 0;
                } else {
                    minute = parseInt(match[this.MINUTE_GROUP], 10);
                    if (isNaN(minute)) {
                        minute = ZH_Hant_1.zhStringToNumber(match[this.MINUTE_GROUP]);
                    }
                }
            } else if (hour > 100) {
                minute = hour % 100;
                hour = Math.floor(hour / 100);
            }
            if (minute >= 60) {
                return false;
            }
            if (hour > 24) {
                return false;
            }
            if (hour >= 12) {
                meridiem = 1;
            }
            return [hour, minute, second, meridiem];
        }
    }, {
        key: "getDay",
        value: function getDay(match, current, refMoment, targetMoment) {
            // ----- Day
            if (match[this.DAY_GROUP_1]) {
                var day1 = match[this.DAY_GROUP_1];
                if (day1 === '明' || day1 === '聽') {
                    // Check not "Tomorrow" on late night
                    if (refMoment.hour() > 1) {
                        targetMoment.add(1, 'day');
                    }
                } else if (day1 === '昨' || day1 === '尋' || day1 === '琴') {
                    targetMoment.add(-1, 'day');
                }
                current.assign(constants_1.DAY, targetMoment.date());
                current.assign(constants_1.MONTH, targetMoment.month() + 1);
                current.assign(constants_1.YEAR, targetMoment.year());
            } else if (match[this.DAY_GROUP_3]) {
                var day3 = match[this.DAY_GROUP_3];
                if (day3 === '明' || day3 === '聽') {
                    targetMoment.add(1, 'day');
                } else if (day3 === '昨' || day3 === '尋' || day3 === '琴') {
                    targetMoment.add(-1, 'day');
                }
                current.assign(constants_1.DAY, targetMoment.date());
                current.assign(constants_1.MONTH, targetMoment.month() + 1);
                current.assign(constants_1.YEAR, targetMoment.year());
            } else {
                current.imply(constants_1.DAY, targetMoment.date());
                current.imply(constants_1.MONTH, targetMoment.month() + 1);
                current.imply(constants_1.YEAR, targetMoment.year());
            }
        }
    }, {
        key: "getMeridiem",
        value: function getMeridiem(match, meridiem, hour) {
            // ----- AM & PM
            if (match[this.AM_PM_HOUR_GROUP]) {
                if (hour > 12) return null;
                var ampm = match[this.AM_PM_HOUR_GROUP][0].toLowerCase();
                if (ampm === 'a') {
                    meridiem = 0;
                    if (hour === 12) hour = 0;
                } else if (ampm === 'p') {
                    meridiem = 1;
                    if (hour !== 12) hour += 12;
                }
            } else if (match[this.ZH_AM_PM_HOUR_GROUP_1]) {
                var _ampm = match[this.ZH_AM_PM_HOUR_GROUP_1][0];
                if (_ampm === '朝' || _ampm === '早') {
                    meridiem = 0;
                    if (hour === 12) hour = 0;
                } else if (_ampm === '晚') {
                    meridiem = 1;
                    if (hour !== 12) hour += 12;
                }
            } else if (match[this.ZH_AM_PM_HOUR_GROUP_2]) {
                var _ampm2 = match[this.ZH_AM_PM_HOUR_GROUP_2][0];
                if (_ampm2 === '上' || _ampm2 === '朝' || _ampm2 === '早' || _ampm2 === '凌') {
                    meridiem = 0;
                    if (hour === 12) hour = 0;
                } else if (_ampm2 === '下' || _ampm2 === '晏' || _ampm2 === '晚') {
                    meridiem = 1;
                    if (hour !== 12) hour += 12;
                }
            } else if (match[this.ZH_AM_PM_HOUR_GROUP_3]) {
                var _ampm3 = match[this.ZH_AM_PM_HOUR_GROUP_3][0];
                if (_ampm3 === '上' || _ampm3 === '朝' || _ampm3 === '早' || _ampm3 === '凌') {
                    meridiem = 0;
                    if (hour === 12) hour = 0;
                } else if (_ampm3 === '下' || _ampm3 === '晏' || _ampm3 === '晚') {
                    meridiem = 1;
                    if (hour !== 12) hour += 12;
                }
            }
            return [meridiem, hour];
        }
    }]);

    return ZHHantTimeExpressionParser;
}(parser_1.default);

exports.default = ZHHantTimeExpressionParser;

},{"../../constants":4,"../../result":66,"../../utils/ZH-Hant":72,"../parser":51,"moment":2}],50:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var parser_1 = require("../parser");
var result_1 = require("../../result");
var ZH_Hant_1 = require("../../utils/ZH-Hant");
var general_1 = require("../../utils/general");

var ZHHantWeekdayParser = function (_parser_1$default) {
    _inherits(ZHHantWeekdayParser, _parser_1$default);

    function ZHHantWeekdayParser() {
        _classCallCheck(this, ZHHantWeekdayParser);

        var _this = _possibleConstructorReturn(this, (ZHHantWeekdayParser.__proto__ || Object.getPrototypeOf(ZHHantWeekdayParser)).apply(this, arguments));

        _this.PATTERN = new RegExp('(上|今|下|這|呢)?' + '(?:個)?' + '(?:星期|禮拜)' + '(' + Object.keys(ZH_Hant_1.WEEKDAY_OFFSET).join('|') + ')');
        _this.PREFIX_GROUP = 1;
        _this.WEEKDAY_GROUP = 2;
        _this.TAG = 'ZHWeekdayParser';
        return _this;
    }

    _createClass(ZHHantWeekdayParser, [{
        key: "pattern",
        value: function pattern() {
            return this.PATTERN;
        }
    }, {
        key: "extract",
        value: function extract(text, ref, match, opt) {
            var index = match.index;
            var matchedText = match[0];
            var result = new result_1.ParsedResult({
                text: matchedText,
                index: index,
                ref: ref
            });
            var offset = ZH_Hant_1.WEEKDAY_OFFSET[(match[this.WEEKDAY_GROUP] || '').toLowerCase()];
            if (offset === undefined) return null;
            var norm = (match[this.PREFIX_GROUP] || '').toLowerCase();
            var modifier = general_1.Modifier.UNKNOWN;
            if (norm == '今' || norm == '這' || norm == '呢') {
                modifier = general_1.Modifier.THIS;
            } else if (norm === '上') {
                modifier = general_1.Modifier.LAST;
            } else if (norm == '下') {
                modifier = general_1.Modifier.NEXT;
            }
            result.tags[this.TAG] = true;
            general_1.updateParsedComponent(result, ref, offset, modifier);
            return result;
        }
    }]);

    return ZHHantWeekdayParser;
}(parser_1.default);

exports.default = ZHHantWeekdayParser;

},{"../../result":66,"../../utils/ZH-Hant":72,"../../utils/general":73,"../parser":51}],51:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });

var Parser = function () {
    function Parser() {
        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, Parser);

        this.strictMode = !!config.strict;
    }

    _createClass(Parser, [{
        key: "isStrictMode",
        value: function isStrictMode() {
            return this.strictMode;
        }
    }, {
        key: "execute",
        value: function execute(text, ref, opt) {
            var results = [];
            var regex = this.pattern();
            var remainingText = text;
            var match = regex.exec(remainingText);
            while (match) {
                // Calculate match index on the full text;
                match.index += text.length - remainingText.length;
                var result = this.extract(text, ref, match, opt);
                if (result) {
                    // If success, start from the end of the result
                    remainingText = text.substring(result.index + result.text.length);
                    if (!this.isStrictMode() || result.hasPossibleDates()) {
                        results.push(result);
                    }
                } else {
                    // If fail, move on by 1 - This should rarely, if ever happen (we matched but couldn't create a result from it)
                    remainingText = text.substring(match.index + 1);
                }
                match = regex.exec(remainingText);
            }
            return results;
        }
    }]);

    return Parser;
}();

exports.default = Parser;
var ENISOFormatParser_1 = require("./EN/ENISOFormatParser");
exports.ENISOFormatParser = ENISOFormatParser_1.default;
var ENDeadlineFormatParser_1 = require("./EN/ENDeadlineFormatParser");
exports.ENDeadlineFormatParser = ENDeadlineFormatParser_1.default;
var ENRelativeDateFormatParser_1 = require("./EN/ENRelativeDateFormatParser");
exports.ENRelativeDateFormatParser = ENRelativeDateFormatParser_1.default;
var ENMonthNameLittleEndianParser_1 = require("./EN/ENMonthNameLittleEndianParser");
exports.ENMonthNameLittleEndianParser = ENMonthNameLittleEndianParser_1.default;
var ENMonthNameMiddleEndianParser_1 = require("./EN/ENMonthNameMiddleEndianParser");
exports.ENMonthNameMiddleEndianParser = ENMonthNameMiddleEndianParser_1.default;
var ENMonthNameParser_1 = require("./EN/ENMonthNameParser");
exports.ENMonthNameParser = ENMonthNameParser_1.default;
var ENSlashDateFormatParser_1 = require("./EN/ENSlashDateFormatParser");
exports.ENSlashDateFormatParser = ENSlashDateFormatParser_1.default;
var ENSlashDateFormatStartWithYearParser_1 = require("./EN/ENSlashDateFormatStartWithYearParser");
exports.ENSlashDateFormatStartWithYearParser = ENSlashDateFormatStartWithYearParser_1.default;
var ENSlashMonthFormatParser_1 = require("./EN/ENSlashMonthFormatParser");
exports.ENSlashMonthFormatParser = ENSlashMonthFormatParser_1.default;
var ENTimeAgoFormatParser_1 = require("./EN/ENTimeAgoFormatParser");
exports.ENTimeAgoFormatParser = ENTimeAgoFormatParser_1.default;
var ENTimeExpressionParser_1 = require("./EN/ENTimeExpressionParser");
exports.ENTimeExpressionParser = ENTimeExpressionParser_1.default;
var ENTimeLaterFormatParser_1 = require("./EN/ENTimeLaterFormatParser");
exports.ENTimeLaterFormatParser = ENTimeLaterFormatParser_1.default;
var ENWeekdayParser_1 = require("./EN/ENWeekdayParser");
exports.ENWeekdayParser = ENWeekdayParser_1.default;
var ENCasualDateParser_1 = require("./EN/ENCasualDateParser");
exports.ENCasualDateParser = ENCasualDateParser_1.default;
var ENCasualTimeParser_1 = require("./EN/ENCasualTimeParser");
exports.ENCasualTimeParser = ENCasualTimeParser_1.default;
var JPStandardParser_1 = require("./JP/JPStandardParser");
exports.JPStandardParser = JPStandardParser_1.default;
var JPCasualDateParser_1 = require("./JP/JPCasualDateParser");
exports.JPCasualDateParser = JPCasualDateParser_1.default;
var ESCasualDateParser_1 = require("./ES/ESCasualDateParser");
exports.ESCasualDateParser = ESCasualDateParser_1.default;
var ESDeadlineFormatParser_1 = require("./ES/ESDeadlineFormatParser");
exports.ESDeadlineFormatParser = ESDeadlineFormatParser_1.default;
var ESTimeAgoFormatParser_1 = require("./ES/ESTimeAgoFormatParser");
exports.ESTimeAgoFormatParser = ESTimeAgoFormatParser_1.default;
var ESTimeExpressionParser_1 = require("./ES/ESTimeExpressionParser");
exports.ESTimeExpressionParser = ESTimeExpressionParser_1.default;
var ESWeekdayParser_1 = require("./ES/ESWeekdayParser");
exports.ESWeekdayParser = ESWeekdayParser_1.default;
var ESMonthNameLittleEndianParser_1 = require("./ES/ESMonthNameLittleEndianParser");
exports.ESMonthNameLittleEndianParser = ESMonthNameLittleEndianParser_1.default;
var ESSlashDateFormatParser_1 = require("./ES/ESSlashDateFormatParser");
exports.ESSlashDateFormatParser = ESSlashDateFormatParser_1.default;
var FRCasualDateParser_1 = require("./FR/FRCasualDateParser");
exports.FRCasualDateParser = FRCasualDateParser_1.default;
var FRDeadlineFormatParser_1 = require("./FR/FRDeadlineFormatParser");
exports.FRDeadlineFormatParser = FRDeadlineFormatParser_1.default;
var FRMonthNameLittleEndianParser_1 = require("./FR/FRMonthNameLittleEndianParser");
exports.FRMonthNameLittleEndianParser = FRMonthNameLittleEndianParser_1.default;
var FRSlashDateFormatParser_1 = require("./FR/FRSlashDateFormatParser");
exports.FRSlashDateFormatParser = FRSlashDateFormatParser_1.default;
var FRTimeAgoFormatParser_1 = require("./FR/FRTimeAgoFormatParser");
exports.FRTimeAgoFormatParser = FRTimeAgoFormatParser_1.default;
var FRTimeExpressionParser_1 = require("./FR/FRTimeExpressionParser");
exports.FRTimeExpressionParser = FRTimeExpressionParser_1.default;
var FRWeekdayParser_1 = require("./FR/FRWeekdayParser");
exports.FRWeekdayParser = FRWeekdayParser_1.default;
var FRRelativeDateFormatParser_1 = require("./FR/FRRelativeDateFormatParser");
exports.FRRelativeDateFormatParser = FRRelativeDateFormatParser_1.default;
var ZHHantDateParser_1 = require("./ZH-Hant/ZHHantDateParser");
exports.ZHHantDateParser = ZHHantDateParser_1.default;
var ZHHantWeekdayParser_1 = require("./ZH-Hant/ZHHantWeekdayParser");
exports.ZHHantWeekdayParser = ZHHantWeekdayParser_1.default;
var ZHHantTimeExpressionParser_1 = require("./ZH-Hant/ZHHantTimeExpressionParser");
exports.ZHHantTimeExpressionParser = ZHHantTimeExpressionParser_1.default;
var ZHHantCasualDateParser_1 = require("./ZH-Hant/ZHHantCasualDateParser");
exports.ZHHantCasualDateParser = ZHHantCasualDateParser_1.default;
var ZHHantDeadlineFormatParser_1 = require("./ZH-Hant/ZHHantDeadlineFormatParser");
exports.ZHHantDeadlineFormatParser = ZHHantDeadlineFormatParser_1.default;
var DEDeadlineFormatParser_1 = require("./DE/DEDeadlineFormatParser");
exports.DEDeadlineFormatParser = DEDeadlineFormatParser_1.default;
var DEMonthNameLittleEndianParser_1 = require("./DE/DEMonthNameLittleEndianParser");
exports.DEMonthNameLittleEndianParser = DEMonthNameLittleEndianParser_1.default;
var DEMonthNameParser_1 = require("./DE/DEMonthNameParser");
exports.DEMonthNameParser = DEMonthNameParser_1.default;
var DESlashDateFormatParser_1 = require("./DE/DESlashDateFormatParser");
exports.DESlashDateFormatParser = DESlashDateFormatParser_1.default;
var DETimeAgoFormatParser_1 = require("./DE/DETimeAgoFormatParser");
exports.DETimeAgoFormatParser = DETimeAgoFormatParser_1.default;
var DETimeExpressionParser_1 = require("./DE/DETimeExpressionParser");
exports.DETimeExpressionParser = DETimeExpressionParser_1.default;
var DEWeekdayParser_1 = require("./DE/DEWeekdayParser");
exports.DEWeekdayParser = DEWeekdayParser_1.default;
var DECasualDateParser_1 = require("./DE/DECasualDateParser");
exports.DECasualDateParser = DECasualDateParser_1.default;

},{"./DE/DECasualDateParser":6,"./DE/DEDeadlineFormatParser":7,"./DE/DEMonthNameLittleEndianParser":8,"./DE/DEMonthNameParser":9,"./DE/DESlashDateFormatParser":10,"./DE/DETimeAgoFormatParser":11,"./DE/DETimeExpressionParser":12,"./DE/DEWeekdayParser":13,"./EN/ENCasualDateParser":14,"./EN/ENCasualTimeParser":15,"./EN/ENDeadlineFormatParser":16,"./EN/ENISOFormatParser":17,"./EN/ENMonthNameLittleEndianParser":18,"./EN/ENMonthNameMiddleEndianParser":19,"./EN/ENMonthNameParser":20,"./EN/ENRelativeDateFormatParser":21,"./EN/ENSlashDateFormatParser":22,"./EN/ENSlashDateFormatStartWithYearParser":23,"./EN/ENSlashMonthFormatParser":24,"./EN/ENTimeAgoFormatParser":25,"./EN/ENTimeExpressionParser":26,"./EN/ENTimeLaterFormatParser":27,"./EN/ENWeekdayParser":28,"./ES/ESCasualDateParser":29,"./ES/ESDeadlineFormatParser":30,"./ES/ESMonthNameLittleEndianParser":31,"./ES/ESSlashDateFormatParser":32,"./ES/ESTimeAgoFormatParser":33,"./ES/ESTimeExpressionParser":34,"./ES/ESWeekdayParser":35,"./FR/FRCasualDateParser":36,"./FR/FRDeadlineFormatParser":37,"./FR/FRMonthNameLittleEndianParser":38,"./FR/FRRelativeDateFormatParser":39,"./FR/FRSlashDateFormatParser":40,"./FR/FRTimeAgoFormatParser":41,"./FR/FRTimeExpressionParser":42,"./FR/FRWeekdayParser":43,"./JP/JPCasualDateParser":44,"./JP/JPStandardParser":45,"./ZH-Hant/ZHHantCasualDateParser":46,"./ZH-Hant/ZHHantDateParser":47,"./ZH-Hant/ZHHantDeadlineFormatParser":48,"./ZH-Hant/ZHHantTimeExpressionParser":49,"./ZH-Hant/ZHHantWeekdayParser":50}],52:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var ENMergeDateRangeRefiner_1 = require("../EN/ENMergeDateRangeRefiner");

var DEMergeDateRangeRefiner = function (_ENMergeDateRangeRefi) {
    _inherits(DEMergeDateRangeRefiner, _ENMergeDateRangeRefi);

    function DEMergeDateRangeRefiner() {
        _classCallCheck(this, DEMergeDateRangeRefiner);

        var _this = _possibleConstructorReturn(this, (DEMergeDateRangeRefiner.__proto__ || Object.getPrototypeOf(DEMergeDateRangeRefiner)).apply(this, arguments));

        _this.PATTERN = /^\s*(bis(?:\s*(?:am|zum))?|\-)\s*$/i;
        _this.TAG = 'DEMergeDateRangeRefiner';
        return _this;
    }

    return DEMergeDateRangeRefiner;
}(ENMergeDateRangeRefiner_1.MergeDateRangeRefiner);

exports.default = DEMergeDateRangeRefiner;

},{"../EN/ENMergeDateRangeRefiner":54}],53:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var ENMergeDateTimeRefiner_1 = require("../EN/ENMergeDateTimeRefiner");

var DEMergeDateTimeRefiner = function (_ENMergeDateTimeRefin) {
    _inherits(DEMergeDateTimeRefiner, _ENMergeDateTimeRefin);

    function DEMergeDateTimeRefiner() {
        _classCallCheck(this, DEMergeDateTimeRefiner);

        var _this = _possibleConstructorReturn(this, (DEMergeDateTimeRefiner.__proto__ || Object.getPrototypeOf(DEMergeDateTimeRefiner)).apply(this, arguments));

        _this.TAG = 'DEMergeDateTimeRefiner';
        _this.PATTERN = new RegExp("^\\s*(T|um|am|,|-)?\\s*$");
        return _this;
    }

    return DEMergeDateTimeRefiner;
}(ENMergeDateTimeRefiner_1.MergeDateTimeRefiner);

exports.default = DEMergeDateTimeRefiner;

},{"../EN/ENMergeDateTimeRefiner":55}],54:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var refiner_1 = require("../refiner");
var constants_1 = require("../../constants");

var MergeDateRangeRefiner = function (_refiner_1$default) {
    _inherits(MergeDateRangeRefiner, _refiner_1$default);

    function MergeDateRangeRefiner() {
        _classCallCheck(this, MergeDateRangeRefiner);

        return _possibleConstructorReturn(this, (MergeDateRangeRefiner.__proto__ || Object.getPrototypeOf(MergeDateRangeRefiner)).apply(this, arguments));
    }

    _createClass(MergeDateRangeRefiner, [{
        key: "refine",
        value: function refine(text, results, opt) {
            if (results.length < 2) {
                return results;
            }
            var mergedResult = [];
            var currResult = null;
            var prevResult = null;
            for (var i = 1; i < results.length; i++) {
                currResult = results[i];
                prevResult = results[i - 1];
                if (!prevResult.end && !currResult.end && this.isAbleToMerge(text, prevResult, currResult)) {
                    prevResult = this.mergeResult(text, prevResult, currResult);
                    currResult = null;
                    i += 1;
                }
                mergedResult.push(prevResult);
            }
            if (currResult != null) {
                mergedResult.push(currResult);
            }
            return mergedResult;
        }
    }, {
        key: "isAbleToMerge",
        value: function isAbleToMerge(text, result1, result2) {
            return !!text.substring(result1.index + result1.text.length, result2.index).match(this.PATTERN);
        }
    }, {
        key: "isWeekdayResult",

        // noinspection JSMethodCanBeStatic
        value: function isWeekdayResult(result) {
            return result.start.isCertain(constants_1.WEEKDAY) && !result.start.isCertain(constants_1.DAY);
        }
    }, {
        key: "mergeResult",
        value: function mergeResult(text, fromResult, toResult) {
            if (!this.isWeekdayResult(fromResult) && !this.isWeekdayResult(toResult)) {
                this.mergeValues(toResult.start, fromResult.start);
                this.mergeValues(fromResult.start, toResult.start);
            }
            if (fromResult.start.date().getTime() > toResult.start.date().getTime()) {
                var fromMoment = fromResult.start.moment();
                var toMoment = toResult.start.moment();
                if (this.isWeekdayResult(fromResult) && fromMoment.clone().add(-7, 'days').isBefore(toMoment)) {
                    fromMoment.add(-7, 'days');
                    fromResult.start.imply(constants_1.DAY, fromMoment.date());
                    fromResult.start.imply(constants_1.MONTH, fromMoment.month() + 1);
                    fromResult.start.imply(constants_1.YEAR, fromMoment.year());
                } else if (this.isWeekdayResult(toResult) && toMoment.clone().add(7, 'days').isAfter(fromMoment)) {
                    toMoment.add(7, 'days');
                    toResult.start.imply(constants_1.DAY, toMoment.date());
                    toResult.start.imply(constants_1.MONTH, toMoment.month() + 1);
                    toResult.start.imply(constants_1.YEAR, toMoment.year());
                } else {
                    var _ref = [fromResult, toResult];
                    toResult = _ref[0];
                    fromResult = _ref[1];
                }
            }
            fromResult.end = toResult.start;
            Object.keys(toResult.tags).forEach(function (tag) {
                return fromResult.tags[tag] = true;
            });
            var startIndex = Math.min(fromResult.index, toResult.index);
            var endIndex = Math.max(fromResult.index + fromResult.text.length, toResult.index + toResult.text.length);
            fromResult.index = startIndex;
            fromResult.text = text.substring(startIndex, endIndex);
            fromResult.tags[this.TAG] = true;
            return fromResult;
        }
    }, {
        key: "mergeValues",
        value: function mergeValues(from, to) {
            Object.keys(from.knownValues).forEach(function (key) {
                if (!to.isCertain(key)) {
                    to.assign(key, from.get(key));
                }
            });
        }
    }]);

    return MergeDateRangeRefiner;
}(refiner_1.default);

exports.MergeDateRangeRefiner = MergeDateRangeRefiner;

var ENMergeDateRangeRefiner = function (_MergeDateRangeRefine) {
    _inherits(ENMergeDateRangeRefiner, _MergeDateRangeRefine);

    function ENMergeDateRangeRefiner() {
        _classCallCheck(this, ENMergeDateRangeRefiner);

        var _this2 = _possibleConstructorReturn(this, (ENMergeDateRangeRefiner.__proto__ || Object.getPrototypeOf(ENMergeDateRangeRefiner)).apply(this, arguments));

        _this2.TAG = 'ENMergeDateRangeRefiner';
        _this2.PATTERN = /^\s*(to|-|ー)\s*$/i;
        return _this2;
    }

    return ENMergeDateRangeRefiner;
}(MergeDateRangeRefiner);

exports.default = ENMergeDateRangeRefiner;

},{"../../constants":4,"../refiner":65}],55:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var refiner_1 = require("../refiner");
var constants_1 = require("../../constants");

var MergeDateTimeRefiner = function (_refiner_1$default) {
    _inherits(MergeDateTimeRefiner, _refiner_1$default);

    function MergeDateTimeRefiner() {
        _classCallCheck(this, MergeDateTimeRefiner);

        return _possibleConstructorReturn(this, (MergeDateTimeRefiner.__proto__ || Object.getPrototypeOf(MergeDateTimeRefiner)).apply(this, arguments));
    }

    _createClass(MergeDateTimeRefiner, [{
        key: "refine",
        value: function refine(text, results, opt) {
            if (results.length < 2) {
                return results;
            }
            var mergedResult = [];
            var currResult = null;
            var prevResult = null;
            for (var i = 1; i < results.length; i++) {
                currResult = results[i];
                prevResult = results[i - 1];
                if (MergeDateTimeRefiner.isDateOnly(prevResult) && MergeDateTimeRefiner.isTimeOnly(currResult) && this.isAbleToMerge(text, prevResult, currResult)) {
                    prevResult = this.mergeResult(text, prevResult, currResult);
                    currResult = results[i + 1] || null;
                    i += 1;
                } else if (MergeDateTimeRefiner.isDateOnly(currResult) && MergeDateTimeRefiner.isTimeOnly(prevResult) && this.isAbleToMerge(text, prevResult, currResult)) {
                    prevResult = this.mergeResult(text, currResult, prevResult);
                    currResult = results[i + 1] || null;
                    i += 1;
                }
                if (prevResult) {
                    mergedResult.push(prevResult);
                }
            }
            if (currResult !== null) {
                mergedResult.push(currResult);
            }
            return mergedResult;
        }
    }, {
        key: "isAbleToMerge",
        value: function isAbleToMerge(text, result1, result2) {
            return !!text.substring(result1.index + result1.text.length, result2.index).match(this.PATTERN);
        }
    }, {
        key: "mergeResult",
        value: function mergeResult(text, dateResult, timeResult) {
            var beginDate = dateResult.start;
            var beginTime = timeResult.start;
            var beginDateTime = MergeDateTimeRefiner.mergeDateTimeValues(beginDate, beginTime);
            if (dateResult.end || timeResult.end) {
                var endDate = dateResult.end ? dateResult.end : dateResult.start;
                var endTime = timeResult.end ? timeResult.end : timeResult.start;
                var endDateTime = MergeDateTimeRefiner.mergeDateTimeValues(endDate, endTime);
                if (!dateResult.end && endDateTime.date().getTime() < beginDateTime.date().getTime()) {
                    // Ex. 9pm - 1am
                    if (endDateTime.isCertain(constants_1.DAY)) {
                        endDateTime.assign(constants_1.DAY, endDateTime.get(constants_1.DAY) + 1);
                    } else {
                        endDateTime.imply(constants_1.DAY, endDateTime.get(constants_1.DAY) + 1);
                    }
                }
                dateResult.end = endDateTime;
            }
            dateResult.start = beginDateTime;
            var startIndex = Math.min(dateResult.index, timeResult.index);
            var endIndex = Math.max(dateResult.index + dateResult.text.length, timeResult.index + timeResult.text.length);
            dateResult.index = startIndex;
            dateResult.text = text.substring(startIndex, endIndex);
            Object.keys(timeResult.tags).forEach(function (tag) {
                return dateResult.tags[tag] = true;
            });
            dateResult.tags[this.TAG] = true;
            return dateResult;
        }
    }], [{
        key: "isDateOnly",
        value: function isDateOnly(result) {
            return !result.start.isCertain(constants_1.HOUR);
        }
    }, {
        key: "isTimeOnly",
        value: function isTimeOnly(result) {
            return !result.start.isCertain(constants_1.MONTH) && !result.start.isCertain(constants_1.WEEKDAY);
        }
    }, {
        key: "mergeDateTimeValues",
        value: function mergeDateTimeValues(dateComponent, timeComponent) {
            var dateTimeComponent = dateComponent.clone();
            if (timeComponent.isCertain(constants_1.HOUR)) {
                dateTimeComponent.assign(constants_1.HOUR, timeComponent.get(constants_1.HOUR));
                dateTimeComponent.assign(constants_1.MINUTE, timeComponent.get(constants_1.MINUTE));
                if (timeComponent.isCertain(constants_1.SECOND)) {
                    dateTimeComponent.assign(constants_1.SECOND, timeComponent.get(constants_1.SECOND));
                    if (timeComponent.isCertain(constants_1.MILLISECOND)) {
                        dateTimeComponent.assign(constants_1.MILLISECOND, timeComponent.get(constants_1.MILLISECOND));
                    } else {
                        dateTimeComponent.imply(constants_1.MILLISECOND, timeComponent.get(constants_1.MILLISECOND));
                    }
                } else {
                    dateTimeComponent.imply(constants_1.SECOND, timeComponent.get(constants_1.SECOND));
                    dateTimeComponent.imply(constants_1.MILLISECOND, timeComponent.get(constants_1.MILLISECOND));
                }
            } else {
                dateTimeComponent.imply(constants_1.HOUR, timeComponent.get(constants_1.HOUR));
                dateTimeComponent.imply(constants_1.MINUTE, timeComponent.get(constants_1.MINUTE));
                dateTimeComponent.imply(constants_1.SECOND, timeComponent.get(constants_1.SECOND));
                dateTimeComponent.imply(constants_1.MILLISECOND, timeComponent.get(constants_1.MILLISECOND));
            }
            if (timeComponent.isCertain(constants_1.MERIDIEM)) {
                dateTimeComponent.assign(constants_1.MERIDIEM, timeComponent.get(constants_1.MERIDIEM));
            } else if (timeComponent.get(constants_1.MERIDIEM, -1) !== -1 && dateTimeComponent.get(constants_1.MERIDIEM, -1) === -1) {
                dateTimeComponent.imply(constants_1.MERIDIEM, timeComponent.get(constants_1.MERIDIEM));
            }
            if (dateTimeComponent.get(constants_1.MERIDIEM) === 1 && dateTimeComponent.get(constants_1.HOUR) < 12) {
                if (timeComponent.isCertain(constants_1.HOUR)) {
                    dateTimeComponent.assign(constants_1.HOUR, dateTimeComponent.get(constants_1.HOUR) + 12);
                } else {
                    dateTimeComponent.imply(constants_1.HOUR, dateTimeComponent.get(constants_1.HOUR) + 12);
                }
            }
            return dateTimeComponent;
        }
    }]);

    return MergeDateTimeRefiner;
}(refiner_1.default);

exports.MergeDateTimeRefiner = MergeDateTimeRefiner;

var ENMergeDateTimeRefiner = function (_MergeDateTimeRefiner) {
    _inherits(ENMergeDateTimeRefiner, _MergeDateTimeRefiner);

    function ENMergeDateTimeRefiner() {
        _classCallCheck(this, ENMergeDateTimeRefiner);

        var _this2 = _possibleConstructorReturn(this, (ENMergeDateTimeRefiner.__proto__ || Object.getPrototypeOf(ENMergeDateTimeRefiner)).apply(this, arguments));

        _this2.TAG = 'ENMergeDateTimeRefiner';
        _this2.PATTERN = new RegExp("^\\s*(T|at|after|before|on|of|,|-)?\\s*$");
        return _this2;
    }

    return ENMergeDateTimeRefiner;
}(MergeDateTimeRefiner);

exports.default = ENMergeDateTimeRefiner;

},{"../../constants":4,"../refiner":65}],56:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var refiner_1 = require("../refiner");
var constants_1 = require("../../constants");

var ENPrioritizeSpecificDateRefiner = function (_refiner_1$default) {
    _inherits(ENPrioritizeSpecificDateRefiner, _refiner_1$default);

    function ENPrioritizeSpecificDateRefiner() {
        _classCallCheck(this, ENPrioritizeSpecificDateRefiner);

        var _this = _possibleConstructorReturn(this, (ENPrioritizeSpecificDateRefiner.__proto__ || Object.getPrototypeOf(ENPrioritizeSpecificDateRefiner)).apply(this, arguments));

        _this.TAG = 'ENPrioritizeSpecificDateRefiner';
        _this.PATTERN = new RegExp("^\\s*(at|after|before|on|,|-|\\(|\\))?\\s*$");
        return _this;
    }

    _createClass(ENPrioritizeSpecificDateRefiner, [{
        key: "refine",
        value: function refine(text, results, opt) {
            if (results.length < 2) {
                return results;
            }
            var mergedResult = [];
            var currResult = null;
            var prevResult = null;
            for (var i = 1; i < results.length; i++) {
                currResult = results[i];
                prevResult = results[i - 1];
                if (this.isMoreSpecific(prevResult, currResult) && this.isAbleToMerge(text, prevResult, currResult)) {
                    prevResult = this.mergeResult(text, prevResult, currResult);
                    currResult = null;
                    i += 1;
                } else if (this.isMoreSpecific(currResult, prevResult) && this.isAbleToMerge(text, prevResult, currResult)) {
                    prevResult = this.mergeResult(text, currResult, prevResult);
                    currResult = null;
                    i += 1;
                }
                if (prevResult) {
                    mergedResult.push(prevResult);
                }
            }
            if (currResult !== null) {
                mergedResult.push(currResult);
            }
            return mergedResult;
        }
        // noinspection JSMethodCanBeStatic

    }, {
        key: "isMoreSpecific",
        value: function isMoreSpecific(prevResult, currResult) {
            if (prevResult.start.isCertain(constants_1.YEAR)) {
                if (!currResult.start.isCertain(constants_1.YEAR)) {
                    return true;
                } else {
                    if (prevResult.start.isCertain(constants_1.MONTH)) {
                        if (!currResult.start.isCertain(constants_1.MONTH)) {
                            return true;
                        } else {
                            if (prevResult.start.isCertain(constants_1.DAY) && !currResult.start.isCertain(constants_1.DAY)) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }
    }, {
        key: "isAbleToMerge",
        value: function isAbleToMerge(text, prevResult, currResult) {
            var textBetween = text.substring(prevResult.index + prevResult.text.length, currResult.index);
            // Only accepts merge if one of them comes from casual relative date
            var includesRelativeResult = prevResult.tags['ENRelativeDateFormatParser'] || currResult.tags['ENRelativeDateFormatParser'];
            // We assume they refer to the same date if all date fields are implied
            var referToSameDate = !prevResult.start.isCertain(constants_1.DAY) && !prevResult.start.isCertain(constants_1.MONTH) && !prevResult.start.isCertain(constants_1.YEAR);
            // If both years are certain, that determines if they refer to the same date
            // but with one more specific than the other
            if (prevResult.start.isCertain(constants_1.YEAR) && currResult.start.isCertain(constants_1.YEAR)) referToSameDate = prevResult.start.get(constants_1.YEAR) === currResult.start.get(constants_1.YEAR);
            // We now test with the next level (month) if they refer to the same date
            if (prevResult.start.isCertain(constants_1.MONTH) && currResult.start.isCertain(constants_1.MONTH)) referToSameDate = prevResult.start.get(constants_1.MONTH) === currResult.start.get(constants_1.MONTH) && referToSameDate;
            return includesRelativeResult && !!textBetween.match(this.PATTERN) && referToSameDate;
        }
    }, {
        key: "mergeResult",
        value: function mergeResult(text, specificResult, nonSpecificResult) {
            var startIndex = Math.min(specificResult.index, nonSpecificResult.index);
            var endIndex = Math.max(specificResult.index + specificResult.text.length, nonSpecificResult.index + nonSpecificResult.text.length);
            specificResult.index = startIndex;
            specificResult.text = text.substring(startIndex, endIndex);
            Object.keys(nonSpecificResult.tags).forEach(function (tag) {
                return specificResult.tags[tag] = true;
            });
            specificResult.tags[this.TAG] = true;
            return specificResult;
        }
    }]);

    return ENPrioritizeSpecificDateRefiner;
}(refiner_1.default);

exports.default = ENPrioritizeSpecificDateRefiner;

},{"../../constants":4,"../refiner":65}],57:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var refiner_1 = require("./refiner");
var constants_1 = require("../constants");

var ExtractTimezoneAbbrRefiner = function (_refiner_1$default) {
    _inherits(ExtractTimezoneAbbrRefiner, _refiner_1$default);

    function ExtractTimezoneAbbrRefiner() {
        _classCallCheck(this, ExtractTimezoneAbbrRefiner);

        var _this = _possibleConstructorReturn(this, (ExtractTimezoneAbbrRefiner.__proto__ || Object.getPrototypeOf(ExtractTimezoneAbbrRefiner)).apply(this, arguments));

        _this.TAG = 'ExtractTimezoneAbbrRefiner';
        _this.TIMEZONE_NAME_PATTERN = new RegExp("^\\s*\\(?([A-Z]{2,4})\\)?(?=\\W|$)", 'i');
        // TODO: Move this to some configuration
        _this.TIMEZONE_ABBR_MAP = { "ACDT": 630, "ACST": 570, "ADT": -180, "AEDT": 660, "AEST": 600, "AFT": 270, "AKDT": -480, "AKST": -540, "ALMT": 360, "AMST": -180, "AMT": -240, "ANAST": 720, "ANAT": 720, "AQTT": 300, "ART": -180, "AST": -240, "AWDT": 540, "AWST": 480, "AZOST": 0, "AZOT": -60, "AZST": 300, "AZT": 240, "BNT": 480, "BOT": -240, "BRST": -120, "BRT": -180, "BST": 60, "BTT": 360, "CAST": 480, "CAT": 120, "CCT": 390, "CDT": -300, "CEST": 120, "CET": 60, "CHADT": 825, "CHAST": 765, "CKT": -600, "CLST": -180, "CLT": -240, "COT": -300, "CST": -360, "CVT": -60, "CXT": 420, "ChST": 600, "DAVT": 420, "EASST": -300, "EAST": -360, "EAT": 180, "ECT": -300, "EDT": -240, "EEST": 180, "EET": 120, "EGST": 0, "EGT": -60, "EST": -300, "ET": -300, "FJST": 780, "FJT": 720, "FKST": -180, "FKT": -240, "FNT": -120, "GALT": -360, "GAMT": -540, "GET": 240, "GFT": -180, "GILT": 720, "GMT": 0, "GST": 240, "GYT": -240, "HAA": -180, "HAC": -300, "HADT": -540, "HAE": -240, "HAP": -420, "HAR": -360, "HAST": -600, "HAT": -90, "HAY": -480, "HKT": 480, "HLV": -210, "HNA": -240, "HNC": -360, "HNE": -300, "HNP": -480, "HNR": -420, "HNT": -150, "HNY": -540, "HOVT": 420, "ICT": 420, "IDT": 180, "IOT": 360, "IRDT": 270, "IRKST": 540, "IRKT": 540, "IRST": 210, "IST": 60, "JST": 540, "KGT": 360, "KRAST": 480, "KRAT": 480, "KST": 540, "KUYT": 240, "LHDT": 660, "LHST": 630, "LINT": 840, "MAGST": 720, "MAGT": 720, "MART": -510, "MAWT": 300, "MDT": -360, "MESZ": 120, "MEZ": 60, "MHT": 720, "MMT": 390, "MSD": 240, "MSK": 240, "MST": -420, "MUT": 240, "MVT": 300, "MYT": 480, "NCT": 660, "NDT": -90, "NFT": 690, "NOVST": 420, "NOVT": 360, "NPT": 345, "NST": -150, "NUT": -660, "NZDT": 780, "NZST": 720, "OMSST": 420, "OMST": 420, "PDT": -420, "PET": -300, "PETST": 720, "PETT": 720, "PGT": 600, "PHOT": 780, "PHT": 480, "PKT": 300, "PMDT": -120, "PMST": -180, "PONT": 660, "PST": -480, "PT": -480, "PWT": 540, "PYST": -180, "PYT": -240, "RET": 240, "SAMT": 240, "SAST": 120, "SBT": 660, "SCT": 240, "SGT": 480, "SRT": -180, "SST": -660, "TAHT": -600, "TFT": 300, "TJT": 300, "TKT": 780, "TLT": 540, "TMT": 300, "TVT": 720, "ULAT": 480, "UTC": 0, "UYST": -120, "UYT": -180, "UZT": 300, "VET": -210, "VLAST": 660, "VLAT": 660, "VUT": 660, "WAST": 120, "WAT": 60, "WEST": 60, "WESZ": 60, "WET": 0, "WEZ": 0, "WFT": 720, "WGST": -120, "WGT": -180, "WIB": 420, "WIT": 540, "WITA": 480, "WST": 780, "WT": 0, "YAKST": 600, "YAKT": 600, "YAPT": 600, "YEKST": 360, "YEKT": 360 };
        return _this;
    }

    _createClass(ExtractTimezoneAbbrRefiner, [{
        key: "refine",
        value: function refine(text, results, opt) {
            var _this2 = this;

            results.forEach(function (result) {
                if (!result.tags['ENTimeExpressionParser'] && !result.tags['ZHTimeExpressionParser'] && !result.tags['FRTimeExpressionParser'] && !result.tags['DETimeExpressionParser']) {
                    return;
                }
                var match = _this2.TIMEZONE_NAME_PATTERN.exec(text.substring(result.index + result.text.length));
                if (match) {
                    var timezoneAbbr = match[1].toUpperCase();
                    if (!_this2.TIMEZONE_ABBR_MAP.hasOwnProperty(timezoneAbbr)) {
                        return;
                    }
                    var timezoneOffset = _this2.TIMEZONE_ABBR_MAP[timezoneAbbr];
                    if (!result.start.isCertain(constants_1.TIMEZONE_OFFSET)) {
                        result.start.assign(constants_1.TIMEZONE_OFFSET, timezoneOffset);
                    }
                    if (result.end && !result.end.isCertain(constants_1.TIMEZONE_OFFSET)) {
                        result.end.assign(constants_1.TIMEZONE_OFFSET, timezoneOffset);
                    }
                    result.text += match[0];
                    result.tags[_this2.TAG] = true;
                }
            });
            return results;
        }
    }]);

    return ExtractTimezoneAbbrRefiner;
}(refiner_1.default);

exports.default = ExtractTimezoneAbbrRefiner;

},{"../constants":4,"./refiner":65}],58:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var refiner_1 = require("./refiner");
var constants_1 = require("../constants");

var ExtractTimezoneOffsetRefiner = function (_refiner_1$default) {
    _inherits(ExtractTimezoneOffsetRefiner, _refiner_1$default);

    function ExtractTimezoneOffsetRefiner() {
        _classCallCheck(this, ExtractTimezoneOffsetRefiner);

        var _this = _possibleConstructorReturn(this, (ExtractTimezoneOffsetRefiner.__proto__ || Object.getPrototypeOf(ExtractTimezoneOffsetRefiner)).apply(this, arguments));

        _this.TAG = 'ExtractTimezoneOffsetRefiner';
        _this.TIMEZONE_OFFSET_PATTERN = new RegExp("^\\s*(GMT|UTC)?(\\+|\\-)(\\d{1,2}):?(\\d{2})", 'i');
        _this.TIMEZONE_OFFSET_SIGN_GROUP = 2;
        _this.TIMEZONE_OFFSET_HOUR_OFFSET_GROUP = 3;
        _this.TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP = 4;
        return _this;
    }

    _createClass(ExtractTimezoneOffsetRefiner, [{
        key: "refine",
        value: function refine(text, results, opt) {
            var _this2 = this;

            results.forEach(function (result) {
                if (result.start.isCertain(constants_1.TIMEZONE_OFFSET)) {
                    return;
                }
                var match = _this2.TIMEZONE_OFFSET_PATTERN.exec(text.substring(result.index + result.text.length));
                if (!match) {
                    return;
                }
                var hourOffset = parseInt(match[_this2.TIMEZONE_OFFSET_HOUR_OFFSET_GROUP], 10);
                var minuteOffset = parseInt(match[_this2.TIMEZONE_OFFSET_MINUTE_OFFSET_GROUP], 10);
                var timezoneOffset = hourOffset * 60 + minuteOffset;
                if (match[_this2.TIMEZONE_OFFSET_SIGN_GROUP] === '-') {
                    timezoneOffset = -timezoneOffset;
                }
                if (result.end != null) {
                    result.end.assign(constants_1.TIMEZONE_OFFSET, timezoneOffset);
                }
                result.start.assign(constants_1.TIMEZONE_OFFSET, timezoneOffset);
                result.text += match[0];
                result.tags[_this2.TAG] = true;
            });
            return results;
        }
    }]);

    return ExtractTimezoneOffsetRefiner;
}(refiner_1.default);

exports.default = ExtractTimezoneOffsetRefiner;

},{"../constants":4,"./refiner":65}],59:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var ENMergeDateRangeRefiner_1 = require("../EN/ENMergeDateRangeRefiner");

var FRMergeDateRangeRefiner = function (_ENMergeDateRangeRefi) {
    _inherits(FRMergeDateRangeRefiner, _ENMergeDateRangeRefi);

    function FRMergeDateRangeRefiner() {
        _classCallCheck(this, FRMergeDateRangeRefiner);

        var _this = _possibleConstructorReturn(this, (FRMergeDateRangeRefiner.__proto__ || Object.getPrototypeOf(FRMergeDateRangeRefiner)).apply(this, arguments));

        _this.PATTERN = /^\s*([àa\-])\s*$/i;
        _this.TAG = 'FRMergeDateRangeRefiner';
        return _this;
    }

    return FRMergeDateRangeRefiner;
}(ENMergeDateRangeRefiner_1.MergeDateRangeRefiner);

exports.default = FRMergeDateRangeRefiner;

},{"../EN/ENMergeDateRangeRefiner":54}],60:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var ENMergeDateTimeRefiner_1 = require("../EN/ENMergeDateTimeRefiner");

var FRMergeDateTimeRefiner = function (_ENMergeDateTimeRefin) {
    _inherits(FRMergeDateTimeRefiner, _ENMergeDateTimeRefin);

    function FRMergeDateTimeRefiner() {
        _classCallCheck(this, FRMergeDateTimeRefiner);

        var _this = _possibleConstructorReturn(this, (FRMergeDateTimeRefiner.__proto__ || Object.getPrototypeOf(FRMergeDateTimeRefiner)).apply(this, arguments));

        _this.TAG = 'FRMergeDateTimeRefiner';
        _this.PATTERN = new RegExp("^\\s*(T|à|a|vers|de|,|-)?\\s*$");
        return _this;
    }

    return FRMergeDateTimeRefiner;
}(ENMergeDateTimeRefiner_1.MergeDateTimeRefiner);

exports.default = FRMergeDateTimeRefiner;

},{"../EN/ENMergeDateTimeRefiner":55}],61:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
/*
    Enforce 'forwardDate' option to on the results. When there are missing component,
    e.g. "March 12-13 (without year)" or "Thursday", the refiner will try to adjust the result
    into the future instead of the past.
*/
var refiner_1 = require("./refiner");
var constants_1 = require("../constants");
var moment = require("moment");

var ForwardDateRefiner = function (_refiner_1$default) {
    _inherits(ForwardDateRefiner, _refiner_1$default);

    function ForwardDateRefiner() {
        _classCallCheck(this, ForwardDateRefiner);

        var _this = _possibleConstructorReturn(this, (ForwardDateRefiner.__proto__ || Object.getPrototypeOf(ForwardDateRefiner)).apply(this, arguments));

        _this.TAG = 'ForwardDateRefiner';
        return _this;
    }

    _createClass(ForwardDateRefiner, [{
        key: "refine",
        value: function refine(text, results, opt) {
            var _this2 = this;

            if (!opt.forwardDate) {
                return results;
            }
            results.forEach(function (result) {
                var refMoment = moment(result.ref);
                // day and month are certain, but not year
                if (result.start.isCertain(constants_1.DAY) && result.start.isCertain(constants_1.MONTH) && !result.start.isCertain(constants_1.YEAR) && refMoment.isAfter(result.start.moment())) {
                    // Adjust year into the future
                    for (var i = 0; i < 3 && refMoment.isAfter(result.start.moment()); i++) {
                        result.start.imply(constants_1.YEAR, result.start.get(constants_1.YEAR) + 1);
                        if (result.end && !result.end.isCertain(constants_1.YEAR)) {
                            result.end.imply(constants_1.YEAR, result.end.get(constants_1.YEAR) + 1);
                        }
                    }
                    result.tags[_this2.TAG] = true;
                }
                // date is uncertain, but weekday is known
                if (!result.start.isCertain(constants_1.DAY) && !result.start.isCertain(constants_1.MONTH) && !result.start.isCertain(constants_1.YEAR) && result.start.isCertain(constants_1.WEEKDAY) && refMoment.isAfter(result.start.moment())) {
                    // Adjust date to the coming week
                    if (refMoment.day() > result.start.get(constants_1.WEEKDAY)) {
                        refMoment.day(result.start.get(constants_1.WEEKDAY) + 7);
                    } else {
                        refMoment.day(result.start.get(constants_1.WEEKDAY));
                    }
                    result.start.imply(constants_1.DAY, refMoment.date());
                    result.start.imply(constants_1.MONTH, refMoment.month() + 1);
                    result.start.imply(constants_1.YEAR, refMoment.year());
                    result.tags[_this2.TAG] = true;
                }
            });
            return results;
        }
    }]);

    return ForwardDateRefiner;
}(refiner_1.default);

exports.default = ForwardDateRefiner;

},{"../constants":4,"./refiner":65,"moment":2}],62:[function(require,module,exports){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var ENMergeDateTimeRefiner_1 = require("../EN/ENMergeDateTimeRefiner");

var JPMergeDateTimeRefiner = function (_ENMergeDateTimeRefin) {
    _inherits(JPMergeDateTimeRefiner, _ENMergeDateTimeRefin);

    function JPMergeDateTimeRefiner() {
        _classCallCheck(this, JPMergeDateTimeRefiner);

        var _this = _possibleConstructorReturn(this, (JPMergeDateTimeRefiner.__proto__ || Object.getPrototypeOf(JPMergeDateTimeRefiner)).apply(this, arguments));

        _this.TAG = 'JPMergeDateTimeRefiner';
        _this.PATTERN = /^\s*(から|ー)\s*$/i;
        return _this;
    }

    return JPMergeDateTimeRefiner;
}(ENMergeDateTimeRefiner_1.MergeDateTimeRefiner);

exports.default = JPMergeDateTimeRefiner;

},{"../EN/ENMergeDateTimeRefiner":55}],63:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var refiner_1 = require("./refiner");

var OverlapRemovalRefiner = function (_refiner_1$default) {
    _inherits(OverlapRemovalRefiner, _refiner_1$default);

    function OverlapRemovalRefiner() {
        _classCallCheck(this, OverlapRemovalRefiner);

        return _possibleConstructorReturn(this, (OverlapRemovalRefiner.__proto__ || Object.getPrototypeOf(OverlapRemovalRefiner)).apply(this, arguments));
    }

    _createClass(OverlapRemovalRefiner, [{
        key: "refine",
        value: function refine(text, results, opt) {
            if (results.length < 2) {
                return results;
            }
            var filteredResults = [];
            var prevResult = results[0];
            for (var i = 1; i < results.length; i++) {
                var result = results[i];
                // If overlap, compare the length and discard the shorter one
                if (result.index < prevResult.index + prevResult.text.length) {
                    if (result.text.length > prevResult.text.length) {
                        prevResult = result;
                    }
                } else {
                    filteredResults.push(prevResult);
                    prevResult = result;
                }
            }
            // The last one
            if (prevResult != null) {
                filteredResults.push(prevResult);
            }
            return filteredResults;
        }
    }]);

    return OverlapRemovalRefiner;
}(refiner_1.default);

exports.default = OverlapRemovalRefiner;

},{"./refiner":65}],64:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var refiner_1 = require("./refiner");

var UnlikelyFormatFilter = function (_refiner_1$Filter) {
    _inherits(UnlikelyFormatFilter, _refiner_1$Filter);

    function UnlikelyFormatFilter() {
        _classCallCheck(this, UnlikelyFormatFilter);

        var _this = _possibleConstructorReturn(this, (UnlikelyFormatFilter.__proto__ || Object.getPrototypeOf(UnlikelyFormatFilter)).apply(this, arguments));

        _this.REGEX = /^\d*(\.\d*)?$/;
        return _this;
    }

    _createClass(UnlikelyFormatFilter, [{
        key: "isValid",
        value: function isValid(text, result, opt) {
            return !result.text.replace(' ', '').match(this.REGEX);
        }
    }]);

    return UnlikelyFormatFilter;
}(refiner_1.Filter);

exports.default = UnlikelyFormatFilter;

},{"./refiner":65}],65:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });

var Refiner = function Refiner() {
    _classCallCheck(this, Refiner);
};

exports.default = Refiner;

var Filter = function (_Refiner) {
    _inherits(Filter, _Refiner);

    function Filter() {
        _classCallCheck(this, Filter);

        return _possibleConstructorReturn(this, (Filter.__proto__ || Object.getPrototypeOf(Filter)).apply(this, arguments));
    }

    _createClass(Filter, [{
        key: "refine",
        value: function refine(text, results, opt) {
            var _this2 = this;

            return results.filter(function (result) {
                return _this2.isValid(text, result, opt);
            });
        }
    }]);

    return Filter;
}(Refiner);

exports.Filter = Filter;
// Common refiners
var OverlapRemovalRefiner_1 = require("./OverlapRemovalRefiner");
exports.OverlapRemovalRefiner = OverlapRemovalRefiner_1.default;
var ExtractTimezoneOffsetRefiner_1 = require("./ExtractTimezoneOffsetRefiner");
exports.ExtractTimezoneOffsetRefiner = ExtractTimezoneOffsetRefiner_1.default;
var ExtractTimezoneAbbrRefiner_1 = require("./ExtractTimezoneAbbrRefiner");
exports.ExtractTimezoneAbbrRefiner = ExtractTimezoneAbbrRefiner_1.default;
var ForwardDateRefiner_1 = require("./ForwardDateRefiner");
exports.ForwardDateRefiner = ForwardDateRefiner_1.default;
var UnlikelyFormatFilter_1 = require("./UnlikelyFormatFilter");
exports.UnlikelyFormatFilter = UnlikelyFormatFilter_1.default;
// EN refiners
var ENMergeDateTimeRefiner_1 = require("./EN/ENMergeDateTimeRefiner");
exports.ENMergeDateTimeRefiner = ENMergeDateTimeRefiner_1.default;
var ENMergeDateRangeRefiner_1 = require("./EN/ENMergeDateRangeRefiner");
exports.ENMergeDateRangeRefiner = ENMergeDateRangeRefiner_1.default;
var ENPrioritizeSpecificDateRefiner_1 = require("./EN/ENPrioritizeSpecificDateRefiner");
exports.ENPrioritizeSpecificDateRefiner = ENPrioritizeSpecificDateRefiner_1.default;
// JP refiners
var JPMergeDateRangeRefiner_1 = require("./JP/JPMergeDateRangeRefiner");
exports.JPMergeDateRangeRefiner = JPMergeDateRangeRefiner_1.default;
// FR refiners
var FRMergeDateRangeRefiner_1 = require("./FR/FRMergeDateRangeRefiner");
exports.FRMergeDateRangeRefiner = FRMergeDateRangeRefiner_1.default;
var FRMergeDateTimeRefiner_1 = require("./FR/FRMergeDateTimeRefiner");
exports.FRMergeDateTimeRefiner = FRMergeDateTimeRefiner_1.default;
// DE refiners
var DEMergeDateRangeRefiner_1 = require("./DE/DEMergeDateRangeRefiner");
exports.DEMergeDateRangeRefiner = DEMergeDateRangeRefiner_1.default;
var DEMergeDateTimeRefiner_1 = require("./DE/DEMergeDateTimeRefiner");
exports.DEMergeDateTimeRefiner = DEMergeDateTimeRefiner_1.default;

},{"./DE/DEMergeDateRangeRefiner":52,"./DE/DEMergeDateTimeRefiner":53,"./EN/ENMergeDateRangeRefiner":54,"./EN/ENMergeDateTimeRefiner":55,"./EN/ENPrioritizeSpecificDateRefiner":56,"./ExtractTimezoneAbbrRefiner":57,"./ExtractTimezoneOffsetRefiner":58,"./FR/FRMergeDateRangeRefiner":59,"./FR/FRMergeDateTimeRefiner":60,"./ForwardDateRefiner":61,"./JP/JPMergeDateRangeRefiner":62,"./OverlapRemovalRefiner":63,"./UnlikelyFormatFilter":64}],66:[function(require,module,exports){
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
var _moment = require("moment");
var constants_1 = require("./constants");

var ParsedResult = function () {
    function ParsedResult(result) {
        _classCallCheck(this, ParsedResult);

        this.ref = result.ref;
        this.index = result.index;
        this.text = result.text;
        this.tags = result.tags || {};
        this.start = new ParsedComponents(result.start, result.ref);
        if (result.end) {
            this.end = new ParsedComponents(result.end, result.ref);
        }
    }

    _createClass(ParsedResult, [{
        key: "clone",
        value: function clone() {
            var result = new ParsedResult({
                ref: this.ref,
                index: this.index,
                text: this.text
            });
            result.tags = Object.assign({}, this.tags);
            result.start = this.start.clone();
            if (this.end) {
                result.end = this.end.clone();
            }
            return result;
        }
    }, {
        key: "hasPossibleDates",
        value: function hasPossibleDates() {
            return this.start.isPossibleDate() && (!this.end || this.end.isPossibleDate());
        }
    }]);

    return ParsedResult;
}();

exports.ParsedResult = ParsedResult;

var ParsedComponents = function () {
    function ParsedComponents(components, ref) {
        var _this = this;

        _classCallCheck(this, ParsedComponents);

        this.knownValues = {};
        this.impliedValues = {};
        if (components) {
            Object.keys(components).forEach(function (key) {
                return _this.knownValues[key] = components[key];
            });
        }
        if (ref) {
            var refMoment = _moment(ref);
            this.imply(constants_1.DAY, refMoment.date());
            this.imply(constants_1.MONTH, refMoment.month() + 1);
            this.imply(constants_1.YEAR, refMoment.year());
        }
        this.imply(constants_1.HOUR, 12);
        this.imply(constants_1.MINUTE, 0);
        this.imply(constants_1.SECOND, 0);
        this.imply(constants_1.MILLISECOND, 0);
    }

    _createClass(ParsedComponents, [{
        key: "clone",
        value: function clone() {
            var component = new ParsedComponents();
            component.knownValues = Object.assign({}, this.knownValues);
            component.impliedValues = Object.assign({}, this.impliedValues);
            return component;
        }
    }, {
        key: "get",
        value: function get(component) {
            var defaultReturn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

            return this.isCertain(component) ? this.knownValues[component] : component in this.impliedValues ? this.impliedValues[component] : defaultReturn;
        }
    }, {
        key: "assign",
        value: function assign(component, value) {
            this.knownValues[component] = value;
            delete this.impliedValues[component];
        }
    }, {
        key: "imply",
        value: function imply(component, value) {
            if (!this.isCertain(component)) {
                this.impliedValues[component] = value;
            }
        }
    }, {
        key: "isCertain",
        value: function isCertain(component) {
            return component in this.knownValues;
        }
    }, {
        key: "isPossibleDate",
        value: function isPossibleDate() {
            var dateMoment = this.moment();
            if (this.isCertain(constants_1.TIMEZONE_OFFSET)) {
                dateMoment.utcOffset(this.get(constants_1.TIMEZONE_OFFSET));
            }
            return dateMoment.get('minute') === this.get(constants_1.MINUTE) && dateMoment.get('hour') === this.get(constants_1.HOUR) && dateMoment.get('year') === this.get(constants_1.YEAR) && dateMoment.get('month') === this.get(constants_1.MONTH) - 1 && dateMoment.get('date') === this.get(constants_1.DAY);
        }
    }, {
        key: "date",
        value: function date() {
            return this.moment().toDate();
        }
    }, {
        key: "moment",
        value: function moment() {
            var dateMoment = _moment();
            dateMoment.set('year', this.get(constants_1.YEAR));
            dateMoment.set('month', this.get(constants_1.MONTH) - 1);
            dateMoment.set('date', this.get(constants_1.DAY));
            dateMoment.set('hour', this.get(constants_1.HOUR));
            dateMoment.set('minute', this.get(constants_1.MINUTE));
            dateMoment.set('second', this.get(constants_1.SECOND));
            dateMoment.set('millisecond', this.get(constants_1.MILLISECOND));
            // Javascript Date Object return minus timezone offset
            var currentTimezoneOffset = dateMoment.utcOffset();
            var targetTimezoneOffset = this.get(constants_1.TIMEZONE_OFFSET, currentTimezoneOffset);
            var adjustTimezoneOffset = targetTimezoneOffset - currentTimezoneOffset;
            dateMoment.add(-adjustTimezoneOffset, 'minutes');
            return dateMoment;
        }
    }]);

    return ParsedComponents;
}();

exports.ParsedComponents = ParsedComponents;

},{"./constants":4,"moment":2}],67:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.WEEKDAY_OFFSET = {
    'sonntag': 0,
    'so': 0,
    'montag': 1,
    'mo': 1,
    'dienstag': 2,
    'di': 2,
    'mittwoch': 3,
    'mi': 3,
    'donnerstag': 4,
    'do': 4,
    'freitag': 5,
    'fr': 5,
    'samstag': 6,
    'sa': 6
};
// noinspection NonAsciiCharacters, JSNonASCIINames
exports.MONTH_OFFSET = {
    'januar': 1,
    'jan': 1,
    'jan.': 1,
    'februar': 2,
    'feb': 2,
    'feb.': 2,
    'märz': 3,
    'maerz': 3,
    'mär': 3,
    'mär.': 3,
    'mrz': 3,
    'mrz.': 3,
    'april': 4,
    'apr': 4,
    'apr.': 4,
    'mai': 5,
    'juni': 6,
    'jun': 6,
    'jun.': 6,
    'juli': 7,
    'jul': 7,
    'jul.': 7,
    'august': 8,
    'aug': 8,
    'aug.': 8,
    'september': 9,
    'sep': 9,
    'sep.': 9,
    'sept': 9,
    'sept.': 9,
    'oktober': 10,
    'okt': 10,
    'okt.': 10,
    'november': 11,
    'nov': 11,
    'nov.': 11,
    'dezember': 12,
    'dez': 12,
    'dez.': 12
};
exports.INTEGER_WORDS_PATTERN = '(?:eins|zwei|drei|vier|fünf|fuenf|sechs|sieben|acht|neun|zehn|elf|zwölf|zwoelf)';
// noinspection NonAsciiCharacters, JSNonASCIINames
exports.INTEGER_WORDS = {
    'eins': 1,
    'zwei': 2,
    'drei': 3,
    'vier': 4,
    'fünf': 5,
    'fuenf': 5,
    'sechs': 6,
    'sieben': 7,
    'acht': 8,
    'neun': 9,
    'zehn': 10,
    'elf': 11,
    'zwölf': 12,
    'zwoelf': 12
};
var V_REGEX = /v/i;
exports.yearCalculation = function (year, yearBe) {
    if (year) {
        var result = parseInt(year, 10);
        if (yearBe) {
            if (V_REGEX.test(yearBe)) {
                // v.Chr.
                result = -result;
            }
            return result;
        } else {
            if (result < 100) {
                result = result + 2000;
            }
            return result;
        }
    }
    return null;
};
var HALF_REGEX = /halben/;
exports.matchInteger = function (text) {
    var num = 0;
    if (exports.INTEGER_WORDS.hasOwnProperty(text)) {
        num = exports.INTEGER_WORDS[text];
    } else if (text === 'einer' || text === 'einem') {
        num = 1;
    } else if (text === 'einigen') {
        num = 3;
    } else if (HALF_REGEX.test(text)) {
        num = 0.5;
    } else {
        num = parseInt(text, 10);
    }
    return num;
};
var unitPatterns = {
    'hour': /stunde/,
    'minute': /min/,
    'second': /sekunde/,
    'week': /woche/,
    'day': /tag/,
    'month': /monat/,
    'year': /jahr/
};
exports.matchUnit = function (text) {
    return Object.keys(unitPatterns).find(function (unit) {
        return unitPatterns[unit].test(text);
    });
};

},{}],68:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.WEEKDAY_OFFSET = {
    'sunday': 0,
    'sun': 0,
    'monday': 1,
    'mon': 1,
    'tuesday': 2,
    'tue': 2,
    'wednesday': 3,
    'wed': 3,
    'thursday': 4,
    'thur': 4,
    'thurs': 4,
    'thu': 4,
    'friday': 5,
    'fri': 5,
    'saturday': 6,
    'sat': 6
};
exports.MONTH_OFFSET = {
    'january': 1,
    'jan': 1,
    'jan.': 1,
    'february': 2,
    'feb': 2,
    'feb.': 2,
    'march': 3,
    'mar': 3,
    'mar.': 3,
    'april': 4,
    'apr': 4,
    'apr.': 4,
    'may': 5,
    'june': 6,
    'jun': 6,
    'jun.': 6,
    'july': 7,
    'jul': 7,
    'jul.': 7,
    'august': 8,
    'aug': 8,
    'aug.': 8,
    'september': 9,
    'sep': 9,
    'sep.': 9,
    'sept': 9,
    'sept.': 9,
    'october': 10,
    'oct': 10,
    'oct.': 10,
    'november': 11,
    'nov': 11,
    'nov.': 11,
    'december': 12,
    'dec': 12,
    'dec.': 12
};
exports.INTEGER_WORDS = {
    'one': 1,
    'two': 2,
    'three': 3,
    'four': 4,
    'five': 5,
    'six': 6,
    'seven': 7,
    'eight': 8,
    'nine': 9,
    'ten': 10,
    'eleven': 11,
    'twelve': 12
};
exports.INTEGER_WORDS_PATTERN = '(?:' + Object.keys(exports.INTEGER_WORDS).join('|') + ')';
exports.ORDINAL_WORDS = {
    'first': 1,
    'second': 2,
    'third': 3,
    'fourth': 4,
    'fifth': 5,
    'sixth': 6,
    'seventh': 7,
    'eighth': 8,
    'ninth': 9,
    'tenth': 10,
    'eleventh': 11,
    'twelfth': 12,
    'thirteenth': 13,
    'fourteenth': 14,
    'fifteenth': 15,
    'sixteenth': 16,
    'seventeenth': 17,
    'eighteenth': 18,
    'nineteenth': 19,
    'twentieth': 20,
    'twenty first': 21,
    'twenty second': 22,
    'twenty third': 23,
    'twenty fourth': 24,
    'twenty fifth': 25,
    'twenty sixth': 26,
    'twenty seventh': 27,
    'twenty eighth': 28,
    'twenty ninth': 29,
    'thirtieth': 30,
    'thirty first': 31
};
exports.ORDINAL_WORDS_PATTERN = '(?:' + Object.keys(exports.ORDINAL_WORDS).join('|').replace(/ /g, '[ -]') + ')';
var TIME_UNIT = '(' + exports.INTEGER_WORDS_PATTERN + '|[0-9]+|an?(?:\\s*few)?|half(?:\\s*an?)?)\\s*' + '(sec(?:onds?)?|min(?:ute)?s?|hours?|weeks?|days?|months?|years?)\\s*';
var TIME_UNIT_STRICT = '([0-9]+|an?)\\s*' + '(seconds?|minutes?|hours?|days?)\\s*';
var PATTERN_TIME_UNIT = new RegExp(TIME_UNIT, 'i');
exports.TIME_UNIT_PATTERN = '(?:' + TIME_UNIT + ')+';
exports.TIME_UNIT_STRICT_PATTERN = '(?:' + TIME_UNIT_STRICT + ')+';
exports.extractDateTimeUnitFragments = function (timeunitText) {
    var fragments = {};
    var remainingText = timeunitText;
    var match = PATTERN_TIME_UNIT.exec(remainingText);
    while (match) {
        collectDateTimeFragment(match, fragments);
        remainingText = remainingText.substring(match[0].length);
        match = PATTERN_TIME_UNIT.exec(remainingText);
    }
    return fragments;
};
function collectDateTimeFragment(match, fragments) {
    var matchedNumber = match[1].toLowerCase();
    var matchedUnit = match[2].toLowerCase();
    var num = 0;
    if (exports.INTEGER_WORDS.hasOwnProperty(matchedNumber)) {
        num = exports.INTEGER_WORDS[matchedNumber];
    } else if (matchedNumber === 'a' || matchedNumber === 'an') {
        num = 1;
    } else if (matchedNumber.match(/few/)) {
        num = 3;
    } else if (matchedNumber.match(/half/)) {
        num = 0.5;
    } else {
        num = parseInt(matchedNumber, 10);
    }
    if (matchedUnit.match(/hour/)) {
        fragments['hour'] = num;
    } else if (matchedUnit.match(/min/)) {
        fragments['minute'] = num;
    } else if (matchedUnit.match(/sec/)) {
        fragments['second'] = num;
    } else if (matchedUnit.match(/week/)) {
        fragments['week'] = num;
    } else if (matchedUnit.match(/day/)) {
        fragments['d'] = num;
    } else if (matchedUnit.match(/month/)) {
        fragments['month'] = num;
    } else if (matchedUnit.match(/year/)) {
        fragments['year'] = num;
    }
    return fragments;
}
var HALF_REGEX = /half/;
var FEW_REGEX = /few/;
exports.matchInteger = function (text) {
    var num = 0;
    if (text) {
        if (exports.INTEGER_WORDS.hasOwnProperty(text)) {
            num = exports.INTEGER_WORDS[text];
        } else if (text === 'a' || text === 'an') {
            num = 1;
        } else if (text.match(FEW_REGEX)) {
            num = 3;
        } else if (text.match(HALF_REGEX)) {
            num = 0.5;
        } else {
            num = parseInt(text, 10);
        }
    }
    return num;
};
var unitPatterns = {
    'hour': /hour/,
    'minute': /min/,
    'second': /second/,
    'week': /week/,
    'day': /day/,
    'month': /month/,
    'year': /year/
};
exports.matchUnit = function (text) {
    return Object.keys(unitPatterns).find(function (unit) {
        return unitPatterns[unit].test(text);
    });
};
var BE_REGEX = /BE/i;
var BC_REGEX = /BC/i;
var AD_REGEX = /AD/i;
exports.yearCalculation = function (year, maybeYearBe) {
    if (year) {
        if (BE_REGEX.test(maybeYearBe || year)) {
            // Buddhist Era
            return parseInt(maybeYearBe ? year : year.replace(BE_REGEX, ''), 10) - 543;
        } else if (BC_REGEX.test(maybeYearBe || year)) {
            // Before Christ
            return -parseInt(maybeYearBe ? year : year.replace(BC_REGEX, ''), 10);
        } else if (AD_REGEX.test(maybeYearBe || year)) {
            return parseInt(maybeYearBe ? year : year.replace(AD_REGEX, ''), 10);
        } else {
            var result = parseInt(year, 10);
            if (result < 100) {
                result += 2000;
            }
            return result;
        }
    }
    return null;
};

},{}],69:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// noinspection NonAsciiCharacters, JSNonASCIINames
exports.WEEKDAY_OFFSET = {
    'domingo': 0,
    'dom': 0,
    'lunes': 1,
    'lun': 1,
    'martes': 2,
    'mar': 2,
    'miércoles': 3,
    'miercoles': 3,
    'mie': 3,
    'jueves': 4,
    'jue': 4,
    'viernes': 5,
    'vie': 5,
    'sábado': 6,
    'sabado': 6,
    'sab': 6
};
// noinspection NonAsciiCharacters, JSNonASCIINames
exports.MONTH_OFFSET = {
    'enero': 1,
    'ene': 1,
    'ene.': 1,
    'febrero': 2,
    'feb': 2,
    'feb.': 2,
    'marzo': 3,
    'mar': 3,
    'mar.': 3,
    'abril': 4,
    'abr': 4,
    'abr.': 4,
    'mayo': 5,
    'may': 5,
    'may.': 5,
    'junio': 6,
    'jun': 6,
    'jun.': 6,
    'julio': 7,
    'jul': 7,
    'jul.': 7,
    'agosto': 8,
    'ago': 8,
    'ago.': 8,
    'septiembre': 9,
    'sep': 9,
    'sept': 9,
    'sep.': 9,
    'sept.': 9,
    'octubre': 10,
    'oct': 10,
    'oct.': 10,
    'noviembre': 11,
    'nov': 11,
    'nov.': 11,
    'diciembre': 12,
    'dic': 12,
    'dic.': 12
};
var unitPatterns = {
    day: /d[ií]a/,
    hour: /hora/,
    minute: /minuto/,
    week: /semana/,
    month: /mes/,
    year: /año/
};
exports.matchUnit = function (text) {
    return Object.keys(unitPatterns).find(function (unit) {
        return unitPatterns[unit].test(text);
    });
};
var AD_REGEX = /a\.?\s*c\.?/i;
exports.yearCalculation = function (year, yearBe) {
    if (year) {
        var result = parseInt(year, 10);
        if (yearBe && AD_REGEX.test(yearBe)) {
            return -result;
        } else if (!yearBe) {
            if (result < 100) {
                return result + 2000;
            } else {
                return result;
            }
        } else {
            return result;
        }
    }
    return null;
};
var HALF_REGEX = /medi/;
exports.matchNumber = function (text) {
    var num = parseInt(text, 10);
    if (isNaN(num)) {
        if (text.match(HALF_REGEX)) {
            return 0.5;
        } else {
            return 1;
        }
    }
    return num;
};

},{}],70:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.WEEKDAY_OFFSET = {
    'dimanche': 0,
    'dim': 0,
    'lundi': 1,
    'lun': 1,
    'mardi': 2,
    'mar': 2,
    'mercredi': 3,
    'mer': 3,
    'jeudi': 4,
    'jeu': 4,
    'vendredi': 5,
    'ven': 5,
    'samedi': 6,
    'sam': 6
};
// noinspection NonAsciiCharacters, JSNonASCIINames
exports.MONTH_OFFSET = {
    'janvier': 1,
    'jan': 1,
    'jan.': 1,
    'février': 2,
    'fév': 2,
    'fév.': 2,
    'fevrier': 2,
    'fev': 2,
    'fev.': 2,
    'mars': 3,
    'mar': 3,
    'mar.': 3,
    'avril': 4,
    'avr': 4,
    'avr.': 4,
    'mai': 5,
    'juin': 6,
    'jun': 6,
    'juil': 7,
    'juillet': 7,
    'jul': 7,
    'jul.': 7,
    'août': 8,
    'aout': 8,
    'septembre': 9,
    'sep': 9,
    'sep.': 9,
    'sept': 9,
    'sept.': 9,
    'octobre': 10,
    'oct': 10,
    'oct.': 10,
    'novembre': 11,
    'nov': 11,
    'nov.': 11,
    'décembre': 12,
    'decembre': 12,
    'dec': 12,
    'dec.': 12
};
exports.INTEGER_WORDS_PATTERN = '(?:un|deux|trois|quatre|cinq|six|sept|huit|neuf|dix|onze|douze|treize)';
exports.INTEGER_WORDS = {
    'un': 1,
    'deux': 2,
    'trois': 3,
    'quatre': 4,
    'cinq': 5,
    'six': 6,
    'sept': 7,
    'huit': 8,
    'neuf': 9,
    'dix': 10,
    'onze': 11,
    'douze': 12,
    'treize': 13
};
var unitPatterns = {
    day: /jours?/,
    hour: /heures?/,
    minute: /min(?:ute)?s?/,
    second: /secondes?/,
    week: /semaines?/,
    month: /mois?/,
    year: /an(?:née)?s?/
};
exports.matchUnit = function (text) {
    return Object.keys(unitPatterns).find(function (unit) {
        return unitPatterns[unit].test(text);
    });
};
var THREE_REGEX = /quelques?/;
var HALF_REGEX = /demi-?/;
exports.matchNumber = function (text) {
    if (!text) {
        return 1;
    }
    if (exports.INTEGER_WORDS.hasOwnProperty(text)) {
        return exports.INTEGER_WORDS[text];
    } else if (text === 'un' || text === 'une') {
        return 1;
    } else if (text.match(THREE_REGEX)) {
        return 3;
    } else if (text.match(HALF_REGEX)) {
        return 0.5;
    }
    var num = parseInt(text, 10);
    if (isNaN(num)) {
        return 1;
    }
    return num;
};
var AD_REGEX = /a/i;
exports.yearCalculation = function (year, yearBe) {
    if (year) {
        var result = parseInt(year, 10);
        if (yearBe && AD_REGEX.test(yearBe)) {
            return -result;
        } else if (!yearBe) {
            if (result < 100) {
                return result + 2000;
            } else {
                return result;
            }
        } else {
            return result;
        }
    }
    return null;
};

},{}],71:[function(require,module,exports){
"use strict";
/**
 * to-hankaku.js
 * convert to ascii code strings.
 *
 * @version 1.0.1
 * @author think49
 * @url https://gist.github.com/964592
 * @license http://www.opensource.org/licenses/mit-license.php (The MIT License)
 */

Object.defineProperty(exports, "__esModule", { value: true });
exports.toHankaku = function (String, fromCharCode) {
    var alphaNum = function alphaNum(token) {
        return fromCharCode(token.charCodeAt(0) - 65248);
    };
    return function (string) {
        return String(string).replace(/\u2019/g, "'").replace(/\u201D/g, "\"").replace(/\u3000/g, " ").replace(/\uFFE5/g, "\xA5").replace(/[\uFF01\uFF03-\uFF06\uFF08\uFF09\uFF0C-\uFF19\uFF1C-\uFF1F\uFF21-\uFF3B\uFF3D\uFF3F\uFF41-\uFF5B\uFF5D\uFF5E]/g, alphaNum);
    };
}(String, String.fromCharCode);
/**
 * to-zenkaku.js
 * convert to multi byte strings.
 *
 * @version 1.0.2
 * @author think49
 * @url https://gist.github.com/964592
 * @license http://www.opensource.org/licenses/mit-license.php (The MIT License)
 */
exports.toZenkaku = function (String, fromCharCode) {
    var alphaNum = function alphaNum(token) {
        return fromCharCode(token.charCodeAt(0) + 65248);
    };
    return function (string) {
        return String(string).replace(/\u0020/g, "\u3000").replace(/\u0022/g, "\u201D").replace(/\u0027/g, "\u2019").replace(/\u00A5/g, "\uFFE5").replace(/[!#-&(),-9\u003C-?A-[\u005D_a-{}~]/g, alphaNum);
    };
}(String, String.fromCharCode);

},{}],72:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// noinspection NonAsciiCharacters
exports.NUMBER = {
    '零': 0,
    '一': 1,
    '二': 2,
    '兩': 2,
    '三': 3,
    '四': 4,
    '五': 5,
    '六': 6,
    '七': 7,
    '八': 8,
    '九': 9,
    '十': 10,
    '廿': 20,
    '卅': 30
};
// noinspection NonAsciiCharacters
exports.WEEKDAY_OFFSET = {
    '天': 0,
    '日': 0,
    '一': 1,
    '二': 2,
    '三': 3,
    '四': 4,
    '五': 5,
    '六': 6
};
exports.zhStringToNumber = function (text) {
    var len = text.length;
    var number = 0;
    var i = 0;
    for (; i < len; i++) {
        var char = text[i];
        if (char === '十') {
            number = number === 0 ? exports.NUMBER[char] : number * exports.NUMBER[char];
        } else {
            number += exports.NUMBER[char];
        }
    }
    return number;
};
exports.zhStringToYear = function (text) {
    var len = text.length;
    var string = '';
    var i = 0;
    for (; i < len; i++) {
        string = string + exports.NUMBER[text[i]];
    }
    return parseInt(string, 10);
};

},{}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var moment = require("moment");
var constants_1 = require("../constants");
exports.getAppropriateYear = function (current, ref) {
    var day = current.get(constants_1.DAY, -1);
    var month = current.get(constants_1.MONTH, -1);
    if (day !== -1 && month !== -1) {
        //Find the most appropriated year
        var refMoment = moment(ref);
        var refMomentClone = refMoment.clone();
        refMoment.month(month - 1);
        refMoment.date(day);
        var nextYear = refMoment.clone().add(1, 'y');
        var lastYear = refMoment.clone().add(-1, 'y');
        var diff = Math.abs(refMoment.diff(refMomentClone));
        if (Math.abs(nextYear.diff(refMomentClone)) < diff) {
            current.imply(constants_1.YEAR, nextYear.year());
        } else if (Math.abs(lastYear.diff(refMomentClone)) < diff) {
            current.imply(constants_1.YEAR, lastYear.year());
        } else {
            current.imply(constants_1.YEAR, refMoment.year());
        }
    }
};
var DeadlineMode;
(function (DeadlineMode) {
    DeadlineMode[DeadlineMode["TIME"] = 0] = "TIME";
    DeadlineMode[DeadlineMode["DATE"] = 1] = "DATE";
    DeadlineMode[DeadlineMode["NONE"] = 2] = "NONE";
})(DeadlineMode || (DeadlineMode = {}));
exports.deadlineCalculations = function (num, unit, result, momentRef) {
    var mode = DeadlineMode.NONE;
    switch (unit) {
        case constants_1.HOUR:
            momentRef.add(num, 'hour');
            mode = DeadlineMode.TIME;
            break;
        case constants_1.MINUTE:
            momentRef.add(num, 'minute');
            mode = DeadlineMode.TIME;
            break;
        case constants_1.SECOND:
            momentRef.add(num, 'second');
            mode = DeadlineMode.TIME;
            break;
        case constants_1.DAY:
            momentRef.add(num, 'd');
            mode = DeadlineMode.DATE;
            break;
        case constants_1.MONTH:
            momentRef.add(num, 'month');
            mode = DeadlineMode.DATE;
            break;
        case constants_1.YEAR:
            momentRef.add(num, 'year');
            mode = DeadlineMode.DATE;
            break;
        case constants_1.WEEK:
            momentRef.add(num * 7, 'd');
            mode = DeadlineMode.DATE;
            break;
    }
    if (mode !== DeadlineMode.NONE) {
        switch (mode) {
            case DeadlineMode.DATE:
                result.start.assign(constants_1.YEAR, momentRef.year());
                result.start.assign(constants_1.MONTH, momentRef.month() + 1);
                result.start.assign(constants_1.DAY, momentRef.date());
                break;
            case DeadlineMode.TIME:
                result.start.imply(constants_1.YEAR, momentRef.year());
                result.start.imply(constants_1.MONTH, momentRef.month() + 1);
                result.start.imply(constants_1.DAY, momentRef.date());
                result.start.assign(constants_1.HOUR, momentRef.hour());
                result.start.assign(constants_1.MINUTE, momentRef.minute());
                result.start.assign(constants_1.SECOND, momentRef.second());
                break;
        }
        return true;
    }
    return false;
};
exports.checkMonthDaysValid = function (day, month, year) {
    return day <= moment().date(1).month(month).year(year).daysInMonth();
};
var Modifier;
(function (Modifier) {
    Modifier[Modifier["LAST"] = 0] = "LAST";
    Modifier[Modifier["THIS"] = 1] = "THIS";
    Modifier[Modifier["NEXT"] = 2] = "NEXT";
    Modifier[Modifier["UNKNOWN"] = 3] = "UNKNOWN";
})(Modifier = exports.Modifier || (exports.Modifier = {}));
exports.updateParsedComponent = function (result, ref, offset, modifier) {
    var startMoment = moment(ref);
    var refOffset = startMoment.day();
    var startMomentFixed = false;
    if (modifier === Modifier.LAST) {
        startMoment.day(offset - 7);
        startMomentFixed = true;
    } else if (modifier === Modifier.NEXT) {
        startMoment.day(offset + 7);
        startMomentFixed = true;
    } else if (modifier == Modifier.THIS) {
        startMoment.day(offset);
    } else {
        var calcOffset = offset - refOffset;
        var absOffset = Math.abs(calcOffset);
        if (Math.abs(calcOffset - 7) < absOffset) {
            startMoment.day(offset - 7);
        } else if (Math.abs(calcOffset + 7) < absOffset) {
            startMoment.day(offset + 7);
        } else {
            startMoment.day(offset);
        }
    }
    result.start.assign(constants_1.WEEKDAY, offset);
    if (startMomentFixed) {
        result.start.assign(constants_1.DAY, startMoment.date());
        result.start.assign(constants_1.MONTH, startMoment.month() + 1);
        result.start.assign(constants_1.YEAR, startMoment.year());
    } else {
        result.start.imply(constants_1.DAY, startMoment.date());
        result.start.imply(constants_1.MONTH, startMoment.month() + 1);
        result.start.imply(constants_1.YEAR, startMoment.year());
    }
};

},{"../constants":4,"moment":2}]},{},[3])(3)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvbW9tZW50L2xvY2FsZS9mci5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwic3JjL2Nocm9uby50cyIsInNyYy9jb25zdGFudHMudHMiLCJzcmMvb3B0aW9ucy50cyIsInNyYy9wYXJzZXJzL0RFL0RFQ2FzdWFsRGF0ZVBhcnNlci50cyIsInNyYy9wYXJzZXJzL0RFL0RFRGVhZGxpbmVGb3JtYXRQYXJzZXIudHMiLCJzcmMvcGFyc2Vycy9ERS9ERU1vbnRoTmFtZUxpdHRsZUVuZGlhblBhcnNlci50cyIsInNyYy9wYXJzZXJzL0RFL0RFTW9udGhOYW1lUGFyc2VyLnRzIiwic3JjL3BhcnNlcnMvREUvREVTbGFzaERhdGVGb3JtYXRQYXJzZXIudHMiLCJzcmMvcGFyc2Vycy9ERS9ERVRpbWVBZ29Gb3JtYXRQYXJzZXIudHMiLCJzcmMvcGFyc2Vycy9ERS9ERVRpbWVFeHByZXNzaW9uUGFyc2VyLnRzIiwic3JjL3BhcnNlcnMvREUvREVXZWVrZGF5UGFyc2VyLnRzIiwic3JjL3BhcnNlcnMvRU4vRU5DYXN1YWxEYXRlUGFyc2VyLnRzIiwic3JjL3BhcnNlcnMvRU4vRU5DYXN1YWxUaW1lUGFyc2VyLnRzIiwic3JjL3BhcnNlcnMvRU4vRU5EZWFkbGluZUZvcm1hdFBhcnNlci50cyIsInNyYy9wYXJzZXJzL0VOL0VOSVNPRm9ybWF0UGFyc2VyLnRzIiwic3JjL3BhcnNlcnMvRU4vRU5Nb250aE5hbWVMaXR0bGVFbmRpYW5QYXJzZXIudHMiLCJzcmMvcGFyc2Vycy9FTi9FTk1vbnRoTmFtZU1pZGRsZUVuZGlhblBhcnNlci50cyIsInNyYy9wYXJzZXJzL0VOL0VOTW9udGhOYW1lUGFyc2VyLnRzIiwic3JjL3BhcnNlcnMvRU4vRU5SZWxhdGl2ZURhdGVGb3JtYXRQYXJzZXIudHMiLCJzcmMvcGFyc2Vycy9FTi9FTlNsYXNoRGF0ZUZvcm1hdFBhcnNlci50cyIsInNyYy9wYXJzZXJzL0VOL0VOU2xhc2hEYXRlRm9ybWF0U3RhcnRXaXRoWWVhclBhcnNlci50cyIsInNyYy9wYXJzZXJzL0VOL0VOU2xhc2hNb250aEZvcm1hdFBhcnNlci50cyIsInNyYy9wYXJzZXJzL0VOL0VOVGltZUFnb0Zvcm1hdFBhcnNlci50cyIsInNyYy9wYXJzZXJzL0VOL0VOVGltZUV4cHJlc3Npb25QYXJzZXIudHMiLCJzcmMvcGFyc2Vycy9FTi9FTlRpbWVMYXRlckZvcm1hdFBhcnNlci50cyIsInNyYy9wYXJzZXJzL0VOL0VOV2Vla2RheVBhcnNlci50cyIsInNyYy9wYXJzZXJzL0VTL0VTQ2FzdWFsRGF0ZVBhcnNlci50cyIsInNyYy9wYXJzZXJzL0VTL0VTRGVhZGxpbmVGb3JtYXRQYXJzZXIudHMiLCJzcmMvcGFyc2Vycy9FUy9FU01vbnRoTmFtZUxpdHRsZUVuZGlhblBhcnNlci50cyIsInNyYy9wYXJzZXJzL0VTL0VTU2xhc2hEYXRlRm9ybWF0UGFyc2VyLnRzIiwic3JjL3BhcnNlcnMvRVMvRVNUaW1lQWdvRm9ybWF0UGFyc2VyLnRzIiwic3JjL3BhcnNlcnMvRVMvRVNUaW1lRXhwcmVzc2lvblBhcnNlci50cyIsInNyYy9wYXJzZXJzL0VTL0VTV2Vla2RheVBhcnNlci50cyIsInNyYy9wYXJzZXJzL0ZSL0ZSQ2FzdWFsRGF0ZVBhcnNlci50cyIsInNyYy9wYXJzZXJzL0ZSL0ZSRGVhZGxpbmVGb3JtYXRQYXJzZXIudHMiLCJzcmMvcGFyc2Vycy9GUi9GUk1vbnRoTmFtZUxpdHRsZUVuZGlhblBhcnNlci50cyIsInNyYy9wYXJzZXJzL0ZSL0ZSUmVsYXRpdmVEYXRlRm9ybWF0UGFyc2VyLnRzIiwic3JjL3BhcnNlcnMvRlIvRlJTbGFzaERhdGVGb3JtYXRQYXJzZXIudHMiLCJzcmMvcGFyc2Vycy9GUi9GUlRpbWVBZ29Gb3JtYXRQYXJzZXIudHMiLCJzcmMvcGFyc2Vycy9GUi9GUlRpbWVFeHByZXNzaW9uUGFyc2VyLnRzIiwic3JjL3BhcnNlcnMvRlIvRlJXZWVrZGF5UGFyc2VyLnRzIiwic3JjL3BhcnNlcnMvSlAvSlBDYXN1YWxEYXRlUGFyc2VyLnRzIiwic3JjL3BhcnNlcnMvSlAvSlBTdGFuZGFyZFBhcnNlci50cyIsInNyYy9wYXJzZXJzL1pILUhhbnQvWkhIYW50Q2FzdWFsRGF0ZVBhcnNlci50cyIsInNyYy9wYXJzZXJzL1pILUhhbnQvWkhIYW50RGF0ZVBhcnNlci50cyIsInNyYy9wYXJzZXJzL1pILUhhbnQvWkhIYW50RGVhZGxpbmVGb3JtYXRQYXJzZXIudHMiLCJzcmMvcGFyc2Vycy9aSC1IYW50L1pISGFudFRpbWVFeHByZXNzaW9uUGFyc2VyLnRzIiwic3JjL3BhcnNlcnMvWkgtSGFudC9aSEhhbnRXZWVrZGF5UGFyc2VyLnRzIiwic3JjL3BhcnNlcnMvcGFyc2VyLnRzIiwic3JjL3JlZmluZXJzL0RFL0RFTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLnRzIiwic3JjL3JlZmluZXJzL0RFL0RFTWVyZ2VEYXRlVGltZVJlZmluZXIudHMiLCJzcmMvcmVmaW5lcnMvRU4vRU5NZXJnZURhdGVSYW5nZVJlZmluZXIudHMiLCJzcmMvcmVmaW5lcnMvRU4vRU5NZXJnZURhdGVUaW1lUmVmaW5lci50cyIsInNyYy9yZWZpbmVycy9FTi9FTlByaW9yaXRpemVTcGVjaWZpY0RhdGVSZWZpbmVyLnRzIiwic3JjL3JlZmluZXJzL0V4dHJhY3RUaW1lem9uZUFiYnJSZWZpbmVyLnRzIiwic3JjL3JlZmluZXJzL0V4dHJhY3RUaW1lem9uZU9mZnNldFJlZmluZXIudHMiLCJzcmMvcmVmaW5lcnMvRlIvRlJNZXJnZURhdGVSYW5nZVJlZmluZXIudHMiLCJzcmMvcmVmaW5lcnMvRlIvRlJNZXJnZURhdGVUaW1lUmVmaW5lci50cyIsInNyYy9yZWZpbmVycy9Gb3J3YXJkRGF0ZVJlZmluZXIudHMiLCJzcmMvcmVmaW5lcnMvSlAvSlBNZXJnZURhdGVSYW5nZVJlZmluZXIudHMiLCJzcmMvcmVmaW5lcnMvT3ZlcmxhcFJlbW92YWxSZWZpbmVyLnRzIiwic3JjL3JlZmluZXJzL1VubGlrZWx5Rm9ybWF0RmlsdGVyLnRzIiwic3JjL3JlZmluZXJzL3JlZmluZXIudHMiLCJzcmMvcmVzdWx0LnRzIiwic3JjL3V0aWxzL0RFLnRzIiwic3JjL3V0aWxzL0VOLnRzIiwic3JjL3V0aWxzL0VTLnRzIiwic3JjL3V0aWxzL0ZSLnRzIiwic3JjL3V0aWxzL0pQLnRzIiwic3JjL3V0aWxzL1pILUhhbnQudHMiLCJzcmMvdXRpbHMvZ2VuZXJhbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdjdJQSxzQkFBcUM7QUFpQjdCLGtCQUFPO0FBaEJmLHdCQVVtQztBQUNuQzthQUFt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LGVBQUMsQUFBQyxBQUFDLEdBQUMsQUFBSSxLQUFDLEFBQVcsQUFBQyxBQUFDLGNBQUMsQUFBQztBQUNsRCxBQUFXLDRCQUFDLEFBQUcsSUFBQyxBQUFTLFVBQUMsQUFBSSxBQUFFLFNBQUcsQUFBQyxBQUFDLEFBQUMsSUFBQyxBQUFDLEFBQUMsQUFBQyxJQUFDLEFBQUMsR0FBRSxBQUFLLEFBQUMsQUFBQyxBQUN6RDtBQUFDLEFBQUMsQUFBSSxhQUZDLEFBQUUsQUFBQyxVQUVDLEFBQUksS0FBQyxBQUFjLGVBQUMsQUFBQyxBQUFDLEdBQUMsQUFBSSxLQUFDLEFBQVcsQUFBQyxBQUFDLGNBQUMsQUFBQztBQUNsRCxBQUFxQztBQUNyQyxBQUFFLEFBQUMsb0JBQUMsQUFBUyxVQUFDLEFBQUksQUFBRSxTQUFHLEFBQUMsQUFBQyxHQUFDLEFBQUM7QUFDdkIsQUFBVyxnQ0FBQyxBQUFHLElBQUMsQUFBQyxHQUFFLEFBQUssQUFBQyxBQUFDLEFBQzlCO0FBQUMsQUFDTDtBQUFDLEFBQUMsQUFBSSxhQUxDLEFBQUUsQUFBQyxVQUtDLEFBQUksS0FBQyxBQUFjLGVBQUMsQUFBQyxBQUFDLEdBQUMsQUFBSSxLQUFDLEFBQVcsQUFBQyxBQUFDLGNBQUMsQUFBQztBQUNsRCxBQUFXLDRCQUFDLEFBQUcsSUFBQyxDQUFDLEFBQUMsR0FBRSxBQUFLLEFBQUMsQUFBQyxBQUMvQjtBQUFDLEFBQUMsQUFBSSxhQUZDLEFBQUUsQUFBQyxVQUVDLEFBQUksS0FBQyxBQUFjLGVBQUMsQUFBQyxBQUFDLEdBQUMsQUFBSSxLQUFDLEFBQVcsQUFBQyxBQUFDLGNBQUMsQUFBQztBQUNsRCxBQUFXLDRCQUFDLEFBQUcsSUFBQyxDQUFDLEFBQUMsR0FBRSxBQUFLLEFBQUMsQUFBQyxBQUMvQjtBQUFDLEFBQUMsQUFBSSxhQUZDLEFBQUUsQUFBQyxVQUVDLEFBQUksS0FBQyxBQUFjLGVBQUMsQUFBQyxBQUFDLEdBQUMsQUFBSSxLQUFDLEFBQVcsQUFBQyxBQUFDLGNBQUMsQUFBQztBQUNsRCxBQUFNLHVCQUFDLEFBQUssTUFBQyxB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LDBEQUFBLEFBQU8sQUFBMEI7QUFDekMsc0NBQTRFO0FBQXBFLHdEQUFBLEFBQU8sQUFBeUI7QUFDeEMsdUNBQThFO0FBQXRFLDBEQUFBLEFBQU8sQUFBMEI7QUFDekMsZ0NBQWdFO0FBQXhELDRDQUFBLEFBQU8sQUFBbUI7QUFDbEMsOENBQTRGO0FBQXBGLHdFQUFBLEFBQU8sQUFBaUM7QUFDaEQsd0NBQWdGO0FBQXhFLDREQUFBLEFBQU8sQUFBMkI7QUFFMUMsbUNBQXNFO0FBQTlELGtEQUFBLEFBQU8sQUFBc0I7QUFDckMsdUNBQThFO0FBQXRFLDBEQUFBLEFBQU8sQUFBMEI7QUFDekMsOENBQTRGO0FBQXBGLHdFQUFBLEFBQU8sQUFBaUM7QUFDaEQsd0NBQWdGO0FBQXhFLDREQUFBLEFBQU8sQUFBMkI7QUFDMUMsc0NBQTRFO0FBQXBFLHdEQUFBLEFBQU8sQUFBeUI7QUFDeEMsdUNBQThFO0FBQXRFLDBEQUFBLEFBQU8sQUFBMEI7QUFDekMsZ0NBQWdFO0FBQXhELDRDQUFBLEFBQU8sQUFBbUI7QUFDbEMsMkNBQXNGO0FBQTlFLGtFQUFBLEFBQU8sQUFBOEI7QUFFN0MsaUNBQXVFO0FBQS9ELDhDQUFBLEFBQU8sQUFBb0I7QUFDbkMsb0NBQTZFO0FBQXJFLG9EQUFBLEFBQU8sQUFBdUI7QUFDdEMsMkNBQTJGO0FBQW5GLGtFQUFBLEFBQU8sQUFBOEI7QUFDN0MsdUNBQW1GO0FBQTNFLDBEQUFBLEFBQU8sQUFBMEI7QUFDekMsMkNBQTJGO0FBQW5GLGtFQUFBLEFBQU8sQUFBOEI7QUFFN0MsdUNBQThFO0FBQXRFLDBEQUFBLEFBQU8sQUFBMEI7QUFDekMsOENBQTRGO0FBQXBGLHdFQUFBLEFBQU8sQUFBaUM7QUFDaEQsa0NBQW9FO0FBQTVELGdEQUFBLEFBQU8sQUFBcUI7QUFDcEMsd0NBQWdGO0FBQXhFLDREQUFBLEFBQU8sQUFBMkI7QUFDMUMsc0NBQTRFO0FBQXBFLHdEQUFBLEFBQU8sQUFBeUI7QUFDeEMsdUNBQThFO0FBQXRFLDBEQUFBLEFBQU8sQUFBMEI7QUFDekMsZ0NBQWdFO0FBQXhE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LEtBQUMsQUFBSyxPQUFDLEFBQUcsS0FBQyxBQUFNLFFBQUMsQ0FBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLENBQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLENBQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxDQUFDLEFBQUcsS0FBQyxBQUFPLFNBQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQ0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLENBQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLEFBQUcsS0FBQyxBQUFPLFNBQUMsQUFBQyxHQUFDLEFBQU0sUUFBQyxDQUFDLEFBQUUsSUFBQyxBQUFNLFFBQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQ0FBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLENBQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxDQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQUFBRSxJQUFDLEFBQUssT0FBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLENBQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLEFBQUUsSUFBQyxBQUFPLFNBQUMsQUFBRyxLQUFDLEFBQU8sU0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLENBQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxDQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQ0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLENBQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxDQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQ0FBQyxBQUFFLElBQUMsQUFBSyxPQUFDLEFBQUcsS0FBQyxBQUFNLFFBQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxBQUFHLEtBQUMsQUFBTyxTQUFDLENBQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxDQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxDQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQ0FBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxBQUFDLEdBQUMsQUFBSyxPQUFDLENBQUMsQUFBRSxJQUFDLEFBQUssT0FBQyxDQUFDLEFBQUcsS0FBQyxBQUFJLE1BQUMsQ0FBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxDQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQ0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLENBQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxDQUFDLEFBQUcsS0FBQyxBQUFNLFFBQUMsQ0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQ0FBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQUFBQyxHQUFDLEFBQUssT0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLENBQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxDQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQ0FBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLENBQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxDQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQ0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLENBQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxDQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQ0FBQyxBQUFFLElBQUMsQUFBSyxPQUFDLENBQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLENBQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxDQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQ0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLENBQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxDQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQ0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLENBQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxDQUFDLEFBQUcsS0FBQyxBQUFNLFFBQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxBQUFHLEtBQUMsQUFBTyxTQUFDLEFBQUcsS0FBQyxBQUFNLFFBQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLEFBQUUsSUFBQyxBQUFLLE9BQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxBQUFHLEtBQUMsQUFBTyxTQUFDLEFBQUcsS0FBQyxBQUFNLFFBQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLEFBQUcsS0FBQyxBQUFNLFFBQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLEFBQUcsS0FBQyxBQUFPLFNBQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLENBQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLENBQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLEFBQUUsSUFBQyxBQUFLLE9BQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxDQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxDQUFDLEFBQUUsSUFBQyxBQUFLLE9BQUMsQUFBRyxLQUFDLEFBQU8sU0FBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxDQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQ0FBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLEFBQUcsS0FBQyxBQUFNLFFBQUMsQUFBRyxLQUFDLEFBQU8sU0FBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQ0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLENBQUMsQUFBRyxLQUFDLEFBQU8sU0FBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxDQUFDLEFBQUcsS0FBQyxBQUFNLFFBQUMsQ0FBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQ0FBQyxBQUFHLEtBQUMsQUFBSSxNQUFDLENBQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLENBQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxDQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxBQUFHLEtBQUMsQUFBTSxRQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQ0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLENBQUMsQUFBRyxLQUFDLEFBQU0sUUFBQyxDQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxBQUFHLEtBQUMsQUFBSyxPQUFDLEFBQUcsS0FBQyxBQUFNLFFBQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxBQUFDLEdBQUMsQUFBTSxRQUFDLENBQUMsQUFBRyxLQUFDLEFBQUssT0FBQyxDQUFDLEFBQUcsS0FBQyxBQUFLLE9BQUMsQUFBRyxLQUFD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LEFBQUssTUFBQyxZQUFLLE9BQUUsQUFBVyxZQUFDLEFBQUssQUFBRSxVQUFHLEFBQUMsQUFBQyxBQUFDO0FBQ25ELEFBQU0sZUFBQyxBQUFLLE1BQUMsQUFBSyxNQUFDLFlBQUksTUFBRSxBQUFXLFlBQUMsQUFBSSxBQUFFLEFBQUMsQUFBQyxBQUNqRDtBQUFDLEFBQ0w7QUFBQyxBQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc31yZXR1cm4gZX0pKCkiLCIvLyEgbW9tZW50LmpzIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyEgbG9jYWxlIDogRnJlbmNoIFtmcl1cbi8vISBhdXRob3IgOiBKb2huIEZpc2NoZXIgOiBodHRwczovL2dpdGh1Yi5jb20vamZyb2ZmaWNlXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyBmYWN0b3J5KHJlcXVpcmUoJy4uL21vbWVudCcpKSA6XG4gICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWycuLi9tb21lbnQnXSwgZmFjdG9yeSkgOlxuICAgZmFjdG9yeShnbG9iYWwubW9tZW50KVxufSh0aGlzLCAoZnVuY3Rpb24gKG1vbWVudCkgeyAndXNlIHN0cmljdCc7XG5cblxudmFyIGZyID0gbW9tZW50LmRlZmluZUxvY2FsZSgnZnInLCB7XG4gICAgbW9udGhzIDogJ2phbnZpZXJfZsOpdnJpZXJfbWFyc19hdnJpbF9tYWlfanVpbl9qdWlsbGV0X2Fvw7t0X3NlcHRlbWJyZV9vY3RvYnJlX25vdmVtYnJlX2TDqWNlbWJyZScuc3BsaXQoJ18nKSxcbiAgICBtb250aHNTaG9ydCA6ICdqYW52Ll9mw6l2ci5fbWFyc19hdnIuX21haV9qdWluX2p1aWwuX2Fvw7t0X3NlcHQuX29jdC5fbm92Ll9kw6ljLicuc3BsaXQoJ18nKSxcbiAgICBtb250aHNQYXJzZUV4YWN0IDogdHJ1ZSxcbiAgICB3ZWVrZGF5cyA6ICdkaW1hbmNoZV9sdW5kaV9tYXJkaV9tZXJjcmVkaV9qZXVkaV92ZW5kcmVkaV9zYW1lZGknLnNwbGl0KCdfJyksXG4gICAgd2Vla2RheXNTaG9ydCA6ICdkaW0uX2x1bi5fbWFyLl9tZXIuX2pldS5fdmVuLl9zYW0uJy5zcGxpdCgnXycpLFxuICAgIHdlZWtkYXlzTWluIDogJ2RpX2x1X21hX21lX2plX3ZlX3NhJy5zcGxpdCgnXycpLFxuICAgIHdlZWtkYXlzUGFyc2VFeGFjdCA6IHRydWUsXG4gICAgbG9uZ0RhdGVGb3JtYXQgOiB7XG4gICAgICAgIExUIDogJ0hIOm1tJyxcbiAgICAgICAgTFRTIDogJ0hIOm1tOnNzJyxcbiAgICAgICAgTCA6ICdERC9NTS9ZWVlZJyxcbiAgICAgICAgTEwgOiAnRCBNTU1NIFlZWVknLFxuICAgICAgICBMTEwgOiAnRCBNTU1NIFlZWVkgSEg6bW0nLFxuICAgICAgICBMTExMIDogJ2RkZGQgRCBNTU1NIFlZWVkgSEg6bW0nXG4gICAgfSxcbiAgICBjYWxlbmRhciA6IHtcbiAgICAgICAgc2FtZURheSA6ICdbQXVqb3VyZOKAmWh1aSDDoF0gTFQnLFxuICAgICAgICBuZXh0RGF5IDogJ1tEZW1haW4gw6BdIExUJyxcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbw6BdIExUJyxcbiAgICAgICAgbGFzdERheSA6ICdbSGllciDDoF0gTFQnLFxuICAgICAgICBsYXN0V2VlayA6ICdkZGRkIFtkZXJuaWVyIMOgXSBMVCcsXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgfSxcbiAgICByZWxhdGl2ZVRpbWUgOiB7XG4gICAgICAgIGZ1dHVyZSA6ICdkYW5zICVzJyxcbiAgICAgICAgcGFzdCA6ICdpbCB5IGEgJXMnLFxuICAgICAgICBzIDogJ3F1ZWxxdWVzIHNlY29uZGVzJyxcbiAgICAgICAgc3MgOiAnJWQgc2Vjb25kZXMnLFxuICAgICAgICBtIDogJ3VuZSBtaW51dGUnLFxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgaCA6ICd1bmUgaGV1cmUnLFxuICAgICAgICBoaCA6ICclZCBoZXVyZXMnLFxuICAgICAgICBkIDogJ3VuIGpvdXInLFxuICAgICAgICBkZCA6ICclZCBqb3VycycsXG4gICAgICAgIE0gOiAndW4gbW9pcycsXG4gICAgICAgIE1NIDogJyVkIG1vaXMnLFxuICAgICAgICB5IDogJ3VuIGFuJyxcbiAgICAgICAgeXkgOiAnJWQgYW5zJ1xuICAgIH0sXG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KGVyfCkvLFxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyLCBwZXJpb2QpIHtcbiAgICAgICAgc3dpdGNoIChwZXJpb2QpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJldHVybiAnZScgd2hlbiBkYXkgb2YgbW9udGggPiAxLiBNb3ZlIHRoaXMgY2FzZSBpbnNpZGVcbiAgICAgICAgICAgIC8vIGJsb2NrIGZvciBtYXNjdWxpbmUgd29yZHMgYmVsb3cuXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzMzNzVcbiAgICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAobnVtYmVyID09PSAxID8gJ2VyJyA6ICcnKTtcblxuICAgICAgICAgICAgLy8gV29yZHMgd2l0aCBtYXNjdWxpbmUgZ3JhbW1hdGljYWwgZ2VuZGVyOiBtb2lzLCB0cmltZXN0cmUsIGpvdXJcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgY2FzZSAnREREJzpcbiAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAobnVtYmVyID09PSAxID8gJ2VyJyA6ICdlJyk7XG5cbiAgICAgICAgICAgIC8vIFdvcmRzIHdpdGggZmVtaW5pbmUgZ3JhbW1hdGljYWwgZ2VuZGVyOiBzZW1haW5lXG4gICAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgIGNhc2UgJ1cnOlxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyAobnVtYmVyID09PSAxID8gJ3JlJyA6ICdlJyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHdlZWsgOiB7XG4gICAgICAgIGRvdyA6IDEsIC8vIE1vbmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3kgOiA0ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA0dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfVxufSk7XG5cbnJldHVybiBmcjtcblxufSkpKTtcbiIsIi8vISBtb21lbnQuanNcbi8vISB2ZXJzaW9uIDogMi4yMC4xXG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuLy8hIGxpY2Vuc2UgOiBNSVRcbi8vISBtb21lbnRqcy5jb21cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBob29rQ2FsbGJhY2s7XG5cbmZ1bmN0aW9uIGhvb2tzICgpIHtcbiAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbi8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4vLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbmZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayAoY2FsbGJhY2spIHtcbiAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGlucHV0KSB7XG4gICAgLy8gSUU4IHdpbGwgdHJlYXQgdW5kZWZpbmVkIGFuZCBudWxsIGFzIG9iamVjdCBpZiBpdCB3YXNuJ3QgZm9yXG4gICAgLy8gaW5wdXQgIT0gbnVsbFxuICAgIHJldHVybiBpbnB1dCAhPSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcykge1xuICAgICAgICByZXR1cm4gKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoID09PSAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaztcbiAgICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGlucHV0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59XG5cbmZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG5mdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW1wdHkgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHVudXNlZFRva2VucyAgICA6IFtdLFxuICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgb3ZlcmZsb3cgICAgICAgIDogLTIsXG4gICAgICAgIGNoYXJzTGVmdE92ZXIgICA6IDAsXG4gICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICBpbnZhbGlkTW9udGggICAgOiBudWxsLFxuICAgICAgICBpbnZhbGlkRm9ybWF0ICAgOiBmYWxzZSxcbiAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgIGlzbyAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICBwYXJzZWREYXRlUGFydHMgOiBbXSxcbiAgICAgICAgbWVyaWRpZW0gICAgICAgIDogbnVsbCxcbiAgICAgICAgcmZjMjgyMiAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHdlZWtkYXlNaXNtYXRjaCA6IGZhbHNlXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICBtLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcbiAgICB9XG4gICAgcmV0dXJuIG0uX3BmO1xufVxuXG52YXIgc29tZTtcbmlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcbn0gZWxzZSB7XG4gICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXMsIHRbaV0sIGksIHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZChtKSB7XG4gICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSk7XG4gICAgICAgIHZhciBwYXJzZWRQYXJ0cyA9IHNvbWUuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlzTm93VmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICFmbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAhZmxhZ3Mud2Vla2RheU1pc21hdGNoICYmXG4gICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgIWZsYWdzLnVzZXJJbnZhbGlkYXRlZCAmJlxuICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcblxuICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICBpc05vd1ZhbGlkID0gaXNOb3dWYWxpZCAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcbiAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBpc05vd1ZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTm93VmFsaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG0uX2lzVmFsaWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWQgKGZsYWdzKSB7XG4gICAgdmFyIG0gPSBjcmVhdGVVVEMoTmFOKTtcbiAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbnZhciBtb21lbnRQcm9wZXJ0aWVzID0gaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG5mdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgdmFyIGksIHByb3AsIHZhbDtcblxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICB9XG5cbiAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0bztcbn1cblxudmFyIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbmZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICB9XG4gICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgIC8vIG9iamVjdHMuXG4gICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTW9tZW50IHx8IChvYmogIT0gbnVsbCAmJiBvYmouX2lzQU1vbWVudE9iamVjdCAhPSBudWxsKTtcbn1cblxuZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICB2YWx1ZSA9IDA7XG5cbiAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gY29tcGFyZSB0d28gYXJyYXlzLCByZXR1cm4gdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlc1xuZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgIGxlbmd0aERpZmYgPSBNYXRoLmFicyhhcnJheTEubGVuZ3RoIC0gYXJyYXkyLmxlbmd0aCksXG4gICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgIGRpZmZzKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmZzICsgbGVuZ3RoRGlmZjtcbn1cblxuZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICBpZiAoaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihudWxsLCBtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICB2YXIgYXJnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmcgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0ga2V5ICsgJzogJyArIGFyZ3VtZW50c1swXVtrZXldICsgJywgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMCwgLTIpOyAvLyBSZW1vdmUgdHJhaWxpbmcgY29tbWEgYW5kIHNwYWNlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdhcm4obXNnICsgJ1xcbkFyZ3VtZW50czogJyArIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmpvaW4oJycpICsgJ1xcbicgKyAobmV3IEVycm9yKCkpLnN0YWNrKTtcbiAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sIGZuKTtcbn1cblxudmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihuYW1lLCBtc2cpO1xuICAgIH1cbiAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgfVxufVxuXG5ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbmhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG5mdW5jdGlvbiBzZXQgKGNvbmZpZykge1xuICAgIHZhciBwcm9wLCBpO1xuICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcbiAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX2RheU9mTW9udGhPcmRpbmFsUGFyc2UuXG4gICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgIHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgKHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2Uuc291cmNlIHx8IHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UpICtcbiAgICAgICAgICAgICd8JyArICgvXFxkezEsMn0vKS5zb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjaGlsZENvbmZpZykge1xuICAgIHZhciByZXMgPSBleHRlbmQoe30sIHBhcmVudENvbmZpZyksIHByb3A7XG4gICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkgJiYgaXNPYmplY3QoY2hpbGRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgcGFyZW50Q29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBjaGlsZENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBjaGlsZENvbmZpZ1twcm9wXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHByb3AgaW4gcGFyZW50Q29uZmlnKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKHBhcmVudENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICBpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIGRvbid0IG1vZGlmeSBwYXJlbnQgY29uZmlnXG4gICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNldChjb25maWcpO1xuICAgIH1cbn1cblxudmFyIGtleXM7XG5cbmlmIChPYmplY3Qua2V5cykge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cztcbn0gZWxzZSB7XG4gICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIGksIHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGkpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xufVxuXG52YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgIHNhbWVFbHNlIDogJ0wnXG59O1xuXG5mdW5jdGlvbiBjYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xuICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG59XG5cbnZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgTFRTICA6ICdoOm1tOnNzIEEnLFxuICAgIExUICAgOiAnaDptbSBBJyxcbiAgICBMICAgIDogJ01NL0REL1lZWVknLFxuICAgIExMICAgOiAnTU1NTSBELCBZWVlZJyxcbiAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbn07XG5cbmZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgZm9ybWF0VXBwZXIgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV07XG5cbiAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG59XG5cbnZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcblxuZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbn1cblxudmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbnZhciBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbmZ1bmN0aW9uIG9yZGluYWwgKG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbn1cblxudmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICBzICA6ICdhIGZldyBzZWNvbmRzJyxcbiAgICBzcyA6ICclZCBzZWNvbmRzJyxcbiAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgbW0gOiAnJWQgbWludXRlcycsXG4gICAgaCAgOiAnYW4gaG91cicsXG4gICAgaGggOiAnJWQgaG91cnMnLFxuICAgIGQgIDogJ2EgZGF5JyxcbiAgICBkZCA6ICclZCBkYXlzJyxcbiAgICBNICA6ICdhIG1vbnRoJyxcbiAgICBNTSA6ICclZCBtb250aHMnLFxuICAgIHkgIDogJ2EgeWVhcicsXG4gICAgeXkgOiAnJWQgeWVhcnMnXG59O1xuXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICByZXR1cm4gKGlzRnVuY3Rpb24ob3V0cHV0KSkgP1xuICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xufVxuXG5mdW5jdGlvbiBwYXN0RnV0dXJlIChkaWZmLCBvdXRwdXQpIHtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGZvcm1hdCkgPyBmb3JtYXQob3V0cHV0KSA6IGZvcm1hdC5yZXBsYWNlKC8lcy9pLCBvdXRwdXQpO1xufVxuXG52YXIgYWxpYXNlcyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRVbml0QWxpYXMgKHVuaXQsIHNob3J0aGFuZCkge1xuICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgcHJvcDtcblxuICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xufVxuXG52YXIgcHJpb3JpdGllcyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG59XG5cbmZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICBmb3IgKHZhciB1IGluIHVuaXRzT2JqKSB7XG4gICAgICAgIHVuaXRzLnB1c2goe3VuaXQ6IHUsIHByaW9yaXR5OiBwcmlvcml0aWVzW3VdfSk7XG4gICAgfVxuICAgIHVuaXRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgIH0pO1xuICAgIHJldHVybiB1bml0cztcbn1cblxuZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgIHZhciBhYnNOdW1iZXIgPSAnJyArIE1hdGguYWJzKG51bWJlciksXG4gICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgIHJldHVybiAoc2lnbiA/IChmb3JjZVNpZ24gPyAnKycgOiAnJykgOiAnLScpICtcbiAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgKyBhYnNOdW1iZXI7XG59XG5cbnZhciBmb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KFtIaF1tbShzcyk/fE1vfE1NP00/TT98RG98REREb3xERD9EP0Q/fGRkZD9kP3xkbz98d1tvfHddP3xXW298V10/fFFvP3xZWVlZWVl8WVlZWVl8WVlZWXxZWXxnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xraz98bW0/fHNzP3xTezEsOX18eHxYfHp6P3xaWj98LikvZztcblxudmFyIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2c7XG5cbnZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxudmFyIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge307XG5cbi8vIHRva2VuOiAgICAnTSdcbi8vIHBhZGRlZDogICBbJ01NJywgMl1cbi8vIG9yZGluYWw6ICAnTW8nXG4vLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbmZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgIHZhciBmdW5jID0gY2FsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2NhbGxiYWNrXSgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICB9XG4gICAgaWYgKHBhZGRlZCkge1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tvcmRpbmFsXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdG9rZW4pO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xufVxuXG5mdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLCBpLCBsZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gJycsIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0ICs9IGlzRnVuY3Rpb24oYXJyYXlbaV0pID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdCkgOiBhcnJheVtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59XG5cbi8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxuXG4gICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgIHZhciBpID0gNTtcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICB9XG5cbiAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgaSAtPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXQ7XG59XG5cbnZhciBtYXRjaDEgICAgICAgICA9IC9cXGQvOyAgICAgICAgICAgIC8vICAgICAgIDAgLSA5XG52YXIgbWF0Y2gyICAgICAgICAgPSAvXFxkXFxkLzsgICAgICAgICAgLy8gICAgICAwMCAtIDk5XG52YXIgbWF0Y2gzICAgICAgICAgPSAvXFxkezN9LzsgICAgICAgICAvLyAgICAgMDAwIC0gOTk5XG52YXIgbWF0Y2g0ICAgICAgICAgPSAvXFxkezR9LzsgICAgICAgICAvLyAgICAwMDAwIC0gOTk5OVxudmFyIG1hdGNoNiAgICAgICAgID0gL1srLV0/XFxkezZ9LzsgICAgLy8gLTk5OTk5OSAtIDk5OTk5OVxudmFyIG1hdGNoMXRvMiAgICAgID0gL1xcZFxcZD8vOyAgICAgICAgIC8vICAgICAgIDAgLSA5OVxudmFyIG1hdGNoM3RvNCAgICAgID0gL1xcZFxcZFxcZFxcZD8vOyAgICAgLy8gICAgIDk5OSAtIDk5OTlcbnZhciBtYXRjaDV0bzYgICAgICA9IC9cXGRcXGRcXGRcXGRcXGRcXGQ/LzsgLy8gICA5OTk5OSAtIDk5OTk5OVxudmFyIG1hdGNoMXRvMyAgICAgID0gL1xcZHsxLDN9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OVxudmFyIG1hdGNoMXRvNCAgICAgID0gL1xcZHsxLDR9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OTlcbnZhciBtYXRjaDF0bzYgICAgICA9IC9bKy1dP1xcZHsxLDZ9LzsgIC8vIC05OTk5OTkgLSA5OTk5OTlcblxudmFyIG1hdGNoVW5zaWduZWQgID0gL1xcZCsvOyAgICAgICAgICAgLy8gICAgICAgMCAtIGluZlxudmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxuXG52YXIgbWF0Y2hPZmZzZXQgICAgPSAvWnxbKy1dXFxkXFxkOj9cXGRcXGQvZ2k7IC8vICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxudmFyIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naTsgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcblxudmFyIG1hdGNoVGltZXN0YW1wID0gL1srLV0/XFxkKyhcXC5cXGR7MSwzfSk/LzsgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcblxuLy8gYW55IHdvcmQgKG9yIHR3bykgY2hhcmFjdGVycyBvciBudW1iZXJzIGluY2x1ZGluZyB0d28vdGhyZWUgd29yZCBtb250aCBpbiBhcmFiaWMuXG4vLyBpbmNsdWRlcyBzY290dGlzaCBnYWVsaWMgdHdvIHdvcmQgYW5kIGh5cGhlbmF0ZWQgbW9udGhzXG52YXIgbWF0Y2hXb3JkID0gL1swLTldezAsMjU2fVsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRjA3XFx1RkYxMC1cXHVGRkVGXXsxLDI1Nn18W1xcdTA2MDAtXFx1MDZGRlxcL117MSwyNTZ9KFxccyo/W1xcdTA2MDAtXFx1MDZGRl17MSwyNTZ9KXsxLDJ9L2k7XG5cblxudmFyIHJlZ2V4ZXMgPSB7fTtcblxuZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgIHJlZ2V4ZXNbdG9rZW5dID0gaXNGdW5jdGlvbihyZWdleCkgPyByZWdleCA6IGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlRGF0YSkge1xuICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuICh0b2tlbiwgY29uZmlnKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xuICAgIH1cblxuICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xufVxuXG4vLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG5mdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgcmV0dXJuIHJlZ2V4RXNjYXBlKHMucmVwbGFjZSgnXFxcXCcsICcnKS5yZXBsYWNlKC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgfSkpO1xufVxuXG5mdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG59XG5cbnZhciB0b2tlbnMgPSB7fTtcblxuZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGksIGZ1bmMgPSBjYWxsYmFjaztcbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgfVxuICAgIGlmIChpc051bWJlcihjYWxsYmFjaykpIHtcbiAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgIGFycmF5W2NhbGxiYWNrXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgfVxufVxuXG52YXIgWUVBUiA9IDA7XG52YXIgTU9OVEggPSAxO1xudmFyIERBVEUgPSAyO1xudmFyIEhPVVIgPSAzO1xudmFyIE1JTlVURSA9IDQ7XG52YXIgU0VDT05EID0gNTtcbnZhciBNSUxMSVNFQ09ORCA9IDY7XG52YXIgV0VFSyA9IDc7XG52YXIgV0VFS0RBWSA9IDg7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ1knLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICByZXR1cm4geSA8PSA5OTk5ID8gJycgKyB5IDogJysnICsgeTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCAgNV0sICAgICAgIDAsICd5ZWFyJyk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbi8vIFBSSU9SSVRJRVNcblxuYWRkVW5pdFByaW9yaXR5KCd5ZWFyJywgMSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignWScsICAgICAgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignWVlZWScsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuYWRkUmVnZXhUb2tlbignWVlZWVknLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG5hZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbn0pO1xuYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG59XG5cbmZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbn1cblxuLy8gSE9PS1NcblxuaG9va3MucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xufTtcblxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbmZ1bmN0aW9uIGdldElzTGVhcFllYXIgKCkge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbn1cblxuZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0IChtb20sIHVuaXQpIHtcbiAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpIDogTmFOO1xufVxuXG5mdW5jdGlvbiBzZXQkMSAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgIGlmIChtb20uaXNWYWxpZCgpICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHVuaXQgPT09ICdGdWxsWWVhcicgJiYgaXNMZWFwWWVhcihtb20ueWVhcigpKSAmJiBtb20ubW9udGgoKSA9PT0gMSAmJiBtb20uZGF0ZSgpID09PSAyOSkge1xuICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlLCBtb20ubW9udGgoKSwgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIHN0cmluZ0dldCAodW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5cbmZ1bmN0aW9uIHN0cmluZ1NldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW9yaXRpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIG1vZChuLCB4KSB7XG4gICAgcmV0dXJuICgobiAlIHgpICsgeCkgJSB4O1xufVxuXG52YXIgaW5kZXhPZjtcblxuaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xufSBlbHNlIHtcbiAgICBpbmRleE9mID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgLy8gSSBrbm93XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICBpZiAoaXNOYU4oeWVhcikgfHwgaXNOYU4obW9udGgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHZhciBtb2RNb250aCA9IG1vZChtb250aCwgMTIpO1xuICAgIHllYXIgKz0gKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG4gICAgcmV0dXJuIG1vZE1vbnRoID09PSAxID8gKGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4KSA6ICgzMSAtIG1vZE1vbnRoICUgNyAlIDIpO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzKHRoaXMsIGZvcm1hdCk7XG59KTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ21vbnRoJywgJ00nKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ00nLCAgICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ01NTScsICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRSZWdleChpc1N0cmljdCk7XG59KTtcbmFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUubW9udGhzUmVnZXgoaXNTdHJpY3QpO1xufSk7XG5cbmFkZFBhcnNlVG9rZW4oWydNJywgJ01NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xufSk7XG5cbmFkZFBhcnNlVG9rZW4oWydNTU0nLCAnTU1NTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgaWYgKG1vbnRoICE9IG51bGwpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZE1vbnRoID0gaW5wdXQ7XG4gICAgfVxufSk7XG5cbi8vIExPQ0FMRVNcblxudmFyIE1PTlRIU19JTl9GT1JNQVQgPSAvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKStNTU1NPy87XG52YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlTW9udGhzIChtLCBmb3JtYXQpIHtcbiAgICBpZiAoIW0pIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRocyA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNbJ3N0YW5kYWxvbmUnXTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKSA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldIDpcbiAgICAgICAgdGhpcy5fbW9udGhzWyh0aGlzLl9tb250aHMuaXNGb3JtYXQgfHwgTU9OVEhTX0lOX0ZPUk1BVCkudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG5mdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydCAobSwgZm9ybWF0KSB7XG4gICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0IDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0WydzdGFuZGFsb25lJ107XG4gICAgfVxuICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFtNT05USFNfSU5fRk9STUFULnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZShtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IG1vbnRoTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgLy8gdGhpcyBpcyBub3QgdXNlZFxuICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7ICsraSkge1xuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UuY2FsbCh0aGlzLCBtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgfVxuXG4gICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcbiAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXG4gICAgLy8gc2VlIHNvcnRpbmcgaW4gY29tcHV0ZU1vbnRoc1BhcnNlXG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTScgJiYgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBzZXRNb250aCAobW9tLCB2YWx1ZSkge1xuICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgIC8vIE5vIG9wXG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICByZXR1cm4gbW9tO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldERheXNJbk1vbnRoICgpIHtcbiAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG59XG5cbnZhciBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuZnVuY3Rpb24gbW9udGhzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IGRlZmF1bHRNb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNSZWdleDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSAoKSB7XG4gICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgaSwgbW9tO1xuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgfVxuICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8xODEzNDhcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcblxuICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCAmJiBpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcblxuICAgIC8vIHRoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbmZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbn1cblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbmZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgIHJlc1llYXIsIHJlc0RheU9mWWVhcjtcblxuICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICByZXNZZWFyID0geWVhciAtIDE7XG4gICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgIHJlc1llYXIgPSB5ZWFyICsgMTtcbiAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXNZZWFyID0geWVhcjtcbiAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQobW9tLnllYXIoKSwgZG93LCBkb3kpLFxuICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICByZXNXZWVrLCByZXNZZWFyO1xuXG4gICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgIHllYXI6IHJlc1llYXJcbiAgICB9O1xufVxuXG5mdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICByZXR1cm4gKGRheXNJblllYXIoeWVhcikgLSB3ZWVrT2Zmc2V0ICsgd2Vla09mZnNldE5leHQpIC8gNztcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbmFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG5hZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4vLyBQUklPUklUSUVTXG5cbmFkZFVuaXRQcmlvcml0eSgnd2VlaycsIDUpO1xuYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrJywgNSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbigndycsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuLy8gTE9DQUxFU1xuXG5mdW5jdGlvbiBsb2NhbGVXZWVrIChtb20pIHtcbiAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2Vlaztcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrID0ge1xuICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbn07XG5cbmZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG59XG5cbmZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG59XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRJU09XZWVrIChpbnB1dCkge1xuICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG5hZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xuYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbmFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbi8vIFBSSU9SSVRZXG5hZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbmFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla2RheScsIDExKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2UnLCAgICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdkZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNSZWdleChpc1N0cmljdCk7XG59KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgfVxufSk7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG5mdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG5cbiAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9XG5cbiAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KSAlIDcgfHwgNztcbiAgICB9XG4gICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbn1cblxuLy8gTE9DQUxFU1xuXG52YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMgKG0sIGZvcm1hdCkge1xuICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl93ZWVrZGF5cykgPyB0aGlzLl93ZWVrZGF5cyA6XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1snc3RhbmRhbG9uZSddO1xuICAgIH1cbiAgICByZXR1cm4gaXNBcnJheSh0aGlzLl93ZWVrZGF5cykgPyB0aGlzLl93ZWVrZGF5c1ttLmRheSgpXSA6XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzW3RoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLmRheSgpXTtcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcbiAgICByZXR1cm4gKG0pID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyk7XG5mdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgIHJldHVybiAobSkgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzTWluO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSB3ZWVrZGF5TmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2UgKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UkMS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZGQnICYmIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXREYXlPZldlZWsgKGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgfVxuICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGF5O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cbiAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cblxuICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICB9XG59XG5cbnZhciBkZWZhdWx0V2Vla2RheXNSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIHdlZWtkYXlzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIHdlZWtkYXlzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBjb21wdXRlV2Vla2RheXNQYXJzZSAoKSB7XG4gICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIG1pblBpZWNlcyA9IFtdLCBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgIGksIG1vbSwgbWlucCwgc2hvcnRwLCBsb25ncDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgIG1pbnAgPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICBzaG9ydHAgPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgIGxvbmdwID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKTtcbiAgICAgICAgbWluUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICB9XG4gICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgIG1pblBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcblxuICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuZnVuY3Rpb24gaEZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG59XG5cbmZ1bmN0aW9uIGtGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbn1cblxuYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XG5hZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG5hZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbmFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignSG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xufSk7XG5cbmZ1bmN0aW9uIG1lcmlkaWVtICh0b2tlbiwgbG93ZXJjYXNlKSB7XG4gICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIGxvd2VyY2FzZSk7XG4gICAgfSk7XG59XG5cbm1lcmlkaWVtKCdhJywgdHJ1ZSk7XG5tZXJpZGllbSgnQScsIGZhbHNlKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4vLyBQQVJTSU5HXG5cbmZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xufVxuXG5hZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xuYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbmFkZFJlZ2V4VG9rZW4oJ0gnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2snLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuYWRkUmVnZXhUb2tlbignaG1tJywgbWF0Y2gzdG80KTtcbmFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcbmFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG5hZGRSZWdleFRva2VuKCdIbW1zcycsIG1hdGNoNXRvNik7XG5cbmFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIGtJbnB1dCA9IHRvSW50KGlucHV0KTtcbiAgICBhcnJheVtIT1VSXSA9IGtJbnB1dCA9PT0gMjQgPyAwIDoga0lucHV0O1xufSk7XG5hZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbn0pO1xuYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ0htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG59KTtcblxuLy8gTE9DQUxFU1xuXG5mdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG5mdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgfVxufVxuXG5cbi8vIE1PTUVOVFNcblxuLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4vLyBzcGVjaWZpZWQgd2hpY2ggaG91ciBoZSB3YW50cy4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4vLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbi8vIHRoaXMgcnVsZS5cbnZhciBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcblxuLy8gbW9udGhzXG4vLyB3ZWVrXG4vLyB3ZWVrZGF5c1xuLy8gbWVyaWRpZW1cbnZhciBiYXNlQ29uZmlnID0ge1xuICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICBpbnZhbGlkRGF0ZTogZGVmYXVsdEludmFsaWREYXRlLFxuICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxuICAgIHJlbGF0aXZlVGltZTogZGVmYXVsdFJlbGF0aXZlVGltZSxcblxuICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgd2VlazogZGVmYXVsdExvY2FsZVdlZWssXG5cbiAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgd2Vla2RheXNTaG9ydDogZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQsXG5cbiAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZVxufTtcblxuLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xudmFyIGxvY2FsZXMgPSB7fTtcbnZhciBsb2NhbGVGYW1pbGllcyA9IHt9O1xudmFyIGdsb2JhbExvY2FsZTtcblxuZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbn1cblxuLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4vLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxuZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxuICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgIHZhciBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICBhbGlhc2VkUmVxdWlyZSgnLi9sb2NhbGUvJyArIG5hbWUpO1xuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcbi8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4vLyBsb2NhbGUga2V5LlxuZnVuY3Rpb24gZ2V0U2V0R2xvYmFsTG9jYWxlIChrZXksIHZhbHVlcykge1xuICAgIHZhciBkYXRhO1xuICAgIGlmIChrZXkpIHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlcykpIHtcbiAgICAgICAgICAgIGRhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoJ2RlZmluZUxvY2FsZU92ZXJyaWRlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3VzZSBtb21lbnQudXBkYXRlTG9jYWxlKGxvY2FsZU5hbWUsIGNvbmZpZykgdG8gY2hhbmdlICcgK1xuICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAnY29uZmlnKSBzaG91bGQgb25seSBiZSB1c2VkIGZvciBjcmVhdGluZyBhIG5ldyBsb2NhbGUgJyArXG4gICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kZWZpbmUtbG9jYWxlLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsb2NhbGVzW25hbWVdID0gbmV3IExvY2FsZShtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpKTtcblxuICAgICAgICBpZiAobG9jYWxlRmFtaWxpZXNbbmFtZV0pIHtcbiAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVMb2NhbGUoeC5uYW1lLCB4LmNvbmZpZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBsb2NhbGUgQUZURVIgYWxsIGNoaWxkIGxvY2FsZXMgaGF2ZSBiZWVuXG4gICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG5cblxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbG9jYWxlLCB0bXBMb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgIC8vIE1FUkdFXG4gICAgICAgIHRtcExvY2FsZSA9IGxvYWRMb2NhbGUobmFtZSk7XG4gICAgICAgIGlmICh0bXBMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gdG1wTG9jYWxlLl9jb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZTtcblxuICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbn1cblxuLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxuZnVuY3Rpb24gZ2V0TG9jYWxlIChrZXkpIHtcbiAgICB2YXIgbG9jYWxlO1xuXG4gICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICB9XG5cbiAgICBpZiAoIWtleSkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgIH1cblxuICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIGtleSA9IFtrZXldO1xuICAgIH1cblxuICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbn1cblxuZnVuY3Rpb24gbGlzdExvY2FsZXMoKSB7XG4gICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICB2YXIgb3ZlcmZsb3c7XG4gICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgIGFbSE9VUl0gICAgICAgIDwgMCB8fCBhW0hPVVJdICAgICAgICA+IDI0IHx8IChhW0hPVVJdID09PSAyNCAmJiAoYVtNSU5VVEVdICE9PSAwIHx8IGFbU0VDT05EXSAhPT0gMCB8fCBhW01JTExJU0VDT05EXSAhPT0gMCkpID8gSE9VUiA6XG4gICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgIC0xO1xuXG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbmZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgIH1cbiAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG59XG5cbi8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbi8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG5mdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xuICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgZXhwZWN0ZWRXZWVrZGF5LCB5ZWFyVG9Vc2U7XG5cbiAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcbiAgICB9XG5cbiAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgIT0gbnVsbCkge1xuICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHwgY29uZmlnLl9kYXlPZlllYXIgPT09IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgfVxuXG4gICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSAoY29uZmlnLl9hW2ldID09IG51bGwpID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgIGlmIChjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDApIHtcbiAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICB9XG5cbiAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgIGV4cGVjdGVkV2Vla2RheSA9IGNvbmZpZy5fdXNlVVRDID8gY29uZmlnLl9kLmdldFVUQ0RheSgpIDogY29uZmlnLl9kLmdldERheSgpO1xuXG4gICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBtaXNtYXRjaGluZyBkYXkgb2Ygd2Vla1xuICAgIGlmIChjb25maWcuX3cgJiYgdHlwZW9mIGNvbmZpZy5fdy5kICE9PSAndW5kZWZpbmVkJyAmJiBjb25maWcuX3cuZCAhPT0gZXhwZWN0ZWRXZWVrZGF5KSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93O1xuXG4gICAgdyA9IGNvbmZpZy5fdztcbiAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgIGRvdyA9IDE7XG4gICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXIpO1xuICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgIGlmICh3ZWVrZGF5IDwgMSB8fCB3ZWVrZGF5ID4gNykge1xuICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgIHZhciBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XG5cbiAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIGN1cldlZWsueWVhcik7XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIGN1cldlZWsud2Vlayk7XG5cbiAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDAgfHwgd2Vla2RheSA+IDYpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla3MgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XG4gICAgfVxufVxuXG4vLyBpc28gODYwMSByZWdleFxuLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG52YXIgZXh0ZW5kZWRJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86XFxkXFxkLVxcZFxcZHxXXFxkXFxkLVxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OjpcXGRcXGQoPzo6XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcbnZhciBiYXNpY0lzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KSg/OlxcZFxcZFxcZFxcZHxXXFxkXFxkXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86XFxkXFxkKD86XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcblxudmFyIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy87XG5cbnZhciBpc29EYXRlcyA9IFtcbiAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuXTtcblxuLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xudmFyIGlzb1RpbWVzID0gW1xuICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcbiAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXG4gICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgIFsnSEgnLCAvXFxkXFxkL11cbl07XG5cbnZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4vLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuZnVuY3Rpb24gY29uZmlnRnJvbUlTTyhjb25maWcpIHtcbiAgICB2YXIgaSwgbCxcbiAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICBhbGxvd1RpbWUsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgfVxufVxuXG4vLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG52YXIgcmZjMjgyMiA9IC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksP1xccyk/KFxcZHsxLDJ9KVxccyhKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoXFxkezIsNH0pXFxzKFxcZFxcZCk6KFxcZFxcZCkoPzo6KFxcZFxcZCkpP1xccyg/OihVVHxHTVR8W0VDTVBdW1NEXVQpfChbWnpdKXwoWystXVxcZHs0fSkpJC87XG5cbmZ1bmN0aW9uIGV4dHJhY3RGcm9tUkZDMjgyMlN0cmluZ3MoeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpIHtcbiAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpLFxuICAgICAgICBwYXJzZUludChkYXlTdHIsIDEwKSxcbiAgICAgICAgcGFyc2VJbnQoaG91clN0ciwgMTApLFxuICAgICAgICBwYXJzZUludChtaW51dGVTdHIsIDEwKVxuICAgIF07XG5cbiAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHNlY29uZFN0ciwgMTApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSB7XG4gICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgaWYgKHllYXIgPD0gNDkpIHtcbiAgICAgICAgcmV0dXJuIDIwMDAgKyB5ZWFyO1xuICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgcmV0dXJuIDE5MDAgKyB5ZWFyO1xuICAgIH1cbiAgICByZXR1cm4geWVhcjtcbn1cblxuZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXFwoW14pXSpcXCl8W1xcblxcdF0vZywgJyAnKS5yZXBsYWNlKC8oXFxzXFxzKykvZywgJyAnKS50cmltKCk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrV2Vla2RheSh3ZWVrZGF5U3RyLCBwYXJzZWRJbnB1dCwgY29uZmlnKSB7XG4gICAgaWYgKHdlZWtkYXlTdHIpIHtcbiAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGUgdmFuaWxsYSBKUyBEYXRlIG9iamVjdCB3aXRoIGFuIGluZGVwZW50ZW50IGRheS1vZi13ZWVrIGNoZWNrLlxuICAgICAgICB2YXIgd2Vla2RheVByb3ZpZGVkID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSxcbiAgICAgICAgICAgIHdlZWtkYXlBY3R1YWwgPSBuZXcgRGF0ZShwYXJzZWRJbnB1dFswXSwgcGFyc2VkSW5wdXRbMV0sIHBhcnNlZElucHV0WzJdKS5nZXREYXkoKTtcbiAgICAgICAgaWYgKHdlZWtkYXlQcm92aWRlZCAhPT0gd2Vla2RheUFjdHVhbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG52YXIgb2JzT2Zmc2V0cyA9IHtcbiAgICBVVDogMCxcbiAgICBHTVQ6IDAsXG4gICAgRURUOiAtNCAqIDYwLFxuICAgIEVTVDogLTUgKiA2MCxcbiAgICBDRFQ6IC01ICogNjAsXG4gICAgQ1NUOiAtNiAqIDYwLFxuICAgIE1EVDogLTYgKiA2MCxcbiAgICBNU1Q6IC03ICogNjAsXG4gICAgUERUOiAtNyAqIDYwLFxuICAgIFBTVDogLTggKiA2MFxufTtcblxuZnVuY3Rpb24gY2FsY3VsYXRlT2Zmc2V0KG9ic09mZnNldCwgbWlsaXRhcnlPZmZzZXQsIG51bU9mZnNldCkge1xuICAgIGlmIChvYnNPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgICB9IGVsc2UgaWYgKG1pbGl0YXJ5T2Zmc2V0KSB7XG4gICAgICAgIC8vIHRoZSBvbmx5IGFsbG93ZWQgbWlsaXRhcnkgdHogaXMgWlxuICAgICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaG0gPSBwYXJzZUludChudW1PZmZzZXQsIDEwKTtcbiAgICAgICAgdmFyIG0gPSBobSAlIDEwMCwgaCA9IChobSAtIG0pIC8gMTAwO1xuICAgICAgICByZXR1cm4gaCAqIDYwICsgbTtcbiAgICB9XG59XG5cbi8vIGRhdGUgYW5kIHRpbWUgZnJvbSByZWYgMjgyMiBmb3JtYXRcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZykge1xuICAgIHZhciBtYXRjaCA9IHJmYzI4MjIuZXhlYyhwcmVwcm9jZXNzUkZDMjgyMihjb25maWcuX2kpKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIHBhcnNlZEFycmF5ID0gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhtYXRjaFs0XSwgbWF0Y2hbM10sIG1hdGNoWzJdLCBtYXRjaFs1XSwgbWF0Y2hbNl0sIG1hdGNoWzddKTtcbiAgICAgICAgaWYgKCFjaGVja1dlZWtkYXkobWF0Y2hbMV0sIHBhcnNlZEFycmF5LCBjb25maWcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2EgPSBwYXJzZWRBcnJheTtcbiAgICAgICAgY29uZmlnLl90em0gPSBjYWxjdWxhdGVPZmZzZXQobWF0Y2hbOF0sIG1hdGNoWzldLCBtYXRjaFsxMF0pO1xuXG4gICAgICAgIGNvbmZpZy5fZCA9IGNyZWF0ZVVUQ0RhdGUuYXBwbHkobnVsbCwgY29uZmlnLl9hKTtcbiAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbi8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG5mdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcblxuICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEZpbmFsIGF0dGVtcHQsIHVzZSBJbnB1dCBGYWxsYmFja1xuICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG59XG5cbmhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICd2YWx1ZSBwcm92aWRlZCBpcyBub3QgaW4gYSByZWNvZ25pemVkIFJGQzI4MjIgb3IgSVNPIGZvcm1hdC4gbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUoKSwgJyArXG4gICAgJ3doaWNoIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgYWxsIGJyb3dzZXJzIGFuZCB2ZXJzaW9ucy4gTm9uIFJGQzI4MjIvSVNPIGRhdGUgZm9ybWF0cyBhcmUgJyArXG4gICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYW4gdXBjb21pbmcgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICdodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2pzLWRhdGUvIGZvciBtb3JlIGluZm8uJyxcbiAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgfVxuKTtcblxuLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuaG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIFJGQyAyODIyIGZvcm1cbmhvb2tzLlJGQ18yODIyID0gZnVuY3Rpb24gKCkge307XG5cbi8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGFub3RoZXIgcGFydCBvZiB0aGUgY3JlYXRpb24gZmxvdyB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcHNcbiAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5JU09fODYwMSkge1xuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuUkZDXzI4MjIpIHtcbiAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25maWcuX2EgPSBbXTtcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXG4gICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xuXG4gICAgdG9rZW5zID0gZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4nLCB0b2tlbiwgJ3BhcnNlZElucHV0JywgcGFyc2VkSW5wdXQsXG4gICAgICAgIC8vICAgICAgICAgJ3JlZ2V4JywgZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKTtcbiAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2Uoc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoKTtcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbid0IHBhcnNlIGlmIGl0J3Mgbm90IGEga25vd24gdG9rZW5cbiAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgIH1cblxuICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA+IDApIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5wYXJzZWREYXRlUGFydHMgPSBjb25maWcuX2Euc2xpY2UoMCk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChjb25maWcuX2xvY2FsZSwgY29uZmlnLl9hW0hPVVJdLCBjb25maWcuX21lcmlkaWVtKTtcblxuICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbn1cblxuXG5mdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICB2YXIgaXNQbTtcblxuICAgIGlmIChtZXJpZGllbSA9PSBudWxsKSB7XG4gICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgfVxuICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgIH0gZWxzZSBpZiAobG9jYWxlLmlzUE0gIT0gbnVsbCkge1xuICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICBpZiAoaXNQbSAmJiBob3VyIDwgMTIpIHtcbiAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1BtICYmIGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgfVxufVxuXG4vLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBhcnJheSBvZiBmb3JtYXQgc3RyaW5nc1xuZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICBiZXN0TW9tZW50LFxuXG4gICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICBpLFxuICAgICAgICBjdXJyZW50U2NvcmU7XG5cbiAgICBpZiAoY29uZmlnLl9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgfVxuICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgIGlmIChzY29yZVRvQmVhdCA9PSBudWxsIHx8IGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbn1cblxuZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSk7XG4gICAgY29uZmlnLl9hID0gbWFwKFtpLnllYXIsIGkubW9udGgsIGkuZGF5IHx8IGkuZGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgfSk7XG5cbiAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyAoY29uZmlnKSB7XG4gICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICBpZiAocmVzLl9uZXh0RGF5KSB7XG4gICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlQ29uZmlnIChjb25maWcpIHtcbiAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XG5cbiAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgIH1cblxuICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgfSAgZWxzZSB7XG4gICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgIH1cblxuICAgIGlmICghaXNWYWxpZChjb25maWcpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZztcbn1cblxuZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgaXNVVEMpIHtcbiAgICB2YXIgYyA9IHt9O1xuXG4gICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHN0cmljdCA9IGxvY2FsZTtcbiAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICgoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxuICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgYy5faSA9IGlucHV0O1xuICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBmYWxzZSk7XG59XG5cbnZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICB9XG4gICAgfVxuKTtcblxudmFyIHByb3RvdHlwZU1heCA9IGRlcHJlY2F0ZShcbiAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuXG4vLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxuLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuLy9cbi8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2Vcbi8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG5mdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICB2YXIgcmVzLCBpO1xuICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgIH1cbiAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xuICAgIH1cbiAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xuICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBUT0RPOiBVc2UgW10uc29ydCBpbnN0ZWFkP1xuZnVuY3Rpb24gbWluICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG59XG5cbmZ1bmN0aW9uIG1heCAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG59XG5cbnZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICsobmV3IERhdGUoKSk7XG59O1xuXG52YXIgb3JkZXJpbmcgPSBbJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCAnbWlsbGlzZWNvbmQnXTtcblxuZnVuY3Rpb24gaXNEdXJhdGlvblZhbGlkKG0pIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbSkge1xuICAgICAgICBpZiAoIShpbmRleE9mLmNhbGwob3JkZXJpbmcsIGtleSkgIT09IC0xICYmIChtW2tleV0gPT0gbnVsbCB8fCAhaXNOYU4obVtrZXldKSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5pdEhhc0RlY2ltYWwgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChtW29yZGVyaW5nW2ldXSkge1xuICAgICAgICAgICAgaWYgKHVuaXRIYXNEZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvbmx5IGFsbG93IG5vbi1pbnRlZ2VycyBmb3Igc21hbGxlc3QgdW5pdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobVtvcmRlcmluZ1tpXV0pICE9PSB0b0ludChtW29yZGVyaW5nW2ldXSkpIHtcbiAgICAgICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZCQxKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnZhbGlkJDEoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKE5hTik7XG59XG5cbmZ1bmN0aW9uIER1cmF0aW9uIChkdXJhdGlvbikge1xuICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxuICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgdGhpcy5faXNWYWxpZCA9IGlzRHVyYXRpb25WYWxpZChub3JtYWxpemVkSW5wdXQpO1xuXG4gICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICB0aGlzLl9taWxsaXNlY29uZHMgPSArbWlsbGlzZWNvbmRzICtcbiAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICBob3VycyAqIDEwMDAgKiA2MCAqIDYwOyAvL3VzaW5nIDEwMDAgKiA2MCAqIDYwIGluc3RlYWQgb2YgMzZlNSB0byBhdm9pZCBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMgaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzI5NzhcbiAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgd2Vla3MgKiA3O1xuICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xuICAgICAgICBxdWFydGVycyAqIDMgK1xuICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgdGhpcy5fbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG5cbiAgICB0aGlzLl9idWJibGUoKTtcbn1cblxuZnVuY3Rpb24gaXNEdXJhdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xufVxuXG5mdW5jdGlvbiBhYnNSb3VuZCAobnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoLTEgKiBudW1iZXIpICogLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcbiAgICB9XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcbiAgICB9KTtcbn1cblxub2Zmc2V0KCdaJywgJzonKTtcbm9mZnNldCgnWlonLCAnJyk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignWicsICBtYXRjaFNob3J0T2Zmc2V0KTtcbmFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG5hZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbi8vIHRpbWV6b25lIGNodW5rZXJcbi8vICcrMTA6MDAnID4gWycxMCcsICAnMDAnXVxuLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG52YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbmZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcobWF0Y2hlciwgc3RyaW5nKSB7XG4gICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKTtcblxuICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgIHZhciBwYXJ0cyAgID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICB2YXIgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICByZXR1cm4gbWludXRlcyA9PT0gMCA/XG4gICAgICAwIDpcbiAgICAgIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG59XG5cbi8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG5mdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgdmFyIHJlcywgZGlmZjtcbiAgICBpZiAobW9kZWwuX2lzVVRDKSB7XG4gICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyBpbnB1dC52YWx1ZU9mKCkgOiBjcmVhdGVMb2NhbChpbnB1dCkudmFsdWVPZigpKSAtIHJlcy52YWx1ZU9mKCk7XG4gICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgcmVzLl9kLnNldFRpbWUocmVzLl9kLnZhbHVlT2YoKSArIGRpZmYpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0KS5sb2NhbCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldCAobSkge1xuICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xufVxuXG4vLyBIT09LU1xuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4vLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbmhvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBNT01FTlRTXG5cbi8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxuLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbi8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbi8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cbi8vXG4vLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbi8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxuLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4vLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxuZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSwga2VlcE1pbnV0ZXMpIHtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgIGxvY2FsQWRqdXN0O1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2ICYmICFrZWVwTWludXRlcykge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2V0Wm9uZSAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG59XG5cbmZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQgKCkge1xuICAgIGlmICh0aGlzLl90em0gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdFpvbmUgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoT2Zmc2V0LCB0aGlzLl9pKTtcbiAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRab25lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5wdXQgPSBpbnB1dCA/IGNyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKSA6IDA7XG5cbiAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWUgKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCAoKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9pc0RTVFNoaWZ0ZWQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB7fTtcblxuICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgYyA9IHByZXBhcmVDb25maWcoYyk7XG5cbiAgICBpZiAoYy5fYSkge1xuICAgICAgICB2YXIgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZVVUQyhjLl9hKSA6IGNyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xufVxuXG5mdW5jdGlvbiBpc0xvY2FsICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNVdGNPZmZzZXQgKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVXRjICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbn1cblxuLy8gQVNQLk5FVCBqc29uIGRhdGUgZm9ybWF0IHJlZ2V4XG52YXIgYXNwTmV0UmVnZXggPSAvXihcXC18XFwrKT8oPzooXFxkKilbLiBdKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKykoXFwuXFxkKik/KT8kLztcblxuLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbi8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbi8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbnZhciBpc29SZWdleCA9IC9eKC18XFwrKT9QKD86KFstK10/WzAtOSwuXSopWSk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopVyk/KD86KFstK10/WzAtOSwuXSopRCk/KD86VCg/OihbLStdP1swLTksLl0qKUgpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVMpPyk/JC87XG5cbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uIChpbnB1dCwga2V5KSB7XG4gICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgc2lnbixcbiAgICAgICAgcmV0LFxuICAgICAgICBkaWZmUmVzO1xuXG4gICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgbXMgOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgIE0gIDogaW5wdXQuX21vbnRoc1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgIHkgIDogMCxcbiAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIG0gIDogdG9JbnQobWF0Y2hbTUlOVVRFXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIG1zIDogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IChtYXRjaFsxXSA9PT0gJysnKSA/IDEgOiAxO1xuICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgIHkgOiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICBNIDogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgdyA6IHBhcnNlSXNvKG1hdGNoWzRdLCBzaWduKSxcbiAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICBoIDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgbSA6IHBhcnNlSXNvKG1hdGNoWzddLCBzaWduKSxcbiAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbilcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09IG51bGwpIHsvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcbiAgICAgICAgZGlmZlJlcyA9IG1vbWVudHNEaWZmZXJlbmNlKGNyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLCBjcmVhdGVMb2NhbChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICB9XG5cbiAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59XG5cbmNyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuY3JlYXRlRHVyYXRpb24uaW52YWxpZCA9IGNyZWF0ZUludmFsaWQkMTtcblxuZnVuY3Rpb24gcGFyc2VJc28gKGlucCwgc2lnbikge1xuICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG59XG5cbmZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICB2YXIgcmVzID0ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcblxuICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcbiAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgIGlmIChiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykuaXNBZnRlcihvdGhlcikpIHtcbiAgICAgICAgLS1yZXMubW9udGhzO1xuICAgIH1cblxuICAgIHJlcy5taWxsaXNlY29uZHMgPSArb3RoZXIgLSArKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKSk7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBtb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgIHZhciByZXM7XG4gICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcbiAgICB9XG5cbiAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XG4gICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBUT0RPOiByZW1vdmUgJ25hbWUnIGFyZyBhZnRlciBkZXByZWNhdGlvbiBpcyByZW1vdmVkXG5mdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgIHZhciBkdXIsIHRtcDtcbiAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUobmFtZSwgJ21vbWVudCgpLicgKyBuYW1lICArICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArIG5hbWUgKyAnKG51bWJlciwgcGVyaW9kKS4gJyArXG4gICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gK3ZhbCA6IHZhbDtcbiAgICAgICAgZHVyID0gY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGFkZFN1YnRyYWN0IChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgIGRheXMgPSBhYnNSb3VuZChkdXJhdGlvbi5fZGF5cyksXG4gICAgICAgIG1vbnRocyA9IGFic1JvdW5kKGR1cmF0aW9uLl9tb250aHMpO1xuXG4gICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgIC8vIE5vIG9wXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICBpZiAobW9udGhzKSB7XG4gICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgfVxuICAgIGlmIChkYXlzKSB7XG4gICAgICAgIHNldCQxKG1vbSwgJ0RhdGUnLCBnZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICB9XG4gICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgIH1cbiAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICB9XG59XG5cbnZhciBhZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbnZhciBzdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuZnVuY3Rpb24gZ2V0Q2FsZW5kYXJGb3JtYXQobXlNb21lbnQsIG5vdykge1xuICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgcmV0dXJuIGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxuICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XG4gICAgICAgICAgICBkaWZmIDwgMCA/ICdsYXN0RGF5JyA6XG4gICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XG4gICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XG4gICAgICAgICAgICBkaWZmIDwgNyA/ICduZXh0V2VlaycgOiAnc2FtZUVsc2UnO1xufVxuXG5mdW5jdGlvbiBjYWxlbmRhciQxICh0aW1lLCBmb3JtYXRzKSB7XG4gICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSBsb2NhbC91dGMvb2Zmc2V0IG9yIG5vdC5cbiAgICB2YXIgbm93ID0gdGltZSB8fCBjcmVhdGVMb2NhbCgpLFxuICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgZm9ybWF0ID0gaG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnO1xuXG4gICAgdmFyIG91dHB1dCA9IGZvcm1hdHMgJiYgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKSA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdykgOiBmb3JtYXRzW2Zvcm1hdF0pO1xuXG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0KG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGNyZWF0ZUxvY2FsKG5vdykpKTtcbn1cblxuZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xufVxuXG5mdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKCFpc1VuZGVmaW5lZCh1bml0cykgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzQmV0d2VlbiAoZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgIGluY2x1c2l2aXR5ID0gaW5jbHVzaXZpdHkgfHwgJygpJztcbiAgICByZXR1cm4gKGluY2x1c2l2aXR5WzBdID09PSAnKCcgPyB0aGlzLmlzQWZ0ZXIoZnJvbSwgdW5pdHMpIDogIXRoaXMuaXNCZWZvcmUoZnJvbSwgdW5pdHMpKSAmJlxuICAgICAgICAoaW5jbHVzaXZpdHlbMV0gPT09ICcpJyA/IHRoaXMuaXNCZWZvcmUodG8sIHVuaXRzKSA6ICF0aGlzLmlzQWZ0ZXIodG8sIHVuaXRzKSk7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgaW5wdXRNcztcbiAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzIHx8ICdtaWxsaXNlY29uZCcpO1xuICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lT3JBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0FmdGVyKGlucHV0LHVuaXRzKTtcbn1cblxuZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNCZWZvcmUoaW5wdXQsdW5pdHMpO1xufVxuXG5mdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICB2YXIgdGhhdCxcbiAgICAgICAgem9uZURlbHRhLFxuICAgICAgICBkZWx0YSwgb3V0cHV0O1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpO1xuXG4gICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XG5cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgY2FzZSAneWVhcic6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDEyOyBicmVhaztcbiAgICAgICAgY2FzZSAnbW9udGgnOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7IGJyZWFrO1xuICAgICAgICBjYXNlICdxdWFydGVyJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMzsgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAxZTM7IGJyZWFrOyAvLyAxMDAwXG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyA2ZTQ7IGJyZWFrOyAvLyAxMDAwICogNjBcbiAgICAgICAgY2FzZSAnaG91cic6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAzNmU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgY2FzZSAnZGF5Jzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDg2NGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICBjYXNlICd3ZWVrJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDYwNDhlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgIGRlZmF1bHQ6IG91dHB1dCA9IHRoaXMgLSB0aGF0O1xuICAgIH1cblxuICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbn1cblxuZnVuY3Rpb24gbW9udGhEaWZmIChhLCBiKSB7XG4gICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcbiAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xuXG4gICAgaWYgKGIgLSBhbmNob3IgPCAwKSB7XG4gICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yIC0gYW5jaG9yMik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICB9XG5cbiAgICAvL2NoZWNrIGZvciBuZWdhdGl2ZSB6ZXJvLCByZXR1cm4gemVybyBpZiBuZWdhdGl2ZSB6ZXJvXG4gICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG59XG5cbmhvb2tzLmRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onO1xuaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA9ICdZWVlZLU1NLUREVEhIOm1tOnNzW1pdJztcblxuZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbn1cblxuZnVuY3Rpb24gdG9JU09TdHJpbmcoa2VlcE9mZnNldCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciB1dGMgPSBrZWVwT2Zmc2V0ICE9PSB0cnVlO1xuICAgIHZhciBtID0gdXRjID8gdGhpcy5jbG9uZSgpLnV0YygpIDogdGhpcztcbiAgICBpZiAobS55ZWFyKCkgPCAwIHx8IG0ueWVhcigpID4gOTk5OSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sIHV0YyA/ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onKTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24oRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpKSB7XG4gICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgIGlmICh1dGMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5fZC52YWx1ZU9mKCkpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgnWicsIGZvcm1hdE1vbWVudChtLCAnWicpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sIHV0YyA/ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWicpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGh1bWFuIHJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgbW9tZW50IHRoYXQgY2FuXG4gKiBhbHNvIGJlIGV2YWx1YXRlZCB0byBnZXQgYSBuZXcgbW9tZW50IHdoaWNoIGlzIHRoZSBzYW1lXG4gKlxuICogQGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0L2RvY3MvYXBpL3V0aWwuaHRtbCN1dGlsX2N1c3RvbV9pbnNwZWN0X2Z1bmN0aW9uX29uX29iamVjdHNcbiAqL1xuZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgIH1cbiAgICB2YXIgZnVuYyA9ICdtb21lbnQnO1xuICAgIHZhciB6b25lID0gJyc7XG4gICAgaWYgKCF0aGlzLmlzTG9jYWwoKSkge1xuICAgICAgICBmdW5jID0gdGhpcy51dGNPZmZzZXQoKSA9PT0gMCA/ICdtb21lbnQudXRjJyA6ICdtb21lbnQucGFyc2Vab25lJztcbiAgICAgICAgem9uZSA9ICdaJztcbiAgICB9XG4gICAgdmFyIHByZWZpeCA9ICdbJyArIGZ1bmMgKyAnKFwiXSc7XG4gICAgdmFyIHllYXIgPSAoMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5KSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgIHZhciBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgIHZhciBzdWZmaXggPSB6b25lICsgJ1tcIildJztcblxuICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XG4gICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKSA/IGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgOiBob29rcy5kZWZhdWx0Rm9ybWF0O1xuICAgIH1cbiAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xufVxuXG5mdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHt0bzogdGhpcywgZnJvbTogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbShjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbn1cblxuZnVuY3Rpb24gdG8gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oe2Zyb206IHRoaXMsIHRvOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRvTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgcmV0dXJuIHRoaXMudG8oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG59XG5cbi8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbi8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbmZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuZXdMb2NhbGVEYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZURhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG52YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxuICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbik7XG5cbmZ1bmN0aW9uIGxvY2FsZURhdGEgKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0T2YgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgLy8gdGhlIGZvbGxvd2luZyBzd2l0Y2ggaW50ZW50aW9uYWxseSBvbWl0cyBicmVhayBrZXl3b3Jkc1xuICAgIC8vIHRvIHV0aWxpemUgZmFsbGluZyB0aHJvdWdoIHRoZSBjYXNlcy5cbiAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgdGhpcy5tb250aCgwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIHRoaXMuZGF0ZSgxKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgIHRoaXMuaG91cnMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgdGhpcy5taW51dGVzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgdGhpcy5zZWNvbmRzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgdGhpcy5taWxsaXNlY29uZHMoMCk7XG4gICAgfVxuXG4gICAgLy8gd2Vla3MgYXJlIGEgc3BlY2lhbCBjYXNlXG4gICAgaWYgKHVuaXRzID09PSAnd2VlaycpIHtcbiAgICAgICAgdGhpcy53ZWVrZGF5KDApO1xuICAgIH1cbiAgICBpZiAodW5pdHMgPT09ICdpc29XZWVrJykge1xuICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XG4gICAgfVxuXG4gICAgLy8gcXVhcnRlcnMgYXJlIGFsc28gc3BlY2lhbFxuICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgIHRoaXMubW9udGgoTWF0aC5mbG9vcih0aGlzLm1vbnRoKCkgLyAzKSAqIDMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBlbmRPZiAodW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyAnZGF0ZScgaXMgYW4gYWxpYXMgZm9yICdkYXknLCBzbyBpdCBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyBzdWNoLlxuICAgIGlmICh1bml0cyA9PT0gJ2RhdGUnKSB7XG4gICAgICAgIHVuaXRzID0gJ2RheSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RhcnRPZih1bml0cykuYWRkKDEsICh1bml0cyA9PT0gJ2lzb1dlZWsnID8gJ3dlZWsnIDogdW5pdHMpKS5zdWJ0cmFjdCgxLCAnbXMnKTtcbn1cblxuZnVuY3Rpb24gdmFsdWVPZiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2QudmFsdWVPZigpIC0gKCh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMCk7XG59XG5cbmZ1bmN0aW9uIHVuaXggKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XG59XG5cbmZ1bmN0aW9uIHRvRGF0ZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbn1cblxuZnVuY3Rpb24gdG9BcnJheSAoKSB7XG4gICAgdmFyIG0gPSB0aGlzO1xuICAgIHJldHVybiBbbS55ZWFyKCksIG0ubW9udGgoKSwgbS5kYXRlKCksIG0uaG91cigpLCBtLm1pbnV0ZSgpLCBtLnNlY29uZCgpLCBtLm1pbGxpc2Vjb25kKCldO1xufVxuXG5mdW5jdGlvbiB0b09iamVjdCAoKSB7XG4gICAgdmFyIG0gPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgIGRhdGU6IG0uZGF0ZSgpLFxuICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgc2Vjb25kczogbS5zZWNvbmRzKCksXG4gICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgLy8gbmV3IERhdGUoTmFOKS50b0pTT04oKSA9PT0gbnVsbFxuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMudG9JU09TdHJpbmcoKSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWQkMiAoKSB7XG4gICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNpbmdGbGFncyAoKSB7XG4gICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZEF0ICgpIHtcbiAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xufVxuXG5mdW5jdGlvbiBjcmVhdGlvbkRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgIGZvcm1hdDogdGhpcy5fZixcbiAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgc3RyaWN0OiB0aGlzLl9zdHJpY3RcbiAgICB9O1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbn0pO1xuXG5mdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xufVxuXG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbmFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAgJ2lzb1dlZWtZZWFyJyk7XG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbmFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCd3ZWVrWWVhcicsIDEpO1xuYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignRycsICAgICAgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignR0cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignZ2cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuYWRkUmVnZXhUb2tlbignZ2dnZycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuYWRkUmVnZXhUb2tlbignR0dHR0cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG5hZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XG59KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICB3ZWVrW3Rva2VuXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbn0pO1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldFdlZWtZZWFyIChpbnB1dCkge1xuICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhciAoaW5wdXQpIHtcbiAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgaW5wdXQsIHRoaXMuaXNvV2VlaygpLCB0aGlzLmlzb1dlZWtkYXkoKSwgMSwgNCk7XG59XG5cbmZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyICgpIHtcbiAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xufVxuXG5mdW5jdGlvbiBnZXRXZWVrc0luWWVhciAoKSB7XG4gICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG59XG5cbmZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3ZWVrc1RhcmdldCA9IHdlZWtzSW5ZZWFyKGlucHV0LCBkb3csIGRveSk7XG4gICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcbiAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKGRheU9mWWVhckRhdGEueWVhciwgMCwgZGF5T2ZZZWFyRGF0YS5kYXlPZlllYXIpO1xuXG4gICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgIHRoaXMuZGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xufSk7XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0UXVhcnRlciAoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuLy8gUFJJT1JPSVRZXG5hZGRVbml0UHJpb3JpdHkoJ2RhdGUnLCA5KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdEJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgcmV0dXJuIGlzU3RyaWN0ID9cbiAgICAgIChsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2UpIDpcbiAgICAgIGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQ7XG59KTtcblxuYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG5hZGRQYXJzZVRva2VuKCdEbycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0pO1xufSk7XG5cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ0RERCcsIFsnRERERCcsIDNdLCAnREREbycsICdkYXlPZlllYXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuLy8gUFJJT1JJVFlcbmFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignREREJywgIG1hdGNoMXRvMyk7XG5hZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbmFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyIChpbnB1dCkge1xuICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSBkYXlPZlllYXIpLCAnZCcpO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ21pbnV0ZScsIDE0KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdtJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnc2Vjb25kJywgMTUpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ3MnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTJywgM10sIDAsICdtaWxsaXNlY29uZCcpO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbn0pO1xuXG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ21pbGxpc2Vjb25kJywgMTYpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ1MnLCAgICBtYXRjaDF0bzMsIG1hdGNoMSk7XG5hZGRSZWdleFRva2VuKCdTUycsICAgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxudmFyIHRva2VuO1xuZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG59XG5cbmZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbn1cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCd6JywgIDAsIDAsICd6b25lQWJicicpO1xuYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0Wm9uZUFiYnIgKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG59XG5cbmZ1bmN0aW9uIGdldFpvbmVOYW1lICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG59XG5cbnZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbnByb3RvLmFkZCAgICAgICAgICAgICAgID0gYWRkO1xucHJvdG8uY2FsZW5kYXIgICAgICAgICAgPSBjYWxlbmRhciQxO1xucHJvdG8uY2xvbmUgICAgICAgICAgICAgPSBjbG9uZTtcbnByb3RvLmRpZmYgICAgICAgICAgICAgID0gZGlmZjtcbnByb3RvLmVuZE9mICAgICAgICAgICAgID0gZW5kT2Y7XG5wcm90by5mb3JtYXQgICAgICAgICAgICA9IGZvcm1hdDtcbnByb3RvLmZyb20gICAgICAgICAgICAgID0gZnJvbTtcbnByb3RvLmZyb21Ob3cgICAgICAgICAgID0gZnJvbU5vdztcbnByb3RvLnRvICAgICAgICAgICAgICAgID0gdG87XG5wcm90by50b05vdyAgICAgICAgICAgICA9IHRvTm93O1xucHJvdG8uZ2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdHZXQ7XG5wcm90by5pbnZhbGlkQXQgICAgICAgICA9IGludmFsaWRBdDtcbnByb3RvLmlzQWZ0ZXIgICAgICAgICAgID0gaXNBZnRlcjtcbnByb3RvLmlzQmVmb3JlICAgICAgICAgID0gaXNCZWZvcmU7XG5wcm90by5pc0JldHdlZW4gICAgICAgICA9IGlzQmV0d2VlbjtcbnByb3RvLmlzU2FtZSAgICAgICAgICAgID0gaXNTYW1lO1xucHJvdG8uaXNTYW1lT3JBZnRlciAgICAgPSBpc1NhbWVPckFmdGVyO1xucHJvdG8uaXNTYW1lT3JCZWZvcmUgICAgPSBpc1NhbWVPckJlZm9yZTtcbnByb3RvLmlzVmFsaWQgICAgICAgICAgID0gaXNWYWxpZCQyO1xucHJvdG8ubGFuZyAgICAgICAgICAgICAgPSBsYW5nO1xucHJvdG8ubG9jYWxlICAgICAgICAgICAgPSBsb2NhbGU7XG5wcm90by5sb2NhbGVEYXRhICAgICAgICA9IGxvY2FsZURhdGE7XG5wcm90by5tYXggICAgICAgICAgICAgICA9IHByb3RvdHlwZU1heDtcbnByb3RvLm1pbiAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWluO1xucHJvdG8ucGFyc2luZ0ZsYWdzICAgICAgPSBwYXJzaW5nRmxhZ3M7XG5wcm90by5zZXQgICAgICAgICAgICAgICA9IHN0cmluZ1NldDtcbnByb3RvLnN0YXJ0T2YgICAgICAgICAgID0gc3RhcnRPZjtcbnByb3RvLnN1YnRyYWN0ICAgICAgICAgID0gc3VidHJhY3Q7XG5wcm90by50b0FycmF5ICAgICAgICAgICA9IHRvQXJyYXk7XG5wcm90by50b09iamVjdCAgICAgICAgICA9IHRvT2JqZWN0O1xucHJvdG8udG9EYXRlICAgICAgICAgICAgPSB0b0RhdGU7XG5wcm90by50b0lTT1N0cmluZyAgICAgICA9IHRvSVNPU3RyaW5nO1xucHJvdG8uaW5zcGVjdCAgICAgICAgICAgPSBpbnNwZWN0O1xucHJvdG8udG9KU09OICAgICAgICAgICAgPSB0b0pTT047XG5wcm90by50b1N0cmluZyAgICAgICAgICA9IHRvU3RyaW5nO1xucHJvdG8udW5peCAgICAgICAgICAgICAgPSB1bml4O1xucHJvdG8udmFsdWVPZiAgICAgICAgICAgPSB2YWx1ZU9mO1xucHJvdG8uY3JlYXRpb25EYXRhICAgICAgPSBjcmVhdGlvbkRhdGE7XG5cbi8vIFllYXJcbnByb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xucHJvdG8uaXNMZWFwWWVhciA9IGdldElzTGVhcFllYXI7XG5cbi8vIFdlZWsgWWVhclxucHJvdG8ud2Vla1llYXIgICAgPSBnZXRTZXRXZWVrWWVhcjtcbnByb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG5cbi8vIFF1YXJ0ZXJcbnByb3RvLnF1YXJ0ZXIgPSBwcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XG5cbi8vIE1vbnRoXG5wcm90by5tb250aCAgICAgICA9IGdldFNldE1vbnRoO1xucHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcblxuLy8gV2Vla1xucHJvdG8ud2VlayAgICAgICAgICAgPSBwcm90by53ZWVrcyAgICAgICAgPSBnZXRTZXRXZWVrO1xucHJvdG8uaXNvV2VlayAgICAgICAgPSBwcm90by5pc29XZWVrcyAgICAgPSBnZXRTZXRJU09XZWVrO1xucHJvdG8ud2Vla3NJblllYXIgICAgPSBnZXRXZWVrc0luWWVhcjtcbnByb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG5cbi8vIERheVxucHJvdG8uZGF0ZSAgICAgICA9IGdldFNldERheU9mTW9udGg7XG5wcm90by5kYXkgICAgICAgID0gcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcbnByb3RvLndlZWtkYXkgICAgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG5wcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xucHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcblxuLy8gSG91clxucHJvdG8uaG91ciA9IHByb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcblxuLy8gTWludXRlXG5wcm90by5taW51dGUgPSBwcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuXG4vLyBTZWNvbmRcbnByb3RvLnNlY29uZCA9IHByb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG5cbi8vIE1pbGxpc2Vjb25kXG5wcm90by5taWxsaXNlY29uZCA9IHByb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuXG4vLyBPZmZzZXRcbnByb3RvLnV0Y09mZnNldCAgICAgICAgICAgID0gZ2V0U2V0T2Zmc2V0O1xucHJvdG8udXRjICAgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1VUQztcbnByb3RvLmxvY2FsICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9Mb2NhbDtcbnByb3RvLnBhcnNlWm9uZSAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG5wcm90by5oYXNBbGlnbmVkSG91ck9mZnNldCA9IGhhc0FsaWduZWRIb3VyT2Zmc2V0O1xucHJvdG8uaXNEU1QgICAgICAgICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbnByb3RvLmlzTG9jYWwgICAgICAgICAgICAgID0gaXNMb2NhbDtcbnByb3RvLmlzVXRjT2Zmc2V0ICAgICAgICAgID0gaXNVdGNPZmZzZXQ7XG5wcm90by5pc1V0YyAgICAgICAgICAgICAgICA9IGlzVXRjO1xucHJvdG8uaXNVVEMgICAgICAgICAgICAgICAgPSBpc1V0YztcblxuLy8gVGltZXpvbmVcbnByb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG5wcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuXG4vLyBEZXByZWNhdGlvbnNcbnByb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcbnByb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xucHJvdG8ueWVhcnMgID0gZGVwcmVjYXRlKCd5ZWFycyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgeWVhciBpbnN0ZWFkJywgZ2V0U2V0WWVhcik7XG5wcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJywgZ2V0U2V0Wm9uZSk7XG5wcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLCBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQpO1xuXG5mdW5jdGlvbiBjcmVhdGVVbml4IChpbnB1dCkge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCAqIDEwMDApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJblpvbmUgKCkge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xufVxuXG5mdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQgKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmc7XG59XG5cbnZhciBwcm90byQxID0gTG9jYWxlLnByb3RvdHlwZTtcblxucHJvdG8kMS5jYWxlbmRhciAgICAgICAgPSBjYWxlbmRhcjtcbnByb3RvJDEubG9uZ0RhdGVGb3JtYXQgID0gbG9uZ0RhdGVGb3JtYXQ7XG5wcm90byQxLmludmFsaWREYXRlICAgICA9IGludmFsaWREYXRlO1xucHJvdG8kMS5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xucHJvdG8kMS5wcmVwYXJzZSAgICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG5wcm90byQxLnBvc3Rmb3JtYXQgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbnByb3RvJDEucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVUaW1lO1xucHJvdG8kMS5wYXN0RnV0dXJlICAgICAgPSBwYXN0RnV0dXJlO1xucHJvdG8kMS5zZXQgICAgICAgICAgICAgPSBzZXQ7XG5cbi8vIE1vbnRoXG5wcm90byQxLm1vbnRocyAgICAgICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRocztcbnByb3RvJDEubW9udGhzU2hvcnQgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzU2hvcnQ7XG5wcm90byQxLm1vbnRoc1BhcnNlICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1BhcnNlO1xucHJvdG8kMS5tb250aHNSZWdleCAgICAgICA9IG1vbnRoc1JlZ2V4O1xucHJvdG8kMS5tb250aHNTaG9ydFJlZ2V4ICA9IG1vbnRoc1Nob3J0UmVnZXg7XG5cbi8vIFdlZWtcbnByb3RvJDEud2VlayA9IGxvY2FsZVdlZWs7XG5wcm90byQxLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG5wcm90byQxLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbi8vIERheSBvZiBXZWVrXG5wcm90byQxLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xucHJvdG8kMS53ZWVrZGF5c01pbiAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c01pbjtcbnByb3RvJDEud2Vla2RheXNTaG9ydCAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNTaG9ydDtcbnByb3RvJDEud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxucHJvdG8kMS53ZWVrZGF5c1JlZ2V4ICAgICAgID0gICAgICAgIHdlZWtkYXlzUmVnZXg7XG5wcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCAgPSAgICAgICAgd2Vla2RheXNTaG9ydFJlZ2V4O1xucHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ICAgID0gICAgICAgIHdlZWtkYXlzTWluUmVnZXg7XG5cbi8vIEhvdXJzXG5wcm90byQxLmlzUE0gPSBsb2NhbGVJc1BNO1xucHJvdG8kMS5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG5mdW5jdGlvbiBnZXQkMSAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKTtcbiAgICB2YXIgdXRjID0gY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xuICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbn1cblxuZnVuY3Rpb24gbGlzdE1vbnRoc0ltcGwgKGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsICdtb250aCcpO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIGksIGZpZWxkLCAnbW9udGgnKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLy8gKClcbi8vICg1KVxuLy8gKGZtdCwgNSlcbi8vIChmbXQpXG4vLyAodHJ1ZSlcbi8vICh0cnVlLCA1KVxuLy8gKHRydWUsIGZtdCwgNSlcbi8vICh0cnVlLCBmbXQpXG5mdW5jdGlvbiBsaXN0V2Vla2RheXNJbXBsIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xuICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgIH1cblxuICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgc2hpZnQgPSBsb2NhbGVTb3J0ZWQgPyBsb2NhbGUuX3dlZWsuZG93IDogMDtcblxuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCAoaSArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGxpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRocycpO1xufVxuXG5mdW5jdGlvbiBsaXN0TW9udGhzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0Jyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RXZWVrZGF5cyAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnKTtcbn1cblxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzU2hvcnQgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzU2hvcnQnKTtcbn1cblxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzTWluIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicpO1xufVxuXG5nZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICBvdXRwdXQgPSAodG9JbnQobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgIH1cbn0pO1xuXG4vLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5ob29rcy5sYW5nID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsIGdldFNldEdsb2JhbExvY2FsZSk7XG5ob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGdldExvY2FsZSk7XG5cbnZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbmZ1bmN0aW9uIGFicyAoKSB7XG4gICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcblxuICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcbiAgICB0aGlzLl9kYXlzICAgICAgICAgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgIGRhdGEubWlsbGlzZWNvbmRzICA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xuICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgZGF0YS5ob3VycyAgICAgICAgID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGFkZFN1YnRyYWN0JDEgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgIHZhciBvdGhlciA9IGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB2YWx1ZSk7XG5cbiAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgZHVyYXRpb24uX2RheXMgICAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICBkdXJhdGlvbi5fbW9udGhzICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XG5cbiAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xufVxuXG4vLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQoZHVyYXRpb24pXG5mdW5jdGlvbiBhZGQkMSAoaW5wdXQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbn1cblxuLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbmZ1bmN0aW9uIHN1YnRyYWN0JDEgKGlucHV0LCB2YWx1ZSkge1xuICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgLTEpO1xufVxuXG5mdW5jdGlvbiBhYnNDZWlsIChudW1iZXIpIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJ1YmJsZSAoKSB7XG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICB2YXIgZGF5cyAgICAgICAgID0gdGhpcy5fZGF5cztcbiAgICB2YXIgbW9udGhzICAgICAgID0gdGhpcy5fbW9udGhzO1xuICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgIHZhciBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnMsIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBhIG1peCBvZiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzLCBidWJibGUgZG93biBmaXJzdFxuICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgIGlmICghKChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKSkpIHtcbiAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgbW9udGhzID0gMDtcbiAgICB9XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgZGF0YS5zZWNvbmRzICAgICAgPSBzZWNvbmRzICUgNjA7XG5cbiAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XG5cbiAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgZGF0YS5ob3VycyAgICAgICAgPSBob3VycyAlIDI0O1xuXG4gICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcbiAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcblxuICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICBtb250aHMgJT0gMTI7XG5cbiAgICBkYXRhLmRheXMgICA9IGRheXM7XG4gICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgZGF0YS55ZWFycyAgPSB5ZWFycztcblxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBkYXlzVG9Nb250aHMgKGRheXMpIHtcbiAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgcmV0dXJuIGRheXMgKiA0ODAwIC8gMTQ2MDk3O1xufVxuXG5mdW5jdGlvbiBtb250aHNUb0RheXMgKG1vbnRocykge1xuICAgIC8vIHRoZSByZXZlcnNlIG9mIGRheXNUb01vbnRoc1xuICAgIHJldHVybiBtb250aHMgKiAxNDYwOTcgLyA0ODAwO1xufVxuXG5mdW5jdGlvbiBhcyAodW5pdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHZhciBkYXlzO1xuICAgIHZhciBtb250aHM7XG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgZGF5cyAgID0gdGhpcy5fZGF5cyAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgcmV0dXJuIHVuaXRzID09PSAnbW9udGgnID8gbW9udGhzIDogbW9udGhzIC8gMTI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxuICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJyAgIDogcmV0dXJuIGRheXMgLyA3ICAgICArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgIGNhc2UgJ2RheScgICAgOiByZXR1cm4gZGF5cyAgICAgICAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICBjYXNlICdob3VyJyAgIDogcmV0dXJuIGRheXMgKiAyNCAgICArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICBjYXNlICdtaW51dGUnIDogcmV0dXJuIGRheXMgKiAxNDQwICArIG1pbGxpc2Vjb25kcyAvIDZlNDtcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCcgOiByZXR1cm4gZGF5cyAqIDg2NDAwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG5mdW5jdGlvbiB2YWx1ZU9mJDEgKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICApO1xufVxuXG5mdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgIH07XG59XG5cbnZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKTtcbnZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xudmFyIGFzTWludXRlcyAgICAgID0gbWFrZUFzKCdtJyk7XG52YXIgYXNIb3VycyAgICAgICAgPSBtYWtlQXMoJ2gnKTtcbnZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xudmFyIGFzV2Vla3MgICAgICAgID0gbWFrZUFzKCd3Jyk7XG52YXIgYXNNb250aHMgICAgICAgPSBtYWtlQXMoJ00nKTtcbnZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG5mdW5jdGlvbiBjbG9uZSQxICgpIHtcbiAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24odGhpcyk7XG59XG5cbmZ1bmN0aW9uIGdldCQyICh1bml0cykge1xuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XG59XG5cbmZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2RhdGFbbmFtZV0gOiBOYU47XG4gICAgfTtcbn1cblxudmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xudmFyIHNlY29uZHMgICAgICA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKTtcbnZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG52YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcbnZhciBkYXlzICAgICAgICAgPSBtYWtlR2V0dGVyKCdkYXlzJyk7XG52YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG52YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuZnVuY3Rpb24gd2Vla3MgKCkge1xuICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xufVxuXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIHRocmVzaG9sZHMgPSB7XG4gICAgc3M6IDQ0LCAgICAgICAgIC8vIGEgZmV3IHNlY29uZHMgdG8gc2Vjb25kc1xuICAgIHMgOiA0NSwgICAgICAgICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgIG0gOiA0NSwgICAgICAgICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICBoIDogMjIsICAgICAgICAgLy8gaG91cnMgdG8gZGF5XG4gICAgZCA6IDI2LCAgICAgICAgIC8vIGRheXMgdG8gbW9udGhcbiAgICBNIDogMTEgICAgICAgICAgLy8gbW9udGhzIHRvIHllYXJcbn07XG5cbi8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG5mdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xufVxuXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWUkMSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKTtcbiAgICB2YXIgc2Vjb25kcyAgPSByb3VuZChkdXJhdGlvbi5hcygncycpKTtcbiAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcbiAgICB2YXIgaG91cnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKTtcbiAgICB2YXIgZGF5cyAgICAgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKTtcbiAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcbiAgICB2YXIgeWVhcnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygneScpKTtcblxuICAgIHZhciBhID0gc2Vjb25kcyA8PSB0aHJlc2hvbGRzLnNzICYmIFsncycsIHNlY29uZHNdICB8fFxuICAgICAgICAgICAgc2Vjb25kcyA8IHRocmVzaG9sZHMucyAgICYmIFsnc3MnLCBzZWNvbmRzXSB8fFxuICAgICAgICAgICAgbWludXRlcyA8PSAxICAgICAgICAgICAgICYmIFsnbSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgbWludXRlcyA8IHRocmVzaG9sZHMubSAgICYmIFsnbW0nLCBtaW51dGVzXSB8fFxuICAgICAgICAgICAgaG91cnMgICA8PSAxICAgICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgaG91cnMgICA8IHRocmVzaG9sZHMuaCAgICYmIFsnaGgnLCBob3Vyc10gICB8fFxuICAgICAgICAgICAgZGF5cyAgICA8PSAxICAgICAgICAgICAgICYmIFsnZCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAgICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgbW9udGhzICA8PSAxICAgICAgICAgICAgICYmIFsnTSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgbW9udGhzICA8IHRocmVzaG9sZHMuTSAgICYmIFsnTU0nLCBtb250aHNdICB8fFxuICAgICAgICAgICAgeWVhcnMgICA8PSAxICAgICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgYVs0XSA9IGxvY2FsZTtcbiAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbmZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nIChyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgaWYgKHJvdW5kaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcm91bmQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Yocm91bmRpbmdGdW5jdGlvbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbmZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCAodGhyZXNob2xkLCBsaW1pdCkge1xuICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgfVxuICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgIGlmICh0aHJlc2hvbGQgPT09ICdzJykge1xuICAgICAgICB0aHJlc2hvbGRzLnNzID0gbGltaXQgLSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaHVtYW5pemUgKHdpdGhTdWZmaXgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cblxuICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICB2YXIgb3V0cHV0ID0gcmVsYXRpdmVUaW1lJDEodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbn1cblxudmFyIGFicyQxID0gTWF0aC5hYnM7XG5cbmZ1bmN0aW9uIHNpZ24oeCkge1xuICAgIHJldHVybiAoKHggPiAwKSAtICh4IDwgMCkpIHx8ICt4O1xufVxuXG5mdW5jdGlvbiB0b0lTT1N0cmluZyQxKCkge1xuICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcbiAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcbiAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxuXG4gICAgdmFyIHNlY29uZHMgPSBhYnMkMSh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMDtcbiAgICB2YXIgZGF5cyAgICAgICAgID0gYWJzJDEodGhpcy5fZGF5cyk7XG4gICAgdmFyIG1vbnRocyAgICAgICA9IGFicyQxKHRoaXMuX21vbnRocyk7XG4gICAgdmFyIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycztcblxuICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgc2Vjb25kcyAlPSA2MDtcbiAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgIHllYXJzICA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICBtb250aHMgJT0gMTI7XG5cblxuICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgdmFyIFkgPSB5ZWFycztcbiAgICB2YXIgTSA9IG1vbnRocztcbiAgICB2YXIgRCA9IGRheXM7XG4gICAgdmFyIGggPSBob3VycztcbiAgICB2YXIgbSA9IG1pbnV0ZXM7XG4gICAgdmFyIHMgPSBzZWNvbmRzID8gc2Vjb25kcy50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykgOiAnJztcbiAgICB2YXIgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpO1xuXG4gICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgIH1cblxuICAgIHZhciB0b3RhbFNpZ24gPSB0b3RhbCA8IDAgPyAnLScgOiAnJztcbiAgICB2YXIgeW1TaWduID0gc2lnbih0aGlzLl9tb250aHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgIHZhciBkYXlzU2lnbiA9IHNpZ24odGhpcy5fZGF5cykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgdmFyIGhtc1NpZ24gPSBzaWduKHRoaXMuX21pbGxpc2Vjb25kcykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG5cbiAgICByZXR1cm4gdG90YWxTaWduICsgJ1AnICtcbiAgICAgICAgKFkgPyB5bVNpZ24gKyBZICsgJ1knIDogJycpICtcbiAgICAgICAgKE0gPyB5bVNpZ24gKyBNICsgJ00nIDogJycpICtcbiAgICAgICAgKEQgPyBkYXlzU2lnbiArIEQgKyAnRCcgOiAnJykgK1xuICAgICAgICAoKGggfHwgbSB8fCBzKSA/ICdUJyA6ICcnKSArXG4gICAgICAgIChoID8gaG1zU2lnbiArIGggKyAnSCcgOiAnJykgK1xuICAgICAgICAobSA/IGhtc1NpZ24gKyBtICsgJ00nIDogJycpICtcbiAgICAgICAgKHMgPyBobXNTaWduICsgcyArICdTJyA6ICcnKTtcbn1cblxudmFyIHByb3RvJDIgPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbnByb3RvJDIuaXNWYWxpZCAgICAgICAgPSBpc1ZhbGlkJDE7XG5wcm90byQyLmFicyAgICAgICAgICAgID0gYWJzO1xucHJvdG8kMi5hZGQgICAgICAgICAgICA9IGFkZCQxO1xucHJvdG8kMi5zdWJ0cmFjdCAgICAgICA9IHN1YnRyYWN0JDE7XG5wcm90byQyLmFzICAgICAgICAgICAgID0gYXM7XG5wcm90byQyLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG5wcm90byQyLmFzU2Vjb25kcyAgICAgID0gYXNTZWNvbmRzO1xucHJvdG8kMi5hc01pbnV0ZXMgICAgICA9IGFzTWludXRlcztcbnByb3RvJDIuYXNIb3VycyAgICAgICAgPSBhc0hvdXJzO1xucHJvdG8kMi5hc0RheXMgICAgICAgICA9IGFzRGF5cztcbnByb3RvJDIuYXNXZWVrcyAgICAgICAgPSBhc1dlZWtzO1xucHJvdG8kMi5hc01vbnRocyAgICAgICA9IGFzTW9udGhzO1xucHJvdG8kMi5hc1llYXJzICAgICAgICA9IGFzWWVhcnM7XG5wcm90byQyLnZhbHVlT2YgICAgICAgID0gdmFsdWVPZiQxO1xucHJvdG8kMi5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbnByb3RvJDIuY2xvbmUgICAgICAgICAgPSBjbG9uZSQxO1xucHJvdG8kMi5nZXQgICAgICAgICAgICA9IGdldCQyO1xucHJvdG8kMi5taWxsaXNlY29uZHMgICA9IG1pbGxpc2Vjb25kcztcbnByb3RvJDIuc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xucHJvdG8kMi5taW51dGVzICAgICAgICA9IG1pbnV0ZXM7XG5wcm90byQyLmhvdXJzICAgICAgICAgID0gaG91cnM7XG5wcm90byQyLmRheXMgICAgICAgICAgID0gZGF5cztcbnByb3RvJDIud2Vla3MgICAgICAgICAgPSB3ZWVrcztcbnByb3RvJDIubW9udGhzICAgICAgICAgPSBtb250aHM7XG5wcm90byQyLnllYXJzICAgICAgICAgID0geWVhcnM7XG5wcm90byQyLmh1bWFuaXplICAgICAgID0gaHVtYW5pemU7XG5wcm90byQyLnRvSVNPU3RyaW5nICAgID0gdG9JU09TdHJpbmckMTtcbnByb3RvJDIudG9TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZyQxO1xucHJvdG8kMi50b0pTT04gICAgICAgICA9IHRvSVNPU3RyaW5nJDE7XG5wcm90byQyLmxvY2FsZSAgICAgICAgID0gbG9jYWxlO1xucHJvdG8kMi5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XG5cbi8vIERlcHJlY2F0aW9uc1xucHJvdG8kMi50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZSgndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLCB0b0lTT1N0cmluZyQxKTtcbnByb3RvJDIubGFuZyA9IGxhbmc7XG5cbi8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG5hZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG5hZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xufSk7XG5cbi8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuXG5ob29rcy52ZXJzaW9uID0gJzIuMjAuMSc7XG5cbnNldEhvb2tDYWxsYmFjayhjcmVhdGVMb2NhbCk7XG5cbmhvb2tzLmZuICAgICAgICAgICAgICAgICAgICA9IHByb3RvO1xuaG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xuaG9va3MubWF4ICAgICAgICAgICAgICAgICAgID0gbWF4O1xuaG9va3Mubm93ICAgICAgICAgICAgICAgICAgID0gbm93O1xuaG9va3MudXRjICAgICAgICAgICAgICAgICAgID0gY3JlYXRlVVRDO1xuaG9va3MudW5peCAgICAgICAgICAgICAgICAgID0gY3JlYXRlVW5peDtcbmhvb2tzLm1vbnRocyAgICAgICAgICAgICAgICA9IGxpc3RNb250aHM7XG5ob29rcy5pc0RhdGUgICAgICAgICAgICAgICAgPSBpc0RhdGU7XG5ob29rcy5sb2NhbGUgICAgICAgICAgICAgICAgPSBnZXRTZXRHbG9iYWxMb2NhbGU7XG5ob29rcy5pbnZhbGlkICAgICAgICAgICAgICAgPSBjcmVhdGVJbnZhbGlkO1xuaG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlRHVyYXRpb247XG5ob29rcy5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcbmhvb2tzLndlZWtkYXlzICAgICAgICAgICAgICA9IGxpc3RXZWVrZGF5cztcbmhvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IGNyZWF0ZUluWm9uZTtcbmhvb2tzLmxvY2FsZURhdGEgICAgICAgICAgICA9IGdldExvY2FsZTtcbmhvb2tzLmlzRHVyYXRpb24gICAgICAgICAgICA9IGlzRHVyYXRpb247XG5ob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0TW9udGhzU2hvcnQ7XG5ob29rcy53ZWVrZGF5c01pbiAgICAgICAgICAgPSBsaXN0V2Vla2RheXNNaW47XG5ob29rcy5kZWZpbmVMb2NhbGUgICAgICAgICAgPSBkZWZpbmVMb2NhbGU7XG5ob29rcy51cGRhdGVMb2NhbGUgICAgICAgICAgPSB1cGRhdGVMb2NhbGU7XG5ob29rcy5sb2NhbGVzICAgICAgICAgICAgICAgPSBsaXN0TG9jYWxlcztcbmhvb2tzLndlZWtkYXlzU2hvcnQgICAgICAgICA9IGxpc3RXZWVrZGF5c1Nob3J0O1xuaG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG5ob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyAgPSBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZztcbmhvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcbmhvb2tzLmNhbGVuZGFyRm9ybWF0ICAgICAgICA9IGdldENhbGVuZGFyRm9ybWF0O1xuaG9va3MucHJvdG90eXBlICAgICAgICAgICAgID0gcHJvdG87XG5cbi8vIGN1cnJlbnRseSBIVE1MNSBpbnB1dCB0eXBlIG9ubHkgc3VwcG9ydHMgMjQtaG91ciBmb3JtYXRzXG5ob29rcy5IVE1MNV9GTVQgPSB7XG4gICAgREFURVRJTUVfTE9DQUw6ICdZWVlZLU1NLUREVEhIOm1tJywgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIC8+XG4gICAgREFURVRJTUVfTE9DQUxfU0VDT05EUzogJ1lZWVktTU0tRERUSEg6bW06c3MnLCAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIxXCIgLz5cbiAgICBEQVRFVElNRV9MT0NBTF9NUzogJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTJywgICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICBEQVRFOiAnWVlZWS1NTS1ERCcsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cImRhdGVcIiAvPlxuICAgIFRJTUU6ICdISDptbScsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIC8+XG4gICAgVElNRV9TRUNPTkRTOiAnSEg6bW06c3MnLCAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjFcIiAvPlxuICAgIFRJTUVfTVM6ICdISDptbTpzcy5TU1MnLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgV0VFSzogJ1lZWVktW1ddV1cnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ3ZWVrXCIgLz5cbiAgICBNT05USDogJ1lZWVktTU0nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cIm1vbnRoXCIgLz5cbn07XG5cbnJldHVybiBob29rcztcblxufSkpKTtcbiIsImltcG9ydCAqIGFzIG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB7T3B0aW9ucyxcbiAgICBjYXN1YWxPcHRpb24sXG4gICAgY29tbW9uUG9zdFByb2Nlc3NpbmcsXG4gICAgZGUgYXMgZGVQYXJzZXJzLFxuICAgIGVuIGFzIGVuUGFyc2VycyxcbiAgICBlbl9HQiBhcyBlbl9HQlBhcnNlcnMsXG4gICAgZXMgYXMgZXNQYXJzZXJzLFxuICAgIGZyIGFzIGZyUGFyc2VycyxcbiAgICBqYSBhcyBqYVBhcnNlcnMsXG4gICAgbWVyZ2VPcHRpb25zLFxuICAgIHN0cmljdE9wdGlvbn0gZnJvbSBcIi4vb3B0aW9uc1wiO1xuaW1wb3J0IFBhcnNlciwgKiBhcyBwYXJzZXIgZnJvbSAnLi9wYXJzZXJzL3BhcnNlcic7XG5pbXBvcnQgUmVmaW5lciwgKiBhcyByZWZpbmVyIGZyb20gJy4vcmVmaW5lcnMvcmVmaW5lcic7XG5pbXBvcnQge0ZpbHRlcn0gZnJvbSAnLi9yZWZpbmVycy9yZWZpbmVyJztcbmltcG9ydCB7UGFyc2VkUmVzdWx0LCBQYXJzZWRDb21wb25lbnRzfSBmcm9tICcuL3Jlc3VsdCc7XG5cbmV4cG9ydCB7b3B0aW9ucywgcGFyc2VyLCByZWZpbmVyLCBQYXJzZXIsIFJlZmluZXIsIFBhcnNlZFJlc3VsdCwgUGFyc2VkQ29tcG9uZW50cywgRmlsdGVyfTtcblxuZXhwb3J0IHR5cGUgUGFyc2VPcHRpb25zID0ge1xuICAgIGZvcndhcmREYXRlOiBib29sZWFuLFxuICAgIGFmdGVybm9vbjogbnVtYmVyLFxuICAgIGV2ZW5pbmc6IG51bWJlcixcbiAgICBtb3JuaW5nOiBudW1iZXIsXG4gICAgbm9vbjogbnVtYmVyXG59O1xuXG5jb25zdCBERUZBVUxUX1BBUlNFX09QVElPTlM6IFBhcnNlT3B0aW9ucyA9IHtcbiAgICBmb3J3YXJkRGF0ZTogZmFsc2UsXG4gICAgYWZ0ZXJub29uOiAxNSxcbiAgICBldmVuaW5nOiAxOCxcbiAgICBtb3JuaW5nOiA2LFxuICAgIG5vb246IDEyLFxufTtcblxuZXhwb3J0IGNsYXNzIENocm9ubyB7XG4gICAgb3B0aW9uOiBPcHRpb25zO1xuICAgIHBhcnNlcnM6IFBhcnNlcltdO1xuICAgIHJlZmluZXJzOiBSZWZpbmVyW107XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb246IE9wdGlvbnMgPSBjYXN1YWxPcHRpb24oKSkge1xuICAgICAgICB0aGlzLm9wdGlvbiA9IG9wdGlvbjtcbiAgICAgICAgdGhpcy5wYXJzZXJzID0gb3B0aW9uLnBhcnNlcnMgfHwgW107XG4gICAgICAgIHRoaXMucmVmaW5lcnMgPSBvcHRpb24ucmVmaW5lcnMgfHwgW107XG4gICAgfVxuXG4gICAgcGFyc2UodGV4dDogc3RyaW5nLCByZWZEYXRlOiBEYXRlID0gbmV3IERhdGUoKSwgb3B0OiBQYXJ0aWFsPFBhcnNlT3B0aW9ucz4gPSB7fSk6IFBhcnNlZFJlc3VsdFtdIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkT3B0aW9uczogUGFyc2VPcHRpb25zID0gey4uLkRFRkFVTFRfUEFSU0VfT1BUSU9OUywgLi4ub3B0fTtcbiAgICAgICAgbGV0IGFsbFJlc3VsdHM6IFBhcnNlZFJlc3VsdFtdID0gW107XG5cbiAgICAgICAgdGhpcy5wYXJzZXJzLmZvckVhY2goKHBhcnNlcjogUGFyc2VyKSA9PlxuICAgICAgICAgICAgYWxsUmVzdWx0cy5wdXNoKC4uLnBhcnNlci5leGVjdXRlKHRleHQsIHJlZkRhdGUsIG1lcmdlZE9wdGlvbnMpKVxuICAgICAgICApO1xuXG4gICAgICAgIGFsbFJlc3VsdHMuc29ydCgoYSwgYikgPT4gYS5pbmRleCAtIGIuaW5kZXgpO1xuXG4gICAgICAgIHRoaXMucmVmaW5lcnMuZm9yRWFjaCgocmVmaW5lcikgPT5cbiAgICAgICAgICAgIGFsbFJlc3VsdHMgPSByZWZpbmVyLnJlZmluZSh0ZXh0LCBhbGxSZXN1bHRzLCBtZXJnZWRPcHRpb25zKVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBhbGxSZXN1bHRzO1xuICAgIH1cblxuICAgIHBhcnNlRGF0ZSh0ZXh0OiBzdHJpbmcsIHJlZkRhdGU6IERhdGUgPSBuZXcgRGF0ZSgpLCBvcHQ6IFBhcnRpYWw8UGFyc2VPcHRpb25zPiA9IHt9KTogRGF0ZSB8IG51bGwge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gdGhpcy5wYXJzZSh0ZXh0LCByZWZEYXRlLCBvcHQpO1xuICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0c1swXS5zdGFydC5kYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENocm9ubztcbmV4cG9ydCBjb25zdCBzdHJpY3Q6IENocm9ubyA9IG5ldyBDaHJvbm8oIHN0cmljdE9wdGlvbigpICk7XG5leHBvcnQgY29uc3QgY2FzdWFsOiBDaHJvbm8gPSBuZXcgQ2hyb25vKCBjYXN1YWxPcHRpb24oKSApO1xuXG5leHBvcnQgY29uc3QgZW46IENocm9ubyA9IG5ldyBDaHJvbm8oIG1lcmdlT3B0aW9ucyhbXG4gICAgZW5QYXJzZXJzLmNhc3VhbCEsIGNvbW1vblBvc3RQcm9jZXNzaW5nXSkpO1xuXG5leHBvcnQgY29uc3QgZW5fR0I6IENocm9ubyA9IG5ldyBDaHJvbm8oIG1lcmdlT3B0aW9ucyhbXG4gICAgZW5fR0JQYXJzZXJzLmNhc3VhbCEsIGNvbW1vblBvc3RQcm9jZXNzaW5nXSkpO1xuXG5leHBvcnQgY29uc3QgZGU6IENocm9ubyA9IG5ldyBDaHJvbm8oIG1lcmdlT3B0aW9ucyhbXG4gICAgZGVQYXJzZXJzLmNhc3VhbCEsIGVuUGFyc2VycywgY29tbW9uUG9zdFByb2Nlc3NpbmddKSk7XG5cbmV4cG9ydCBjb25zdCBlczogQ2hyb25vID0gbmV3IENocm9ubyggbWVyZ2VPcHRpb25zKFtcbiAgICBlc1BhcnNlcnMuY2FzdWFsISwgZW5QYXJzZXJzLCBjb21tb25Qb3N0UHJvY2Vzc2luZ10pKTtcblxuZXhwb3J0IGNvbnN0IGZyOiBDaHJvbm8gPSBuZXcgQ2hyb25vKCBtZXJnZU9wdGlvbnMoW1xuICAgIGZyUGFyc2Vycy5jYXN1YWwhLCBlblBhcnNlcnMsIGNvbW1vblBvc3RQcm9jZXNzaW5nXSkpO1xuXG5leHBvcnQgY29uc3QgamE6IENocm9ubyA9IG5ldyBDaHJvbm8oIG1lcmdlT3B0aW9ucyhbXG4gICAgamFQYXJzZXJzLmNhc3VhbCEsIGVuUGFyc2VycywgY29tbW9uUG9zdFByb2Nlc3NpbmddKSk7XG5cblxuZXhwb3J0IGNvbnN0IHBhcnNlID0gKHRleHQ6IHN0cmluZywgcmVmPzogRGF0ZSwgb3B0PzogUGFyc2VPcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIGNhc3VhbC5wYXJzZS5jYWxsKGNhc3VhbCwgdGV4dCwgcmVmLCBvcHQpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlRGF0ZSA9ICh0ZXh0OiBzdHJpbmcsIHJlZj86IERhdGUsIG9wdD86IFBhcnNlT3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBjYXN1YWwucGFyc2VEYXRlLmNhbGwoY2FzdWFsLCB0ZXh0LCByZWYsIG9wdCk7XG59O1xuXG5cblxuXG4iLCJpbXBvcnQge0NPTVBPTkVOVF9OQU1FfSBmcm9tIFwiLi9yZXN1bHRcIjtcblxuZXhwb3J0IGNvbnN0IEhPVVI6IENPTVBPTkVOVF9OQU1FID0gJ2hvdXInO1xuZXhwb3J0IGNvbnN0IE1JTlVURTogQ09NUE9ORU5UX05BTUUgPSAnbWludXRlJztcbmV4cG9ydCBjb25zdCBTRUNPTkQ6IENPTVBPTkVOVF9OQU1FID0gJ3NlY29uZCc7XG5leHBvcnQgY29uc3QgTUlMTElTRUNPTkQ6IENPTVBPTkVOVF9OQU1FID0gJ21pbGxpc2Vjb25kJztcbmV4cG9ydCBjb25zdCBNRVJJRElFTTogQ09NUE9ORU5UX05BTUUgPSAnbWVyaWRpZW0nO1xuZXhwb3J0IGNvbnN0IERBWTogQ09NUE9ORU5UX05BTUUgPSAnZGF5JztcbmV4cG9ydCBjb25zdCBNT05USDogQ09NUE9ORU5UX05BTUUgPSAnbW9udGgnO1xuZXhwb3J0IGNvbnN0IFlFQVI6IENPTVBPTkVOVF9OQU1FID0gJ3llYXInO1xuZXhwb3J0IGNvbnN0IFdFRUtEQVk6IENPTVBPTkVOVF9OQU1FID0gJ3dlZWtkYXknO1xuZXhwb3J0IGNvbnN0IFRJTUVaT05FX09GRlNFVDogQ09NUE9ORU5UX05BTUUgPSAndGltZXpvbmVPZmZzZXQnO1xuZXhwb3J0IGNvbnN0IFdFRUs6IFVuaXRPZlRpbWUgPSAnd2Vlayc7XG5cbmV4cG9ydCB0eXBlIE5hbWVNYXAgPSB7XG4gICAgW2sgOnN0cmluZ106IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBVbml0T2ZUaW1lID0gJ2hvdXInXG58ICdtaW51dGUnXG58ICdzZWNvbmQnXG58ICdtaWxsaXNlY29uZCdcbnwgJ2RheSdcbnwgJ21vbnRoJ1xufCAneWVhcidcbnwgJ3dlZWsnXG5cbmV4cG9ydCB0eXBlIFVuaXRSZWdleE1hcCA9IHtcbiAgICBbayBpbiBVbml0T2ZUaW1lXT86IFJlZ0V4cFxufSIsImltcG9ydCBQYXJzZXIsIHtcbiAgICBERUNhc3VhbERhdGVQYXJzZXIsXG4gICAgREVEZWFkbGluZUZvcm1hdFBhcnNlcixcbiAgICBERU1vbnRoTmFtZUxpdHRsZUVuZGlhblBhcnNlcixcbiAgICBERU1vbnRoTmFtZVBhcnNlcixcbiAgICBERVNsYXNoRGF0ZUZvcm1hdFBhcnNlcixcbiAgICBERVRpbWVBZ29Gb3JtYXRQYXJzZXIsXG4gICAgREVUaW1lRXhwcmVzc2lvblBhcnNlcixcbiAgICBERVdlZWtkYXlQYXJzZXIsXG4gICAgRU5DYXN1YWxEYXRlUGFyc2VyLFxuICAgIEVOQ2FzdWFsVGltZVBhcnNlcixcbiAgICBFTkRlYWRsaW5lRm9ybWF0UGFyc2VyLFxuICAgIEVOSVNPRm9ybWF0UGFyc2VyLFxuICAgIEVOTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyLFxuICAgIEVOTW9udGhOYW1lTWlkZGxlRW5kaWFuUGFyc2VyLFxuICAgIEVOTW9udGhOYW1lUGFyc2VyLFxuICAgIEVOUmVsYXRpdmVEYXRlRm9ybWF0UGFyc2VyLFxuICAgIEVOU2xhc2hEYXRlRm9ybWF0UGFyc2VyLFxuICAgIEVOU2xhc2hEYXRlRm9ybWF0U3RhcnRXaXRoWWVhclBhcnNlcixcbiAgICBFTlNsYXNoTW9udGhGb3JtYXRQYXJzZXIsXG4gICAgRU5UaW1lQWdvRm9ybWF0UGFyc2VyLFxuICAgIEVOVGltZUV4cHJlc3Npb25QYXJzZXIsXG4gICAgRU5UaW1lTGF0ZXJGb3JtYXRQYXJzZXIsXG4gICAgRU5XZWVrZGF5UGFyc2VyLFxuICAgIEVTQ2FzdWFsRGF0ZVBhcnNlcixcbiAgICBFU0RlYWRsaW5lRm9ybWF0UGFyc2VyLFxuICAgIEVTTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyLFxuICAgIEVTU2xhc2hEYXRlRm9ybWF0UGFyc2VyLFxuICAgIEVTVGltZUFnb0Zvcm1hdFBhcnNlcixcbiAgICBFU1RpbWVFeHByZXNzaW9uUGFyc2VyLFxuICAgIEVTV2Vla2RheVBhcnNlcixcbiAgICBGUkNhc3VhbERhdGVQYXJzZXIsXG4gICAgRlJEZWFkbGluZUZvcm1hdFBhcnNlcixcbiAgICBGUk1vbnRoTmFtZUxpdHRsZUVuZGlhblBhcnNlcixcbiAgICBGUlJlbGF0aXZlRGF0ZUZvcm1hdFBhcnNlcixcbiAgICBGUlNsYXNoRGF0ZUZvcm1hdFBhcnNlcixcbiAgICBGUlRpbWVBZ29Gb3JtYXRQYXJzZXIsXG4gICAgRlJUaW1lRXhwcmVzc2lvblBhcnNlcixcbiAgICBGUldlZWtkYXlQYXJzZXIsXG4gICAgSlBDYXN1YWxEYXRlUGFyc2VyLFxuICAgIEpQU3RhbmRhcmRQYXJzZXIsXG4gICAgWkhIYW50Q2FzdWFsRGF0ZVBhcnNlcixcbiAgICBaSEhhbnREYXRlUGFyc2VyLFxuICAgIFpISGFudERlYWRsaW5lRm9ybWF0UGFyc2VyLFxuICAgIFpISGFudFRpbWVFeHByZXNzaW9uUGFyc2VyLFxuICAgIFpISGFudFdlZWtkYXlQYXJzZXJcbn0gZnJvbSAnLi9wYXJzZXJzL3BhcnNlcic7XG5pbXBvcnQgUmVmaW5lciwge1xuICAgIERFTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLFxuICAgIERFTWVyZ2VEYXRlVGltZVJlZmluZXIsXG4gICAgRU5NZXJnZURhdGVSYW5nZVJlZmluZXIsXG4gICAgRU5NZXJnZURhdGVUaW1lUmVmaW5lcixcbiAgICBFTlByaW9yaXRpemVTcGVjaWZpY0RhdGVSZWZpbmVyLFxuICAgIEV4dHJhY3RUaW1lem9uZUFiYnJSZWZpbmVyLFxuICAgIEV4dHJhY3RUaW1lem9uZU9mZnNldFJlZmluZXIsXG4gICAgRm9yd2FyZERhdGVSZWZpbmVyLFxuICAgIEZSTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyLFxuICAgIEZSTWVyZ2VEYXRlVGltZVJlZmluZXIsXG4gICAgSlBNZXJnZURhdGVSYW5nZVJlZmluZXIsXG4gICAgT3ZlcmxhcFJlbW92YWxSZWZpbmVyLFxuICAgIFVubGlrZWx5Rm9ybWF0RmlsdGVyXG59IGZyb20gJy4vcmVmaW5lcnMvcmVmaW5lcic7XG5cbmV4cG9ydCB0eXBlIE9wdGlvbnMgPSB7XG4gICAgcGFyc2Vycz86IFBhcnNlcltdO1xuICAgIHJlZmluZXJzPzogUmVmaW5lcltdO1xufVxuZXhwb3J0IHR5cGUgQ29uZmlnID0ge1xuICAgIHN0cmljdD86IGJvb2xlYW4sXG4gICAgbGl0dGxlRW5kaWFuPzogYm9vbGVhblxufVxuZXhwb3J0IHR5cGUgT3B0aW9uc1Jlc29sdmVyID0gKGNvbmZpZz86IENvbmZpZykgPT4gT3B0aW9ucztcbmV4cG9ydCB0eXBlIE9wdGlvbnNPclJlc29sdmVyID0gT3B0aW9ucyB8IE9wdGlvbnNSZXNvbHZlcjtcblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zUmVzb2x2ZXJXaXRoQ2FzdWFsIGV4dGVuZHMgT3B0aW9uc1Jlc29sdmVyIHtcbiAgICBjYXN1YWw/OiBPcHRpb25zUmVzb2x2ZXI7XG59XG5cbmZ1bmN0aW9uIGlzUmVzb2x2ZXIodGVzdDogT3B0aW9uc09yUmVzb2x2ZXIpOiB0ZXN0IGlzIE9wdGlvbnNSZXNvbHZlciB7XG4gICAgcmV0dXJuICg8T3B0aW9uc1Jlc29sdmVyPnRlc3QpLmNhbGwgIT09IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGNvbnN0IG1lcmdlT3B0aW9ucyA9IChvcHRpb25zOiBPcHRpb25zT3JSZXNvbHZlcltdKTogT3B0aW9ucyA9PiB7XG4gICAgY29uc3QgYWRkZWRUeXBlczogeyBbazogc3RyaW5nXTogdHJ1ZSB9ID0ge307XG4gICAgY29uc3QgbWVyZ2VkT3B0aW9uOiBPcHRpb25zID0ge1xuICAgICAgICBwYXJzZXJzOiBbXSxcbiAgICAgICAgcmVmaW5lcnM6IFtdXG4gICAgfTtcblxuICAgIG9wdGlvbnMuZm9yRWFjaCgobWF5YmVPcHRpb246IE9wdGlvbnNPclJlc29sdmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGlvbjogT3B0aW9ucyA9IGlzUmVzb2x2ZXIobWF5YmVPcHRpb24pID8gbWF5YmVPcHRpb24uY2FsbChtYXliZU9wdGlvbikgOiBtYXliZU9wdGlvbjtcblxuICAgICAgICBpZiAob3B0aW9uLnBhcnNlcnMpIHtcbiAgICAgICAgICAgIG9wdGlvbi5wYXJzZXJzLmZvckVhY2goKHBhcnNlcjogUGFyc2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFhZGRlZFR5cGVzW3BhcnNlci5jb25zdHJ1Y3Rvci5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRPcHRpb24ucGFyc2VycyEucHVzaChwYXJzZXIpO1xuICAgICAgICAgICAgICAgICAgICBhZGRlZFR5cGVzW3BhcnNlci5jb25zdHJ1Y3Rvci5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9uLnJlZmluZXJzKSB7XG4gICAgICAgICAgICBvcHRpb24ucmVmaW5lcnMuZm9yRWFjaCgocmVmaW5lcjogUmVmaW5lcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghYWRkZWRUeXBlc1tyZWZpbmVyLmNvbnN0cnVjdG9yLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZE9wdGlvbi5yZWZpbmVycyEucHVzaChyZWZpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRUeXBlc1tyZWZpbmVyLmNvbnN0cnVjdG9yLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1lcmdlZE9wdGlvbjtcbn07XG5cbmV4cG9ydCBjb25zdCBjb21tb25Qb3N0UHJvY2Vzc2luZzogT3B0aW9uc1Jlc29sdmVyID0gKCk6IE9wdGlvbnMgPT4gKHtcbiAgICByZWZpbmVyczogW1xuICAgICAgICAvLyBUaGVzZSBzaG91bGQgYmUgYWZ0ZXIgYWxsIG90aGVyIHJlZmluZXJzXG4gICAgICAgIG5ldyBFeHRyYWN0VGltZXpvbmVPZmZzZXRSZWZpbmVyKCksXG4gICAgICAgIG5ldyBFeHRyYWN0VGltZXpvbmVBYmJyUmVmaW5lcigpLFxuICAgICAgICBuZXcgVW5saWtlbHlGb3JtYXRGaWx0ZXIoKVxuICAgIF1cbn0pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBzdHJpY3RPcHRpb246IE9wdGlvbnNSZXNvbHZlciA9ICgpOiBPcHRpb25zID0+IHtcbiAgICBjb25zdCBzdHJpY3RDb25maWcgPSB7XG4gICAgICAgIHN0cmljdDogdHJ1ZVxuICAgIH07XG5cbiAgICByZXR1cm4gbWVyZ2VPcHRpb25zKFtcbiAgICAgICAgZW4oc3RyaWN0Q29uZmlnKSxcbiAgICAgICAgZGUoc3RyaWN0Q29uZmlnKSxcbiAgICAgICAgZXMoc3RyaWN0Q29uZmlnKSxcbiAgICAgICAgZnIoc3RyaWN0Q29uZmlnKSxcbiAgICAgICAgamEoKSxcbiAgICAgICAgemgoKSxcbiAgICAgICAgY29tbW9uUG9zdFByb2Nlc3NpbmdcbiAgICBdKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjYXN1YWxPcHRpb246IE9wdGlvbnNSZXNvbHZlciA9ICgpOiBPcHRpb25zID0+IG1lcmdlT3B0aW9ucyhbXG4gICAgZW4uY2FzdWFsISxcbiAgICAvLyBTb21lIEdlcm1hbiBhYmJyZXZpYXRlIG92ZXJsYXAgd2l0aCBjb21tb24gRW5nbGlzaFxuICAgIGRlKHtzdHJpY3Q6IHRydWV9KSxcbiAgICBlcy5jYXN1YWwhLFxuICAgIGZyLmNhc3VhbCEsXG4gICAgamEuY2FzdWFsISxcbiAgICB6aCxcbiAgICBjb21tb25Qb3N0UHJvY2Vzc2luZ1xuXSk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZGU6IE9wdGlvbnNSZXNvbHZlcldpdGhDYXN1YWwgPSAoY29uZmlnKTogT3B0aW9ucyA9PiAoe1xuICAgIHBhcnNlcnM6IFtcbiAgICAgICAgbmV3IERFRGVhZGxpbmVGb3JtYXRQYXJzZXIoY29uZmlnKSxcbiAgICAgICAgbmV3IERFTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyKGNvbmZpZyksXG4gICAgICAgIG5ldyBERU1vbnRoTmFtZVBhcnNlcihjb25maWcpLFxuICAgICAgICBuZXcgREVTbGFzaERhdGVGb3JtYXRQYXJzZXIoY29uZmlnKSxcbiAgICAgICAgbmV3IERFVGltZUFnb0Zvcm1hdFBhcnNlcihjb25maWcpLFxuICAgICAgICBuZXcgREVUaW1lRXhwcmVzc2lvblBhcnNlcihjb25maWcpXG4gICAgXSxcbiAgICByZWZpbmVyczogW1xuICAgICAgICBuZXcgT3ZlcmxhcFJlbW92YWxSZWZpbmVyKCksXG4gICAgICAgIG5ldyBGb3J3YXJkRGF0ZVJlZmluZXIoKSxcbiAgICAgICAgbmV3IERFTWVyZ2VEYXRlVGltZVJlZmluZXIoKSxcbiAgICAgICAgbmV3IERFTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyKClcbiAgICBdXG59KTtcblxuZGUuY2FzdWFsID0gKCk6IE9wdGlvbnMgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnM6IE9wdGlvbnMgPSBkZSh7c3RyaWN0OiBmYWxzZX0pO1xuICAgIG9wdGlvbnMucGFyc2VycyEudW5zaGlmdChuZXcgREVDYXN1YWxEYXRlUGFyc2VyKCkpO1xuICAgIG9wdGlvbnMucGFyc2VycyEudW5zaGlmdChuZXcgREVXZWVrZGF5UGFyc2VyKCkpO1xuICAgIHJldHVybiBvcHRpb25zO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBlbjogT3B0aW9uc1Jlc29sdmVyV2l0aENhc3VhbCA9IChjb25maWcpOiBPcHRpb25zID0+ICh7XG4gICAgcGFyc2VyczogW1xuICAgICAgICBuZXcgRU5JU09Gb3JtYXRQYXJzZXIoY29uZmlnKSxcbiAgICAgICAgbmV3IEVORGVhZGxpbmVGb3JtYXRQYXJzZXIoY29uZmlnKSxcbiAgICAgICAgbmV3IEVOTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyKGNvbmZpZyksXG4gICAgICAgIG5ldyBFTk1vbnRoTmFtZU1pZGRsZUVuZGlhblBhcnNlcihjb25maWcpLFxuICAgICAgICBuZXcgRU5Nb250aE5hbWVQYXJzZXIoY29uZmlnKSxcbiAgICAgICAgbmV3IEVOU2xhc2hEYXRlRm9ybWF0UGFyc2VyKGNvbmZpZyksXG4gICAgICAgIG5ldyBFTlNsYXNoRGF0ZUZvcm1hdFN0YXJ0V2l0aFllYXJQYXJzZXIoY29uZmlnKSxcbiAgICAgICAgbmV3IEVOU2xhc2hNb250aEZvcm1hdFBhcnNlcihjb25maWcpLFxuICAgICAgICBuZXcgRU5UaW1lQWdvRm9ybWF0UGFyc2VyKGNvbmZpZyksXG4gICAgICAgIG5ldyBFTlRpbWVMYXRlckZvcm1hdFBhcnNlcihjb25maWcpLFxuICAgICAgICBuZXcgRU5UaW1lRXhwcmVzc2lvblBhcnNlcihjb25maWcpXG4gICAgXSxcbiAgICByZWZpbmVyczogW1xuICAgICAgICBuZXcgT3ZlcmxhcFJlbW92YWxSZWZpbmVyKCksXG4gICAgICAgIG5ldyBGb3J3YXJkRGF0ZVJlZmluZXIoKSxcblxuICAgICAgICAvLyBFbmdsaXNoXG4gICAgICAgIG5ldyBFTk1lcmdlRGF0ZVRpbWVSZWZpbmVyKCksXG4gICAgICAgIG5ldyBFTk1lcmdlRGF0ZVJhbmdlUmVmaW5lcigpLFxuICAgICAgICBuZXcgRU5Qcmlvcml0aXplU3BlY2lmaWNEYXRlUmVmaW5lcigpXG4gICAgXVxufSk7XG5cbmVuLmNhc3VhbCA9IChjb25maWc6IENvbmZpZyA9IHt9KTogT3B0aW9ucyA9PiB7XG4gICAgY29uc3Qgb3B0aW9uczogT3B0aW9ucyA9IGVuKHsuLi5jb25maWcsIHN0cmljdDogZmFsc2V9KTtcblxuICAgIC8vIEVOXG4gICAgb3B0aW9ucy5wYXJzZXJzIS51bnNoaWZ0KG5ldyBFTkNhc3VhbERhdGVQYXJzZXIoKSk7XG4gICAgb3B0aW9ucy5wYXJzZXJzIS51bnNoaWZ0KG5ldyBFTkNhc3VhbFRpbWVQYXJzZXIoKSk7XG4gICAgb3B0aW9ucy5wYXJzZXJzIS51bnNoaWZ0KG5ldyBFTldlZWtkYXlQYXJzZXIoKSk7XG4gICAgb3B0aW9ucy5wYXJzZXJzIS51bnNoaWZ0KG5ldyBFTlJlbGF0aXZlRGF0ZUZvcm1hdFBhcnNlcigpKTtcbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5cbmNvbnN0IGVuX0dCOiBPcHRpb25zUmVzb2x2ZXJXaXRoQ2FzdWFsID0gKGNvbmZpZzogQ29uZmlnID0ge30pOiBPcHRpb25zID0+IGVuKHsuLi5jb25maWcsIGxpdHRsZUVuZGlhbjogdHJ1ZX0pO1xuXG5lbl9HQi5jYXN1YWwgPSAoY29uZmlnOiBDb25maWcgPSB7fSk6IE9wdGlvbnMgPT4gZW4uY2FzdWFsISh7Li4uY29uZmlnLCBsaXR0bGVFbmRpYW46IHRydWV9KTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBqYTogT3B0aW9uc1Jlc29sdmVyV2l0aENhc3VhbCA9ICgpOiBPcHRpb25zID0+ICh7XG4gICAgcGFyc2VyczogW1xuICAgICAgICBuZXcgSlBTdGFuZGFyZFBhcnNlcigpXG4gICAgXSxcbiAgICByZWZpbmVyczogW1xuICAgICAgICBuZXcgT3ZlcmxhcFJlbW92YWxSZWZpbmVyKCksXG4gICAgICAgIG5ldyBGb3J3YXJkRGF0ZVJlZmluZXIoKSxcbiAgICAgICAgbmV3IEpQTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyKClcbiAgICBdXG59KTtcblxuamEuY2FzdWFsID0gKCk6IE9wdGlvbnMgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnM6IE9wdGlvbnMgPSBqYSgpO1xuICAgIG9wdGlvbnMucGFyc2VycyEudW5zaGlmdChuZXcgSlBDYXN1YWxEYXRlUGFyc2VyKCkpO1xuICAgIHJldHVybiBvcHRpb25zO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbmNvbnN0IGVzOiBPcHRpb25zUmVzb2x2ZXJXaXRoQ2FzdWFsID0gKGNvbmZpZz86IENvbmZpZyk6IE9wdGlvbnMgPT4gKHtcbiAgICBwYXJzZXJzOiBbXG4gICAgICAgIG5ldyBFU1RpbWVBZ29Gb3JtYXRQYXJzZXIoY29uZmlnKSxcbiAgICAgICAgbmV3IEVTRGVhZGxpbmVGb3JtYXRQYXJzZXIoY29uZmlnKSxcbiAgICAgICAgbmV3IEVTVGltZUV4cHJlc3Npb25QYXJzZXIoY29uZmlnKSxcbiAgICAgICAgbmV3IEVTTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyKGNvbmZpZyksXG4gICAgICAgIG5ldyBFU1NsYXNoRGF0ZUZvcm1hdFBhcnNlcihjb25maWcpXG4gICAgXSxcbiAgICByZWZpbmVyczogW1xuICAgICAgICBuZXcgT3ZlcmxhcFJlbW92YWxSZWZpbmVyKCksXG4gICAgICAgIG5ldyBGb3J3YXJkRGF0ZVJlZmluZXIoKVxuICAgIF1cbn0pO1xuXG5lcy5jYXN1YWwgPSAoKTogT3B0aW9ucyA9PiB7XG4gICAgY29uc3Qgb3B0aW9uczogT3B0aW9ucyA9IGVzKHtzdHJpY3Q6IGZhbHNlfSk7XG5cbiAgICBvcHRpb25zLnBhcnNlcnMhLnVuc2hpZnQobmV3IEVTQ2FzdWFsRGF0ZVBhcnNlcigpKTtcbiAgICBvcHRpb25zLnBhcnNlcnMhLnVuc2hpZnQobmV3IEVTV2Vla2RheVBhcnNlcigpKTtcbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZnI6IE9wdGlvbnNSZXNvbHZlcldpdGhDYXN1YWwgPSAoY29uZmlnPzogQ29uZmlnKTogT3B0aW9ucyA9PiAoe1xuICAgIHBhcnNlcnM6IFtcbiAgICAgICAgbmV3IEZSRGVhZGxpbmVGb3JtYXRQYXJzZXIoY29uZmlnKSxcbiAgICAgICAgbmV3IEZSTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyKGNvbmZpZyksXG4gICAgICAgIG5ldyBGUlNsYXNoRGF0ZUZvcm1hdFBhcnNlcihjb25maWcpLFxuICAgICAgICBuZXcgRlJUaW1lQWdvRm9ybWF0UGFyc2VyKGNvbmZpZyksXG4gICAgICAgIG5ldyBGUlRpbWVFeHByZXNzaW9uUGFyc2VyKGNvbmZpZylcbiAgICBdLFxuICAgIHJlZmluZXJzOiBbXG4gICAgICAgIG5ldyBPdmVybGFwUmVtb3ZhbFJlZmluZXIoKSxcbiAgICAgICAgbmV3IEZvcndhcmREYXRlUmVmaW5lcigpLFxuICAgICAgICBuZXcgRlJNZXJnZURhdGVSYW5nZVJlZmluZXIoKSxcbiAgICAgICAgbmV3IEZSTWVyZ2VEYXRlVGltZVJlZmluZXIoKVxuICAgIF1cbn0pO1xuXG5mci5jYXN1YWwgPSAoKTogT3B0aW9ucyA9PiB7XG4gICAgY29uc3Qgb3B0aW9uOiBPcHRpb25zID0gZnIoe3N0cmljdDogZmFsc2V9KTtcblxuICAgIG9wdGlvbi5wYXJzZXJzIS51bnNoaWZ0KG5ldyBGUkNhc3VhbERhdGVQYXJzZXIoKSk7XG4gICAgb3B0aW9uLnBhcnNlcnMhLnVuc2hpZnQobmV3IEZSV2Vla2RheVBhcnNlcigpKTtcbiAgICBvcHRpb24ucGFyc2VycyEudW5zaGlmdChuZXcgRlJSZWxhdGl2ZURhdGVGb3JtYXRQYXJzZXIoKSk7XG4gICAgcmV0dXJuIG9wdGlvbjtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3Qgemg6IE9wdGlvbnNSZXNvbHZlciA9ICgpOiBPcHRpb25zID0+ICh7XG4gICAgcGFyc2VyczogW1xuICAgICAgICBuZXcgWkhIYW50RGF0ZVBhcnNlcigpLFxuICAgICAgICBuZXcgWkhIYW50V2Vla2RheVBhcnNlcigpLFxuICAgICAgICBuZXcgWkhIYW50VGltZUV4cHJlc3Npb25QYXJzZXIoKSxcbiAgICAgICAgbmV3IFpISGFudENhc3VhbERhdGVQYXJzZXIoKSxcbiAgICAgICAgbmV3IFpISGFudERlYWRsaW5lRm9ybWF0UGFyc2VyKClcbiAgICBdLFxuICAgIHJlZmluZXJzOiBbXG4gICAgICAgIG5ldyBPdmVybGFwUmVtb3ZhbFJlZmluZXIoKSxcbiAgICAgICAgbmV3IEZvcndhcmREYXRlUmVmaW5lcigpXG4gICAgXVxufSk7XG5cbmV4cG9ydCB7ZGUsIGVuLCBmciwgZW5fR0IsIGphLCBlcywgemh9OyIsImltcG9ydCAqIGFzIG1vbWVudCBmcm9tIFwibW9tZW50XCI7XG5pbXBvcnQge01vbWVudH0gZnJvbSBcIm1vbWVudFwiO1xuaW1wb3J0IFBhcnNlciBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHtQYXJzZWRSZXN1bHR9IGZyb20gXCIuLi8uLi9yZXN1bHRcIjtcbmltcG9ydCB7UGFyc2VPcHRpb25zfSBmcm9tIFwiLi4vLi4vY2hyb25vXCI7XG5pbXBvcnQge0RBWSwgSE9VUiwgTUVSSURJRU0sIE1JTExJU0VDT05ELCBNSU5VVEUsIE1PTlRILCBTRUNPTkQsIFlFQVJ9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgREVDYXN1YWxEYXRlUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBwcml2YXRlIFBBVFRFUk46IFJlZ0V4cCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICcoXFxcXFd8XikoJyArXG4gICAgICAgICdqZXR6dHwnICtcbiAgICAgICAgJyg/OmhldXRlfGRpZXNlbilcXFxccyoobW9yZ2VufHZvcm1pdHRhZ3xtaXR0YWd8bmFjaG1pdHRhZ3xhYmVuZCl8JyArXG4gICAgICAgICcoPzpoZXV0ZXxkaWVzZSlcXFxccypuYWNodHwnICtcbiAgICAgICAgJ2hldXRlfCcgK1xuICAgICAgICAnKD86KD86w7x8dWUpYmVyKT9tb3JnZW4oPzpcXFxccyoobW9yZ2VufHZvcm1pdHRhZ3xtaXR0YWd8bmFjaG1pdHRhZ3xhYmVuZHxuYWNodCkpP3wnICtcbiAgICAgICAgJyg/OnZvcik/Z2VzdGVybig/OlxcXFxzKihtb3JnZW58dm9ybWl0dGFnfG1pdHRhZ3xuYWNobWl0dGFnfGFiZW5kfG5hY2h0KSk/fCcgK1xuICAgICAgICAnbGV0enRlXFxcXHMqbmFjaHQnICtcbiAgICAgICAgJykoPz1cXFxcV3wkKScsICdpJyk7XG5cbiAgICBwcml2YXRlIE9USEVSX1BBVFRFUk5TOiBSZWdFeHBbXSA9IFtcbiAgICAgICAgLyg/OmhldXRlfGRpZXNlKVxccypuYWNodC8sXG4gICAgICAgIC9eKD86w7x8dWUpYmVybW9yZ2VuLyxcbiAgICAgICAgL15tb3JnZW4vLFxuICAgICAgICAvXmdlc3Rlcm4vLFxuICAgICAgICAvXnZvcmdlc3Rlcm4vLFxuICAgICAgICAvbGV0enRlXFxzKm5hY2h0L1xuICAgIF07XG5cbiAgICBwcml2YXRlIFRBRzogc3RyaW5nID0gJ0RFQ2FzdWFsRGF0ZVBhcnNlcic7XG5cbiAgICBwYXR0ZXJuKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiB0aGlzLlBBVFRFUk47XG4gICAgfVxuXG4gICAgZXh0cmFjdCh0ZXh0OiBzdHJpbmcsIHJlZjogRGF0ZSwgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSwgb3B0OiBQYXJzZU9wdGlvbnMpOiBQYXJzZWRSZXN1bHQgfCBudWxsIHtcbiAgICAgICAgY29uc3QgaW5kZXg6IG51bWJlciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFJlc3VsdCA9IG5ldyBQYXJzZWRSZXN1bHQoe1xuICAgICAgICAgICAgdGV4dDogbWF0Y2hbMF0uc3Vic3RyKG1hdGNoWzFdLmxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIHJlZlxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBtYXRjaGVkVGV4dDogc3RyaW5nID0gcmVzdWx0LnRleHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbGV0IHJlZk1vbWVudDogTW9tZW50ID0gbW9tZW50KHJlZik7XG4gICAgICAgIGxldCBzdGFydE1vbWVudDogTW9tZW50ID0gcmVmTW9tZW50LmNsb25lKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuT1RIRVJfUEFUVEVSTlNbMF0udGVzdChtYXRjaGVkVGV4dCkpIHtcbiAgICAgICAgICAgIC8vIE5vcm1hbGx5IG1lYW5zIHRoaXMgY29taW5nIG1pZG5pZ2h0XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoSE9VUiwgMjIpO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1FUklESUVNLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLk9USEVSX1BBVFRFUk5TWzFdLnRlc3QobWF0Y2hlZFRleHQpKSB7XG4gICAgICAgICAgICBzdGFydE1vbWVudC5hZGQocmVmTW9tZW50LmhvdXIoKSA+IDEgPyAyIDogMSwgJ2RheScpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuT1RIRVJfUEFUVEVSTlNbMl0udGVzdChtYXRjaGVkVGV4dCkpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIG5vdCBcIlRvbW9ycm93XCIgb24gbGF0ZSBuaWdodFxuICAgICAgICAgICAgaWYgKHJlZk1vbWVudC5ob3VyKCkgPiAxKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRNb21lbnQuYWRkKDEsICdkYXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLk9USEVSX1BBVFRFUk5TWzNdLnRlc3QobWF0Y2hlZFRleHQpKSB7XG4gICAgICAgICAgICBzdGFydE1vbWVudC5hZGQoLTEsICdkYXknKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLk9USEVSX1BBVFRFUk5TWzRdLnRlc3QobWF0Y2hlZFRleHQpKSB7XG4gICAgICAgICAgICBzdGFydE1vbWVudC5hZGQoLTIsICdkYXknKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLk9USEVSX1BBVFRFUk5TWzVdLnRlc3QobWF0Y2hlZFRleHQpKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoSE9VUiwgMCk7XG4gICAgICAgICAgICBpZiAocmVmTW9tZW50LmhvdXIoKSA+IDYpIHtcbiAgICAgICAgICAgICAgICBzdGFydE1vbWVudC5hZGQoLTEsICdkYXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVkVGV4dCA9PT0gJ2pldHp0Jykge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KEhPVVIsIHJlZk1vbWVudC5ob3VyKCkpO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1JTlVURSwgcmVmTW9tZW50Lm1pbnV0ZSgpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShTRUNPTkQsIHJlZk1vbWVudC5zZWNvbmQoKSk7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTUlMTElTRUNPTkQsIHJlZk1vbWVudC5taWxsaXNlY29uZCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlY29uZE1hdGNoOiBzdHJpbmcgPSBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XTtcbiAgICAgICAgaWYgKHNlY29uZE1hdGNoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNlY29uZE1hdGNoLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtb3JnZW4nOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoSE9VUiwgNik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3Zvcm1pdHRhZyc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShIT1VSLCA5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWl0dGFnJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KEhPVVIsIDEyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbmFjaG1pdHRhZyc6XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShIT1VSLCAxNSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNRVJJRElFTSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FiZW5kJzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KEhPVVIsIDE4KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1FUklESUVNLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbmFjaHQnOlxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoSE9VUiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihEQVksIHN0YXJ0TW9tZW50LmRhdGUoKSk7XG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTU9OVEgsIHN0YXJ0TW9tZW50Lm1vbnRoKCkgKyAxKTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCBzdGFydE1vbWVudC55ZWFyKCkpO1xuICAgICAgICByZXN1bHQudGFnc1t0aGlzLlRBR10gPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSIsImltcG9ydCAqIGFzIG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IFBhcnNlciBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHtQYXJzZWRSZXN1bHR9IGZyb20gXCIuLi8uLi9yZXN1bHRcIjtcbmltcG9ydCB7UGFyc2VPcHRpb25zfSBmcm9tIFwiLi4vLi4vY2hyb25vXCI7XG5pbXBvcnQge1VuaXRPZlRpbWV9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCB7SU5URUdFUl9XT1JEU19QQVRURVJOLCBtYXRjaEludGVnZXIsIG1hdGNoVW5pdH0gZnJvbSAnLi4vLi4vdXRpbHMvREUnO1xuaW1wb3J0IHtkZWFkbGluZUNhbGN1bGF0aW9uc30gZnJvbSBcIi4uLy4uL3V0aWxzL2dlbmVyYWxcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgREVEZWFkbGluZUZvcm1hdFBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgcHJpdmF0ZSBQQVRURVJOOiBSZWdFeHAgPSBuZXcgUmVnRXhwKCcoXFxcXFd8XiknICtcbiAgICAgICAgJyhpbnxuYWNoKVxcXFxzKicgK1xuICAgICAgICAnKCcgKyBJTlRFR0VSX1dPUkRTX1BBVFRFUk4gKyAnfFswLTldK3xlaW5pZ2VufGVpbmVbcm1dXFxcXHMqaGFsYmVufGVpbmVbcm1dKVxcXFxzKicgK1xuICAgICAgICAnKHNla3VuZGVuP3xtaW4oPzp1dGUpP24/fHN0dW5kZW4/fHRhZyg/OmVuKT98d29jaGVuP3xtb25hdCg/OmVuKT98amFocig/OmVuKT8pXFxcXHMqJyArXG4gICAgICAgICcoPz1cXFxcV3wkKScsICdpJ1xuICAgICk7XG5cbiAgICBwcml2YXRlIFNUUklDVF9QQVRURVJOOiBSZWdFeHAgPSBuZXcgUmVnRXhwKCcoXFxcXFd8XiknICtcbiAgICAgICAgJyhpbnxuYWNoKVxcXFxzKicgK1xuICAgICAgICAnKCcgKyBJTlRFR0VSX1dPUkRTX1BBVFRFUk4gKyAnfFswLTldK3xlaW5lKD86cnxtKT8pXFxcXHMqJyArXG4gICAgICAgICcoc2VrdW5kZW4/fG1pbnV0ZW4/fHN0dW5kZW4/fHRhZyg/OmVuKT8pXFxcXHMqJyArXG4gICAgICAgICcoPz1cXFxcV3wkKScsICdpJ1xuICAgICk7XG5cbiAgICBwcml2YXRlIFRBRzogc3RyaW5nID0gJ0RFRGVhZGxpbmVGb3JtYXRQYXJzZXInO1xuXG4gICAgcGF0dGVybigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTdHJpY3RNb2RlKCkgPyB0aGlzLlNUUklDVF9QQVRURVJOIDogdGhpcy5QQVRURVJOO1xuICAgIH1cblxuICAgIGV4dHJhY3QodGV4dDogc3RyaW5nLCByZWY6IERhdGUsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGluZGV4OiBudW1iZXIgPSBtYXRjaC5pbmRleCArIG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbWF0Y2hlZFRleHQ6IHN0cmluZyA9IG1hdGNoWzBdLnN1YnN0cihtYXRjaFsxXS5sZW5ndGgsIG1hdGNoWzBdLmxlbmd0aCAtIG1hdGNoWzFdLmxlbmd0aCk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBQYXJzZWRSZXN1bHQgPSBuZXcgUGFyc2VkUmVzdWx0KHtcbiAgICAgICAgICAgIHRleHQ6IG1hdGNoZWRUZXh0LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcbiAgICAgICAgbGV0IG51bTogbnVtYmVyID0gbWF0Y2hJbnRlZ2VyKG1hdGNoWzNdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBjb25zdCBtYXRjaGVkVW5pdDogVW5pdE9mVGltZSB8IHVuZGVmaW5lZCA9IG1hdGNoVW5pdChtYXRjaFs0XS50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgICBpZiAobnVtICYmIG1hdGNoZWRVbml0ICYmIGRlYWRsaW5lQ2FsY3VsYXRpb25zKG51bSwgbWF0Y2hlZFVuaXQsIHJlc3VsdCwgbW9tZW50KHJlZikpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufSIsImltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tIFwiLi4vLi4vcmVzdWx0XCI7XG5pbXBvcnQge1BhcnNlT3B0aW9uc30gZnJvbSBcIi4uLy4uL2Nocm9ub1wiO1xuaW1wb3J0IHtEQVksIE1PTlRILCBXRUVLREFZLCBZRUFSfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQge01PTlRIX09GRlNFVCwgV0VFS0RBWV9PRkZTRVQsIHllYXJDYWxjdWxhdGlvbn0gZnJvbSAnLi4vLi4vdXRpbHMvREUnO1xuaW1wb3J0IHtnZXRBcHByb3ByaWF0ZVllYXJ9IGZyb20gXCIuLi8uLi91dGlscy9nZW5lcmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERFTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBwcml2YXRlIFBBVFRFUk46IFJlZ0V4cCA9IG5ldyBSZWdFeHAoJyhcXFxcV3xeKScgK1xuICAgICAgICAnKD86YW1cXFxccyo/KT8nICtcbiAgICAgICAgJyg/OihTb25udGFnfE1vbnRhZ3xEaWVuc3RhZ3xNaXR0d29jaHxEb25uZXJzdGFnfEZyZWl0YWd8U2Ftc3RhZ3xTb3xNb3xEaXxNaXxEb3xGcnxTYSlcXFxccyosP1xcXFxzKik/JyArXG4gICAgICAgICcoPzpkZW5cXFxccyopPycgK1xuICAgICAgICAnKFswLTldezEsMn0pXFxcXC4nICtcbiAgICAgICAgJyg/OlxcXFxzKig/OmJpcyg/OlxcXFxzKig/OmFtfHp1bSkpP3xcXFxcLXxcXFxc4oCTfFxcXFxzKVxcXFxzKihbMC05XXsxLDJ9KVxcXFwuKT9cXFxccyonICtcbiAgICAgICAgJyhKYW4oPzp1YXJ8XFxcXC4pP3xGZWIoPzpydWFyfFxcXFwuKT98TcOkcig/Onp8XFxcXC4pP3xNYWVyenxNcnpcXFxcLj98QXByKD86aWx8XFxcXC4pP3xNYWl8SnVuKD86aXxcXFxcLik/fEp1bCg/Oml8XFxcXC4pP3xBdWcoPzp1c3R8XFxcXC4pP3xTZXAoPzp0fHRcXFxcLnx0ZW1iZXJ8XFxcXC4pP3xPa3QoPzpvYmVyfFxcXFwuKT98Tm92KD86ZW1iZXJ8XFxcXC4pP3xEZXooPzplbWJlcnxcXFxcLik/KScgK1xuICAgICAgICAnKD86JyArXG4gICAgICAgICcsP1xcXFxzKihbMC05XXsxLDR9KD8hW15cXFxcc11cXFxcZCkpJyArXG4gICAgICAgICcoXFxcXHMqW3ZuXVxcXFwuP1xcXFxzKkMoPzpocik/XFxcXC4/KT8nICtcbiAgICAgICAgJyk/JyArXG4gICAgICAgICcoPz1cXFxcV3wkKScsICdpJ1xuICAgICk7XG5cbiAgICBwcml2YXRlIFdFRUtEQVlfR1JPVVA6IG51bWJlciA9IDI7XG4gICAgcHJpdmF0ZSBEQVRFX0dST1VQOiBudW1iZXIgPSAzO1xuICAgIHByaXZhdGUgREFURV9UT19HUk9VUDogbnVtYmVyID0gNDtcbiAgICBwcml2YXRlIE1PTlRIX05BTUVfR1JPVVA6IG51bWJlciA9IDU7XG4gICAgcHJpdmF0ZSBZRUFSX0dST1VQOiBudW1iZXIgPSA2O1xuICAgIHByaXZhdGUgWUVBUl9CRV9HUk9VUDogbnVtYmVyID0gNztcblxuXG4gICAgcHJpdmF0ZSBUQUc6IHN0cmluZyA9ICdERU1vbnRoTmFtZUxpdHRsZUVuZGlhblBhcnNlcic7XG5cbiAgICBwYXR0ZXJuKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiB0aGlzLlBBVFRFUk47XG4gICAgfVxuXG4gICAgZXh0cmFjdCh0ZXh0OiBzdHJpbmcsIHJlZjogRGF0ZSwgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSwgb3B0OiBQYXJzZU9wdGlvbnMpOiBQYXJzZWRSZXN1bHQgfCBudWxsIHtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBQYXJzZWRSZXN1bHQgPSBuZXcgUGFyc2VkUmVzdWx0KHtcbiAgICAgICAgICAgIHRleHQ6IG1hdGNoWzBdLnN1YnN0cihtYXRjaFsxXS5sZW5ndGgsIG1hdGNoWzBdLmxlbmd0aCAtIG1hdGNoWzFdLmxlbmd0aCksXG4gICAgICAgICAgICBpbmRleDogbWF0Y2guaW5kZXggKyBtYXRjaFsxXS5sZW5ndGgsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbW9udGg6IG51bWJlciA9IE1PTlRIX09GRlNFVFttYXRjaFt0aGlzLk1PTlRIX05BTUVfR1JPVVBdLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgIGNvbnN0IGRheTogbnVtYmVyID0gcGFyc2VJbnQobWF0Y2hbdGhpcy5EQVRFX0dST1VQXSwgMTApO1xuXG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oREFZLCBkYXkpO1xuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1PTlRILCBtb250aCk7XG5cbiAgICAgICAgbGV0IHllYXI6IG51bWJlciB8IG51bGwgPSB5ZWFyQ2FsY3VsYXRpb24obWF0Y2hbdGhpcy5ZRUFSX0dST1VQXSwgbWF0Y2hbdGhpcy5ZRUFSX0JFX0dST1VQXSk7XG5cbiAgICAgICAgaWYgKHllYXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oWUVBUiwgeWVhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRBcHByb3ByaWF0ZVllYXIocmVzdWx0LnN0YXJ0LCByZWYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2Vla2RheSBjb21wb25lbnRcbiAgICAgICAgaWYgKG1hdGNoW3RoaXMuV0VFS0RBWV9HUk9VUF0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oV0VFS0RBWSwgV0VFS0RBWV9PRkZTRVRbbWF0Y2hbdGhpcy5XRUVLREFZX0dST1VQXS50b0xvd2VyQ2FzZSgpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXh0IGNhbiBiZSAncmFuZ2UnIHZhbHVlLiBTdWNoIGFzICcxMiAtIDEzIEphbnVhcnkgMjAxMidcbiAgICAgICAgaWYgKG1hdGNoW3RoaXMuREFURV9UT19HUk9VUF0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5lbmQgPSByZXN1bHQuc3RhcnQuY2xvbmUoKTtcbiAgICAgICAgICAgIHJlc3VsdC5lbmQuYXNzaWduKERBWSwgcGFyc2VJbnQobWF0Y2hbdGhpcy5EQVRFX1RPX0dST1VQXSwgMTApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC50YWdzW3RoaXMuVEFHXSA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG59IiwiaW1wb3J0IFBhcnNlciBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHtQYXJzZWRSZXN1bHR9IGZyb20gXCIuLi8uLi9yZXN1bHRcIjtcbmltcG9ydCB7UGFyc2VPcHRpb25zfSBmcm9tIFwiLi4vLi4vY2hyb25vXCI7XG5pbXBvcnQge0RBWSwgTU9OVEgsIFlFQVJ9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCB7TU9OVEhfT0ZGU0VULCB5ZWFyQ2FsY3VsYXRpb259IGZyb20gJy4uLy4uL3V0aWxzL0RFJztcbmltcG9ydCB7Z2V0QXBwcm9wcmlhdGVZZWFyfSBmcm9tIFwiLi4vLi4vdXRpbHMvZ2VuZXJhbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBERU1vbnRoTmFtZVBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgcHJpdmF0ZSBQQVRURVJOOiBSZWdFeHAgPSBuZXcgUmVnRXhwKCcoXnxcXFxcRFxcXFxzK3xbXlxcXFx3XFxcXHNdKScgK1xuICAgICAgICAnKEphblxcXFwuP3xKYW51YXJ8RmViXFxcXC4/fEZlYnJ1YXJ8TcOkclxcXFwuP3xNKD86w6R8YWUpcnp8TXJ6XFxcXC4/fEFwclxcXFwuP3xBcHJpbHxNYWlcXFxcLj98SnVuXFxcXC4/fEp1bml8SnVsXFxcXC4/fEp1bGl8QXVnXFxcXC4/fEF1Z3VzdHxTZXBcXFxcLj98U2VwdFxcXFwuP3xTZXB0ZW1iZXJ8T2t0XFxcXC4/fE9rdG9iZXJ8Tm92XFxcXC4/fE5vdmVtYmVyfERlelxcXFwuP3xEZXplbWJlciknICtcbiAgICAgICAgJ1xcXFxzKicgK1xuICAgICAgICAnKD86JyArXG4gICAgICAgICcsP1xcXFxzKig/OihbMC05XXs0fSkoXFxcXHMqW3ZuXVxcXFwuP1xcXFxzKkMoPzpocik/XFxcXC4/KT98KFswLTldezEsNH0pXFxcXHMqKFt2bl1cXFxcLj9cXFxccypDKD86aHIpP1xcXFwuPykpJyArXG4gICAgICAgICcpPycgK1xuICAgICAgICAnKD89W15cXFxcc1xcXFx3XXwkKScsICdpJyk7XG5cbiAgICBwcml2YXRlIE1PTlRIX05BTUVfR1JPVVA6IG51bWJlciA9IDI7XG4gICAgcHJpdmF0ZSBZRUFSX0dST1VQOiBudW1iZXIgPSAzO1xuICAgIHByaXZhdGUgWUVBUl9CRV9HUk9VUDogbnVtYmVyID0gNDtcbiAgICBwcml2YXRlIFlFQVJfR1JPVVAyOiBudW1iZXIgPSA1O1xuICAgIHByaXZhdGUgWUVBUl9CRV9HUk9VUDI6IG51bWJlciA9IDY7XG5cbiAgICBwcml2YXRlIFRBRzogc3RyaW5nID0gJ0RFTW9udGhOYW1lUGFyc2VyJztcblxuICAgIHBhdHRlcm4oKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuUEFUVEVSTjtcbiAgICB9XG5cbiAgICBleHRyYWN0KHRleHQ6IHN0cmluZywgcmVmOiBEYXRlLCBtYXRjaDogUmVnRXhwRXhlY0FycmF5LCBvcHQ6IFBhcnNlT3B0aW9ucyk6IFBhcnNlZFJlc3VsdCB8IG51bGwge1xuICAgICAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFJlc3VsdCA9IG5ldyBQYXJzZWRSZXN1bHQoe1xuICAgICAgICAgICAgdGV4dDogbWF0Y2hbMF0uc3Vic3RyKG1hdGNoWzFdLmxlbmd0aCwgbWF0Y2hbMF0ubGVuZ3RoIC0gbWF0Y2hbMV0ubGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4OiBtYXRjaC5pbmRleCArIG1hdGNoWzFdLmxlbmd0aCxcbiAgICAgICAgICAgIHJlZjogcmVmLFxuICAgICAgICB9KTtcblxuXG4gICAgICAgIGNvbnN0IG1vbnRoID0gTU9OVEhfT0ZGU0VUW21hdGNoW3RoaXMuTU9OVEhfTkFNRV9HUk9VUF0udG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KERBWSwgMSk7XG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTU9OVEgsIG1vbnRoKTtcblxuICAgICAgICBsZXQgeWVhcjogbnVtYmVyIHwgbnVsbCA9IHllYXJDYWxjdWxhdGlvbihtYXRjaFt0aGlzLllFQVJfR1JPVVBdIHx8IG1hdGNoW3RoaXMuWUVBUl9HUk9VUDJdLCBtYXRjaFt0aGlzLllFQVJfQkVfR1JPVVBdIHx8IG1hdGNoW3RoaXMuWUVBUl9CRV9HUk9VUDJdKTtcblxuICAgICAgICBpZiAoeWVhciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCB5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldEFwcHJvcHJpYXRlWWVhcihyZXN1bHQuc3RhcnQsIHJlZik7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQudGFnc1t0aGlzLlRBR10gPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuIiwiLypcbiAgICBEYXRlIGZvcm1hdCB3aXRoIHNsYXNoIFwiL1wiIChhbHNvIFwiLVwiIGFuZCBcIi5cIikgYmV0d2VlbiBudW1iZXJzXG4gICAgLSBUdWVzZGF5IDExLzMvMjAxNVxuICAgIC0gMTEvMy8yMDE1XG4gICAgLSAxMS8zXG4qL1xuaW1wb3J0IFBhcnNlciBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHtQYXJzZWRSZXN1bHR9IGZyb20gXCIuLi8uLi9yZXN1bHRcIjtcbmltcG9ydCB7UGFyc2VPcHRpb25zfSBmcm9tIFwiLi4vLi4vY2hyb25vXCI7XG5pbXBvcnQge0RBWSwgTU9OVEgsIFdFRUtEQVksIFlFQVJ9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCB7V0VFS0RBWV9PRkZTRVR9IGZyb20gJy4uLy4uL3V0aWxzL0RFJztcbmltcG9ydCAqIGFzIG1vbWVudCBmcm9tICdtb21lbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBERVNsYXNoRGF0ZUZvcm1hdFBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgcHJpdmF0ZSBQQVRURVJOOiBSZWdFeHAgPSBuZXcgUmVnRXhwKCcoXFxcXFd8XiknICtcbiAgICAgICAgJyg/OicgK1xuICAgICAgICAnKD86YW1cXFxccyo/KT8nICtcbiAgICAgICAgJygoPzpzb25udGFnfHNvfG1vbnRhZ3xtb3xkaWVuc3RhZ3xkaXxtaXR0d29jaHxtaXxkb25uZXJzdGFnfGRvfGZyZWl0YWd8ZnJ8c2Ftc3RhZ3xzYSkpJyArXG4gICAgICAgICdcXFxccypcXFxcLD9cXFxccyonICtcbiAgICAgICAgJyg/OmRlblxcXFxzKik/JyArXG4gICAgICAgICcpPycgK1xuICAgICAgICAnKFswLTNdezAsMX1bMC05XXsxfSlbXFxcXC9cXFxcLlxcXFwtXShbMC0zXXswLDF9WzAtOV17MX0pJyArXG4gICAgICAgICcoPzonICtcbiAgICAgICAgJ1tcXFxcL1xcXFwuXFxcXC1dJyArXG4gICAgICAgICcoWzAtOV17NH1cXHMqXFwsP1xccyp8WzAtOV17Mn1cXHMqXFwsP1xccyopJyArXG4gICAgICAgICcpPycgK1xuICAgICAgICAnKFxcXFxXfCQpJywgJ2knKTtcblxuICAgIHByaXZhdGUgT1BFTklOR19HUk9VUDogbnVtYmVyID0gMTtcbiAgICBwcml2YXRlIFdFRUtEQVlfR1JPVVA6IG51bWJlciA9IDI7XG4gICAgcHJpdmF0ZSBEQVlfR1JPVVA6IG51bWJlciA9IDM7XG4gICAgcHJpdmF0ZSBNT05USF9HUk9VUDogbnVtYmVyID0gNDtcbiAgICBwcml2YXRlIFlFQVJfR1JPVVA6IG51bWJlciA9IDU7XG4gICAgcHJpdmF0ZSBFTkRJTkdfR1JPVVA6IG51bWJlciA9IDY7XG5cbiAgICBwcml2YXRlIFRBRzogc3RyaW5nID0gJ0RFU2xhc2hEYXRlRm9ybWF0UGFyc2VyJztcblxuICAgIHByaXZhdGUgT1RIRVJfUEFUVEVSTlM6IFJlZ0V4cFtdID0gW1xuICAgICAgICAvXlxcZFxcLlxcZCQvLFxuICAgICAgICAvXlxcZFxcLlxcZHsxLDJ9XFwuXFxkezEsMn0kL1xuICAgIF07XG5cbiAgICBwYXR0ZXJuKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiB0aGlzLlBBVFRFUk47XG4gICAgfVxuXG4gICAgZXh0cmFjdCh0ZXh0OiBzdHJpbmcsIHJlZjogRGF0ZSwgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSwgb3B0OiBQYXJzZU9wdGlvbnMpOiBQYXJzZWRSZXN1bHQgfCBudWxsIHtcbiAgICAgICAgaWYgKG1hdGNoW3RoaXMuT1BFTklOR19HUk9VUF0gPT09ICcvJyB8fCBtYXRjaFt0aGlzLkVORElOR19HUk9VUF0gPT09ICcvJykge1xuICAgICAgICAgICAgLy8gTG9uZyBza2lwLCBpZiB0aGVyZSBpcyBzb21lIG92ZXJsYXBwaW5nIGxpa2U6XG4gICAgICAgICAgICAvLyBYWFsvWVkvWlpdXG4gICAgICAgICAgICAvLyBbWFgvWVkvXVpaXG4gICAgICAgICAgICBtYXRjaC5pbmRleCArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGluZGV4OiBudW1iZXIgPSBtYXRjaC5pbmRleCArIG1hdGNoW3RoaXMuT1BFTklOR19HUk9VUF0ubGVuZ3RoO1xuICAgICAgICBjb25zdCBtYXRjaGVkVGV4dDogc3RyaW5nID0gbWF0Y2hbMF0uc3Vic3RyKG1hdGNoW3RoaXMuT1BFTklOR19HUk9VUF0ubGVuZ3RoLCBtYXRjaFswXS5sZW5ndGggLSBtYXRjaFt0aGlzLkVORElOR19HUk9VUF0ubGVuZ3RoKTtcblxuICAgICAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFJlc3VsdCA9IG5ldyBQYXJzZWRSZXN1bHQoe1xuICAgICAgICAgICAgdGV4dDogbWF0Y2hlZFRleHQsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWRUZXh0Lm1hdGNoKHRoaXMuT1RIRVJfUEFUVEVSTlNbMF0pIHx8IG1hdGNoZWRUZXh0Lm1hdGNoKHRoaXMuT1RIRVJfUEFUVEVSTlNbMV0pKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAvLyBNTS9kZCAtPiBPS1xuICAgICAgICAvLyBNTS5kZCAtPiBOR1xuICAgICAgICBpZiAoIW1hdGNoW3RoaXMuWUVBUl9HUk9VUF0gJiYgbWF0Y2hbMF0uaW5kZXhPZignLycpIDwgMCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgbGV0IHllYXI6IG51bWJlciA9IHBhcnNlSW50KG1hdGNoW3RoaXMuWUVBUl9HUk9VUF0gfHwgbW9tZW50KHJlZikueWVhcigpICsgJycsIDEwKTtcbiAgICAgICAgY29uc3QgbW9udGg6IG51bWJlciA9IHBhcnNlSW50KG1hdGNoW3RoaXMuTU9OVEhfR1JPVVBdLCAxMCk7XG4gICAgICAgIGNvbnN0IGRheTogbnVtYmVyID0gcGFyc2VJbnQobWF0Y2hbdGhpcy5EQVlfR1JPVVBdLCAxMCk7XG5cbiAgICAgICAgaWYgKChtb250aCA8IDEgfHwgbW9udGggPiAxMikgfHwgKGRheSA8IDEgfHwgZGF5ID4gMzEpKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBpZiAoeWVhciA8IDEwMCkge1xuICAgICAgICAgICAgaWYgKHllYXIgPiA1MCkge1xuICAgICAgICAgICAgICAgIHllYXIgPSB5ZWFyICsgMTkwMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeWVhciA9IHllYXIgKyAyMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihEQVksIGRheSk7XG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTU9OVEgsIG1vbnRoKTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCB5ZWFyKTtcblxuICAgICAgICAvLyBEYXkgb2Ygd2Vla1xuICAgICAgICBpZiAobWF0Y2hbdGhpcy5XRUVLREFZX0dST1VQXSkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihXRUVLREFZLCBXRUVLREFZX09GRlNFVFttYXRjaFt0aGlzLldFRUtEQVlfR1JPVVBdLnRvTG93ZXJDYXNlKCldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC50YWdzW3RoaXMuVEFHXSA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IFBhcnNlciBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHtQYXJzZWRSZXN1bHR9IGZyb20gXCIuLi8uLi9yZXN1bHRcIjtcbmltcG9ydCB7UGFyc2VPcHRpb25zfSBmcm9tIFwiLi4vLi4vY2hyb25vXCI7XG5pbXBvcnQge0RBWSwgSE9VUiwgTUlOVVRFLCBNT05USCwgU0VDT05ELCBVbml0T2ZUaW1lLCBXRUVLLCBXRUVLREFZLCBZRUFSfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQge0lOVEVHRVJfV09SRFNfUEFUVEVSTiwgbWF0Y2hJbnRlZ2VyLCBtYXRjaFVuaXR9IGZyb20gJy4uLy4uL3V0aWxzL0RFJztcbmltcG9ydCAqIGFzIG1vbWVudCBmcm9tIFwibW9tZW50XCI7XG5pbXBvcnQge01vbWVudH0gZnJvbSBcIm1vbWVudFwiO1xuXG5lbnVtIE1PREUge1xuICAgIFRJTUUsXG4gICAgREFURSxcbiAgICBXRUVLLFxuICAgIE5PTkUsXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERFVGltZUFnb0Zvcm1hdFBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgcHJpdmF0ZSBQQVRURVJOOiBSZWdFeHAgPSBuZXcgUmVnRXhwKCcnICtcbiAgICAgICAgJyhcXFxcV3xeKXZvclxcXFxzKicgK1xuICAgICAgICAnKCcgKyBJTlRFR0VSX1dPUkRTX1BBVFRFUk4gKyAnfFswLTldK3xlaW5pZ2VufGVpbmVbcm1dXFxcXHMqaGFsYmVufGVpbmVbcm1dKVxcXFxzKicgK1xuICAgICAgICAnKHNla3VuZGVuP3xtaW4oPzp1dGUpP24/fHN0dW5kZW4/fHdvY2hlbj98dGFnKD86ZW4pP3xtb25hdCg/OmVuKT98amFocig/OmVuKT8pXFxcXHMqJyArXG4gICAgICAgICcoPz0oPzpcXFxcV3wkKSknLCAnaScpO1xuXG4gICAgcHJpdmF0ZSBTVFJJQ1RfUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cCgnJyArXG4gICAgICAgICcoXFxcXFd8Xil2b3JcXFxccyonICtcbiAgICAgICAgJyhbMC05XSt8ZWluZSg/OnJ8bSkpXFxcXHMqJyArXG4gICAgICAgICcoc2VrdW5kZW4/fG1pbnV0ZW4/fHN0dW5kZW4/fHRhZyg/OmVuKT8pJyArXG4gICAgICAgICcoPz0oPzpcXFxcV3wkKSknLCAnaScpO1xuXG4gICAgcHJpdmF0ZSBUQUc6IHN0cmluZyA9ICdERVRpbWVBZ29Gb3JtYXRQYXJzZXInO1xuXG5cbiAgICBwYXR0ZXJuKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU3RyaWN0TW9kZSgpID8gdGhpcy5TVFJJQ1RfUEFUVEVSTiA6IHRoaXMuUEFUVEVSTjtcbiAgICB9XG5cbiAgICBleHRyYWN0KHRleHQ6IHN0cmluZywgcmVmOiBEYXRlLCBtYXRjaDogUmVnRXhwRXhlY0FycmF5LCBvcHQ6IFBhcnNlT3B0aW9ucyk6IFBhcnNlZFJlc3VsdCB8IG51bGwge1xuICAgICAgICBpZiAobWF0Y2guaW5kZXggPiAwICYmIHRleHRbbWF0Y2guaW5kZXggLSAxXS5tYXRjaCgvXFx3LykpIHJldHVybiBudWxsO1xuXG4gICAgICAgIGNvbnN0IG1hdGNoZWRUZXh0OiBzdHJpbmcgPSBtYXRjaFswXS5zdWJzdHIobWF0Y2hbMV0ubGVuZ3RoLCBtYXRjaFswXS5sZW5ndGggLSBtYXRjaFsxXS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBpbmRleDogbnVtYmVyID0gbWF0Y2guaW5kZXggKyBtYXRjaFsxXS5sZW5ndGg7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBQYXJzZWRSZXN1bHQgPSBuZXcgUGFyc2VkUmVzdWx0KHtcbiAgICAgICAgICAgIHRleHQ6IG1hdGNoZWRUZXh0LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbWF0Y2hlZFVuaXQ6IFVuaXRPZlRpbWUgfCB1bmRlZmluZWQgPSBtYXRjaFVuaXQobWF0Y2hbM10udG9Mb3dlckNhc2UoKSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWRVbml0KSB7XG4gICAgICAgICAgICBjb25zdCBudW06IG51bWJlciA9IG1hdGNoSW50ZWdlcihtYXRjaFsyXS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIGNvbnN0IG1vbWVudFJlZjogTW9tZW50ID0gbW9tZW50KHJlZik7XG4gICAgICAgICAgICBsZXQgbW9kZTogTU9ERSA9IE1PREUuTk9ORTtcbiAgICAgICAgICAgIHN3aXRjaCAobWF0Y2hlZFVuaXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEhPVVI6XG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFJlZi5hZGQoLW51bSwgJ2hvdXInKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IE1PREUuVElNRTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBNSU5VVEU6XG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFJlZi5hZGQoLW51bSwgJ21pbnV0ZScpO1xuICAgICAgICAgICAgICAgICAgICBtb2RlID0gTU9ERS5USU1FO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFNFQ09ORDpcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50UmVmLmFkZCgtbnVtLCAnc2Vjb25kJyk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBNT0RFLlRJTUU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgREFZOlxuICAgICAgICAgICAgICAgICAgICBtb21lbnRSZWYuYWRkKC1udW0sICdkJyk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBNT0RFLkRBVEU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTU9OVEg6XG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFJlZi5hZGQoLW51bSwgJ21vbnRoJyk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBNT0RFLkRBVEU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgWUVBUjpcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50UmVmLmFkZCgtbnVtLCAneWVhcicpO1xuICAgICAgICAgICAgICAgICAgICBtb2RlID0gTU9ERS5EQVRFO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFdFRUs6XG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFJlZi5hZGQoLW51bSwgJ3dlZWsnKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZSA9IE1PREUuV0VFSztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtb2RlICE9PSBNT0RFLk5PTkUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudGFnc1t0aGlzLlRBR10gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE1PREUuV0VFSzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShEQVksIG1vbWVudFJlZi5kYXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1PTlRILCBtb21lbnRSZWYubW9udGgoKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KFlFQVIsIG1vbWVudFJlZi55ZWFyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KFdFRUtEQVksIG1vbWVudFJlZi5kYXkoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNT0RFLkRBVEU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKERBWSwgbW9tZW50UmVmLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1PTlRILCBtb21lbnRSZWYubW9udGgoKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCBtb21lbnRSZWYueWVhcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIE1PREUuVElNRTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShEQVksIG1vbWVudFJlZi5kYXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1PTlRILCBtb21lbnRSZWYubW9udGgoKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KFlFQVIsIG1vbWVudFJlZi55ZWFyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihIT1VSLCBtb21lbnRSZWYuaG91cigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTUlOVVRFLCBtb21lbnRSZWYubWludXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihTRUNPTkQsIG1vbWVudFJlZi5zZWNvbmQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG59IiwiaW1wb3J0IFBhcnNlciBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHtQYXJzZWRDb21wb25lbnRzLCBQYXJzZWRSZXN1bHR9IGZyb20gXCIuLi8uLi9yZXN1bHRcIjtcbmltcG9ydCB7UGFyc2VPcHRpb25zfSBmcm9tIFwiLi4vLi4vY2hyb25vXCI7XG5pbXBvcnQge0RBWSwgSE9VUiwgTUVSSURJRU0sIE1JTlVURSwgTU9OVEgsIFNFQ09ORCwgWUVBUn0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuaW1wb3J0ICogYXMgbW9tZW50IGZyb20gXCJtb21lbnRcIjtcbmltcG9ydCB7TW9tZW50fSBmcm9tIFwibW9tZW50XCI7XG5cbnR5cGUgVGltZSA9IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBERVRpbWVFeHByZXNzaW9uUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBwcml2YXRlIFBBVFRFUk46IFJlZ0V4cCA9IG5ldyBSZWdFeHAoXCIoXnxcXFxcc3xUKVwiICtcbiAgICAgICAgXCIoPzooPzp1bXx2b24pXFxcXHMqKT9cIiArXG4gICAgICAgIFwiKFxcXFxkezEsNH18bWl0dGFncz98bWl0dGVybmFjaHRzPylcIiArXG4gICAgICAgIFwiKD86XCIgK1xuICAgICAgICBcIig/OlxcXFwufFxcXFw6fFxcXFzvvJopKFxcXFxkezEsMn0pXCIgK1xuICAgICAgICBcIig/OlwiICtcbiAgICAgICAgXCIoPzpcXFxcOnxcXFxc77yaKShcXFxcZHsyfSlcIiArXG4gICAgICAgIFwiKT9cIiArXG4gICAgICAgIFwiKT9cIiArXG4gICAgICAgIFwiKD86XFxcXHMqdWhyKT9cIiArXG4gICAgICAgIFwiKD86XFxcXHMqKG1vcmdlbnN8dm9ybWl0dGFnc3xtaXR0YWdzfG5hY2htaXR0YWdzfGFiZW5kc3xuYWNodHMpKT9cIiArXG4gICAgICAgIFwiKD89XFxcXFd8JClcIiwgJ2knKTtcblxuICAgIHByaXZhdGUgRU5EX1BBVFRFUk46IFJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJeXFxcXHMqXCIgK1xuICAgICAgICBcIihcXFxcLXxcXFxc4oCTfFxcXFx+fFxcXFzjgJx8YmlzfFxcXFw/KVxcXFxzKlwiICtcbiAgICAgICAgXCIoXFxcXGR7MSw0fSlcIiArXG4gICAgICAgIFwiKD86XCIgK1xuICAgICAgICBcIig/OlxcXFwufFxcXFw6fFxcXFzvvJopKFxcXFxkezEsMn0pXCIgK1xuICAgICAgICBcIig/OlwiICtcbiAgICAgICAgXCIoPzpcXFxcLnxcXFxcOnxcXFxc77yaKShcXFxcZHsxLDJ9KVwiICtcbiAgICAgICAgXCIpP1wiICtcbiAgICAgICAgXCIpP1wiICtcbiAgICAgICAgXCIoPzpcXFxccyoobW9yZ2Vuc3x2b3JtaXR0YWdzfG1pdHRhZ3N8bmFjaG1pdHRhZ3N8YWJlbmRzfG5hY2h0cykpP1wiICtcbiAgICAgICAgXCIoPz1cXFxcV3wkKVwiLCAnaScpO1xuXG4gICAgcHJpdmF0ZSBIT1VSX0dST1VQOiBudW1iZXIgPSAyO1xuICAgIHByaXZhdGUgTUlOVVRFX0dST1VQOiBudW1iZXIgPSAzO1xuICAgIHByaXZhdGUgU0VDT05EX0dST1VQOiBudW1iZXIgPSA0O1xuICAgIHByaXZhdGUgQU1fUE1fSE9VUl9HUk9VUDogbnVtYmVyID0gNTtcblxuICAgIHByaXZhdGUgVEFHOiBzdHJpbmcgPSAnREVUaW1lRXhwcmVzc2lvblBhcnNlcic7XG5cbiAgICBwcml2YXRlIE9USEVSX1BBVFRFUk5TOiBSZWdFeHBbXSA9IFtcbiAgICAgICAgL21pdHRhZ3M/L2ksXG4gICAgICAgIC9taXR0ZXJuYWNodHM/L2ksXG4gICAgICAgIC9eXFxzKihbK1xcLV0pXFxzKlxcZHszLDR9JC8sXG4gICAgICAgIC9eXFxkKyQvXG4gICAgXTtcblxuICAgIHBhdHRlcm4oKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuUEFUVEVSTjtcbiAgICB9XG5cbiAgICBleHRyYWN0KHRleHQ6IHN0cmluZywgcmVmOiBEYXRlLCBtYXRjaDogUmVnRXhwRXhlY0FycmF5LCBvcHQ6IFBhcnNlT3B0aW9ucyk6IFBhcnNlZFJlc3VsdCB8IG51bGwge1xuICAgICAgICAvLyBUaGlzIHBhdHRlcm4gY2FuIGJlIG92ZXJsYXBlZCBFeC4gWzEyXSBBTSwgMVsyXSBBTVxuICAgICAgICBpZiAobWF0Y2guaW5kZXggPiAwICYmIHRleHRbbWF0Y2guaW5kZXggLSAxXS5tYXRjaCgvXFx3LykpIHJldHVybiBudWxsO1xuXG4gICAgICAgIGNvbnN0IHJlZk1vbWVudDogTW9tZW50ID0gbW9tZW50KHJlZik7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBQYXJzZWRSZXN1bHQgPSBuZXcgUGFyc2VkUmVzdWx0KHtcbiAgICAgICAgICAgIHRleHQ6IG1hdGNoWzBdLnN1YnN0cmluZyhtYXRjaFsxXS5sZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXg6IG1hdGNoLmluZGV4ICsgbWF0Y2hbMV0ubGVuZ3RoLFxuICAgICAgICAgICAgcmVmXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3VsdC50YWdzW3RoaXMuVEFHXSA9IHRydWU7XG5cbiAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KERBWSwgcmVmTW9tZW50LmRhdGUoKSk7XG4gICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNT05USCwgcmVmTW9tZW50Lm1vbnRoKCkgKyAxKTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KFlFQVIsIHJlZk1vbWVudC55ZWFyKCkpO1xuXG4gICAgICAgIGlmICghdGhpcy5leHRyYWN0Rmlyc3RDaHVuayhyZXN1bHQsIG1hdGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuZXh0cmFjdFNlY29uZENodW5rKHRleHQsIHJlc3VsdCkgJiYgcmVzdWx0LnRleHQubWF0Y2godGhpcy5PVEhFUl9QQVRURVJOU1szXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGV4dHJhY3RGaXJzdENodW5rKHJlc3VsdDogUGFyc2VkUmVzdWx0LCBtYXRjaDogUmVnRXhwRXhlY0FycmF5KTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHRpbWU6IFRpbWUgfCBmYWxzZSA9IHRoaXMuZ2V0VGltZShtYXRjaCk7XG4gICAgICAgIGlmICghdGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IFtob3VyLCBtaW51dGUsIHNlY29uZCwgbWVyaWRpZW1dOiBUaW1lID0gdGltZTtcblxuICAgICAgICBpZiAoc2Vjb25kID4gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oU0VDT05ELCBzZWNvbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0gQU0gJiBQTVxuICAgICAgICBpZiAobWF0Y2hbdGhpcy5BTV9QTV9IT1VSX0dST1VQXSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPiAxMikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgYW1wbTogc3RyaW5nID0gbWF0Y2hbdGhpcy5BTV9QTV9IT1VSX0dST1VQXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGFtcG0gPT09ICdtb3JnZW5zJyB8fCBhbXBtID09PSAndm9ybWl0dGFncycpIHtcbiAgICAgICAgICAgICAgICBtZXJpZGllbSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSBob3VyID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVyaWRpZW0gPSAxO1xuICAgICAgICAgICAgICAgIGlmIChob3VyICE9PSAxMikgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oSE9VUiwgaG91cik7XG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTUlOVVRFLCBtaW51dGUpO1xuXG4gICAgICAgIGlmIChtZXJpZGllbSA+PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1FUklESUVNLCBtZXJpZGllbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1FUklESUVNLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1FUklESUVNLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgZXh0cmFjdFNlY29uZENodW5rKHRleHQ6IHN0cmluZywgcmVzdWx0OiBQYXJzZWRSZXN1bHQpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGwgPSB0aGlzLkVORF9QQVRURVJOLmV4ZWModGV4dC5zdWJzdHJpbmcocmVzdWx0LmluZGV4ICsgcmVzdWx0LnRleHQubGVuZ3RoKSk7XG5cbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGF0dGVybiBcIllZLllZIC1YWFhYXCIgaXMgbW9yZSBsaWtlIHRpbWV6b25lIG9mZnNldFxuICAgICAgICBpZiAobWF0Y2hbMF0ubWF0Y2godGhpcy5PVEhFUl9QQVRURVJOU1syXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGltZTogVGltZSB8IGZhbHNlID0gdGhpcy5nZXRUaW1lKG1hdGNoKTtcbiAgICAgICAgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBbaG91ciwgbWludXRlLCBzZWNvbmQsIG1lcmlkaWVtXTogVGltZSA9IHRpbWU7XG5cbiAgICAgICAgaWYgKCFyZXN1bHQuZW5kKSB7XG4gICAgICAgICAgICByZXN1bHQuZW5kID0gbmV3IFBhcnNlZENvbXBvbmVudHModW5kZWZpbmVkLCByZXN1bHQuc3RhcnQuZGF0ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWNvbmQgPiAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LmVuZC5hc3NpZ24oU0VDT05ELCBzZWNvbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0gQU0gJiBQTVxuICAgICAgICBpZiAobWF0Y2hbdGhpcy5BTV9QTV9IT1VSX0dST1VQXSkge1xuXG4gICAgICAgICAgICBpZiAoaG91ciA+IDEyKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIGNvbnN0IGFtcG06IHN0cmluZyA9IG1hdGNoW3RoaXMuQU1fUE1fSE9VUl9HUk9VUF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChhbXBtID09PSAnbW9yZ2VucycgfHwgYW1wbSA9PT0gJ3Zvcm1pdHRhZ3MnKSB7XG4gICAgICAgICAgICAgICAgbWVyaWRpZW0gPSAwO1xuICAgICAgICAgICAgICAgIGlmIChob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuZW5kLmlzQ2VydGFpbihEQVkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZW5kLmltcGx5KERBWSwgcmVzdWx0LmVuZC5nZXQoREFZKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJpZGllbSA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXIgIT09IDEyKSBob3VyICs9IDEyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5zdGFydC5pc0NlcnRhaW4oTUVSSURJRU0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lcmlkaWVtID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNRVJJRElFTSwgMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGFydC5nZXQoSE9VUikgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKEhPVVIsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1FUklESUVNLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXJ0LmdldChIT1VSKSAhPT0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oSE9VUiwgcmVzdWx0LnN0YXJ0LmdldChIT1VSKSArIDEyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC50ZXh0ID0gcmVzdWx0LnRleHQgKyBtYXRjaFswXTtcbiAgICAgICAgcmVzdWx0LmVuZC5hc3NpZ24oSE9VUiwgaG91cik7XG4gICAgICAgIHJlc3VsdC5lbmQuYXNzaWduKE1JTlVURSwgbWludXRlKTtcbiAgICAgICAgaWYgKG1lcmlkaWVtID49IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5lbmQuYXNzaWduKE1FUklESUVNLCBtZXJpZGllbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydEF0UE06IGJvb2xlYW4gPSByZXN1bHQuc3RhcnQuaXNDZXJ0YWluKE1FUklESUVNKSAmJiByZXN1bHQuc3RhcnQuZ2V0KE1FUklESUVNKSA9PT0gMTtcbiAgICAgICAgICAgIGlmIChzdGFydEF0UE0gJiYgcmVzdWx0LnN0YXJ0LmdldChIT1VSKSA+IGhvdXIpIHtcbiAgICAgICAgICAgICAgICAvLyAxMHBtIC0gMSAoYW0pXG4gICAgICAgICAgICAgICAgcmVzdWx0LmVuZC5pbXBseShNRVJJRElFTSwgMCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA+IDEyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVuZC5pbXBseShNRVJJRElFTSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LmVuZC5kYXRlKCkuZ2V0VGltZSgpIDwgcmVzdWx0LnN0YXJ0LmRhdGUoKS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lbmQuaW1wbHkoREFZLCByZXN1bHQuZW5kLmdldChEQVkpICsgMSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGltZShtYXRjaDogUmVnRXhwRXhlY0FycmF5KTogVGltZSB8IGZhbHNlIHtcbiAgICAgICAgbGV0IHNlY29uZDogbnVtYmVyID0gLTE7XG4gICAgICAgIGxldCBob3VyOiBudW1iZXIgPSAwO1xuICAgICAgICBsZXQgbWludXRlOiBudW1iZXIgPSAwO1xuICAgICAgICBsZXQgbWVyaWRpZW06IG51bWJlciA9IC0xO1xuXG5cbiAgICAgICAgLy8gLS0tLS0gU2Vjb25kXG4gICAgICAgIGlmIChtYXRjaFt0aGlzLlNFQ09ORF9HUk9VUF0pIHtcbiAgICAgICAgICAgIHNlY29uZCA9IHBhcnNlSW50KG1hdGNoW3RoaXMuU0VDT05EX0dST1VQXSwgMTApO1xuICAgICAgICAgICAgaWYgKHNlY29uZCA+PSA2MCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0gSG91cnNcbiAgICAgICAgaWYgKHRoaXMuT1RIRVJfUEFUVEVSTlNbMF0udGVzdChtYXRjaFt0aGlzLkhPVVJfR1JPVVBdKSkge1xuICAgICAgICAgICAgbWVyaWRpZW0gPSAxO1xuICAgICAgICAgICAgaG91ciA9IDEyO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuT1RIRVJfUEFUVEVSTlNbMV0udGVzdChtYXRjaFt0aGlzLkhPVVJfR1JPVVBdKSkge1xuICAgICAgICAgICAgbWVyaWRpZW0gPSAwO1xuICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBob3VyID0gcGFyc2VJbnQobWF0Y2hbdGhpcy5IT1VSX0dST1VQXSwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0gTWludXRlc1xuICAgICAgICBpZiAobWF0Y2hbdGhpcy5NSU5VVEVfR1JPVVBdKSB7XG4gICAgICAgICAgICBtaW51dGUgPSBwYXJzZUludChtYXRjaFt0aGlzLk1JTlVURV9HUk9VUF0sIDEwKTtcbiAgICAgICAgfSBlbHNlIGlmIChob3VyID4gMTAwKSB7XG4gICAgICAgICAgICBtaW51dGUgPSBob3VyICUgMTAwO1xuICAgICAgICAgICAgaG91ciA9IE1hdGguZmxvb3IoaG91ciAvIDEwMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWludXRlID49IDYwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaG91ciA+IDI0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvdXIgPj0gMTIpIHtcbiAgICAgICAgICAgIG1lcmlkaWVtID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbaG91ciwgbWludXRlLCBzZWNvbmQsIG1lcmlkaWVtXTtcbiAgICB9XG59XG4iLCJpbXBvcnQgUGFyc2VyIGZyb20gJy4uL3BhcnNlcic7XG5pbXBvcnQge1BhcnNlZFJlc3VsdH0gZnJvbSBcIi4uLy4uL3Jlc3VsdFwiO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jaHJvbm9cIjtcbmltcG9ydCB7V0VFS0RBWV9PRkZTRVR9IGZyb20gJy4uLy4uL3V0aWxzL0RFJztcbmltcG9ydCAqIGFzIG1vbWVudCBmcm9tIFwibW9tZW50XCI7XG5pbXBvcnQge01vbWVudH0gZnJvbSBcIm1vbWVudFwiO1xuaW1wb3J0IHtEQVksIE1PTlRILCBXRUVLREFZLCBZRUFSfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgREVXZWVrZGF5UGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBwcml2YXRlIFBBVFRFUk46IFJlZ0V4cCA9IG5ldyBSZWdFeHAoJyhcXFxcV3xeKScgK1xuICAgICAgICAnKD86KD86XFxcXCx8XFxcXCh8XFxcXO+8iClcXFxccyopPycgK1xuICAgICAgICAnKD86YVttbl1cXFxccyo/KT8nICtcbiAgICAgICAgJyg/OihkaWVzZVttbl18bGV0enRlW21uXXxuKD86w6R8YWUpY2hzdGVbbW5dKVxcXFxzKik/JyArXG4gICAgICAgICcoJyArIE9iamVjdC5rZXlzKFdFRUtEQVlfT0ZGU0VUKS5qb2luKCd8JykgKyAnKScgK1xuICAgICAgICAnKD86XFxcXHMqKD86XFxcXCx8XFxcXCl8XFxcXO+8iSkpPycgK1xuICAgICAgICAnKD86XFxcXHMqKGRpZXNlfGxldHp0ZXxuKD86w6R8YWUpY2hzdGUpXFxcXHMqd29jaGUpPycgK1xuICAgICAgICAnKD89XFxcXFd8JCknLCAnaScpO1xuXG4gICAgcHJpdmF0ZSBQUkVGSVhfR1JPVVA6IG51bWJlciA9IDI7XG4gICAgcHJpdmF0ZSBXRUVLREFZX0dST1VQOiBudW1iZXIgPSAzO1xuICAgIHByaXZhdGUgUE9TVEZJWF9HUk9VUDogbnVtYmVyID0gNDtcblxuICAgIHByaXZhdGUgT1RIRVJfUEFUVEVSTlM6IFJlZ0V4cFtdID0gW1xuICAgICAgICAvbGV0enRlLyxcbiAgICAgICAgL24oPzrDpHxhZSljaHN0ZS8sXG4gICAgICAgIC9kaWVzZS9cbiAgICBdO1xuXG4gICAgcHJpdmF0ZSBUQUc6IHN0cmluZyA9ICdERVdlZWtkYXlQYXJzZXInO1xuXG4gICAgcGF0dGVybigpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gdGhpcy5QQVRURVJOO1xuICAgIH1cblxuICAgIGV4dHJhY3QodGV4dDogc3RyaW5nLCByZWY6IERhdGUsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGluZGV4OiBudW1iZXIgPSBtYXRjaC5pbmRleCArIG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbWF0Y2hlZFRleHQ6IHN0cmluZyA9IG1hdGNoWzBdLnN1YnN0cihtYXRjaFsxXS5sZW5ndGgsIG1hdGNoWzBdLmxlbmd0aCAtIG1hdGNoWzFdLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogUGFyc2VkUmVzdWx0ID0gbmV3IFBhcnNlZFJlc3VsdCh7XG4gICAgICAgICAgICB0ZXh0OiBtYXRjaGVkVGV4dCxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcmVmLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBvZmZzZXQ6IG51bWJlciB8IHVuZGVmaW5lZCA9IFdFRUtEQVlfT0ZGU0VUW21hdGNoW3RoaXMuV0VFS0RBWV9HUk9VUF0udG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgY29uc3Qgc3RhcnRNb21lbnQ6IE1vbWVudCA9IG1vbWVudChyZWYpO1xuICAgICAgICBjb25zdCBwcmVmaXg6IHN0cmluZyA9IG1hdGNoW3RoaXMuUFJFRklYX0dST1VQXTtcbiAgICAgICAgY29uc3QgcG9zdGZpeDogc3RyaW5nID0gbWF0Y2hbdGhpcy5QT1NURklYX0dST1VQXTtcblxuICAgICAgICBjb25zdCByZWZPZmZzZXQ6IG51bWJlciA9IHN0YXJ0TW9tZW50LmRheSgpO1xuICAgICAgICBjb25zdCBub3JtOiBzdHJpbmcgPSAocHJlZml4IHx8IHBvc3RmaXggfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh0aGlzLk9USEVSX1BBVFRFUk5TWzBdLnRlc3Qobm9ybSkpIHtcbiAgICAgICAgICAgIHN0YXJ0TW9tZW50LmRheShvZmZzZXQgLSA3KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLk9USEVSX1BBVFRFUk5TWzFdLnRlc3Qobm9ybSkpIHtcbiAgICAgICAgICAgIHN0YXJ0TW9tZW50LmRheShvZmZzZXQgKyA3KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLk9USEVSX1BBVFRFUk5TWzJdLnRlc3Qobm9ybSkpIHtcbiAgICAgICAgICAgIGlmIChvcHQuZm9yd2FyZERhdGUgJiYgcmVmT2Zmc2V0ID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgc3RhcnRNb21lbnQuZGF5KG9mZnNldCArIDcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydE1vbWVudC5kYXkob2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGNPZmZzZXQgPSBvZmZzZXQgLSByZWZPZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCBhYnNPZmZzZXQgPSBNYXRoLmFicyhjYWxjT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChvcHQuZm9yd2FyZERhdGUgJiYgcmVmT2Zmc2V0ID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgc3RhcnRNb21lbnQuZGF5KG9mZnNldCArIDcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghb3B0LmZvcndhcmREYXRlICYmIE1hdGguYWJzKGNhbGNPZmZzZXQgLSA3KSA8IGFic09mZnNldCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0TW9tZW50LmRheShvZmZzZXQgLSA3KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW9wdC5mb3J3YXJkRGF0ZSAmJiBNYXRoLmFicyhjYWxjT2Zmc2V0ICsgNykgPCBhYnNPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBzdGFydE1vbWVudC5kYXkob2Zmc2V0ICsgNyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0TW9tZW50LmRheShvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihXRUVLREFZLCBvZmZzZXQpO1xuICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoREFZLCBzdGFydE1vbWVudC5kYXRlKCkpO1xuICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTU9OVEgsIHN0YXJ0TW9tZW50Lm1vbnRoKCkgKyAxKTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KFlFQVIsIHN0YXJ0TW9tZW50LnllYXIoKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSIsImltcG9ydCAqIGFzIG1vbWVudCBmcm9tIFwibW9tZW50XCI7XG5pbXBvcnQge01vbWVudH0gZnJvbSBcIm1vbWVudFwiO1xuaW1wb3J0IFBhcnNlciBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHtQYXJzZWRSZXN1bHR9IGZyb20gJy4uLy4uL3Jlc3VsdCc7XG5pbXBvcnQge1BhcnNlT3B0aW9uc30gZnJvbSBcIi4uLy4uL2Nocm9ub1wiO1xuaW1wb3J0IHtEQVksIEhPVVIsIE1FUklESUVNLCBNSUxMSVNFQ09ORCwgTUlOVVRFLCBNT05USCwgU0VDT05ELCBZRUFSfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVOQ2FzdWFsRGF0ZVBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgcHJpdmF0ZSBQQVRURVJOOiBSZWdFeHAgPSAvKFxcV3xeKShub3d8dG9kYXl8dG9uaWdodHxsYXN0XFxzKm5pZ2h0fCg/OnRvbW9ycm93fHRtcnx5ZXN0ZXJkYXkpXFxzKnx0b21vcnJvd3x0bXJ8eWVzdGVyZGF5KSg/PVxcV3wkKS9pO1xuXG4gICAgcHJpdmF0ZSBPVEhFUl9QQVRURVJOUzogUmVnRXhwW10gPSBbXG4gICAgICAgIC9edG9tb3Jyb3d8XnRtci8sXG4gICAgICAgIC9eeWVzdGVyZGF5LyxcbiAgICAgICAgL2xhc3RcXHMqbmlnaHQvXG4gICAgXTtcblxuICAgIHByaXZhdGUgVEFHOiBzdHJpbmcgPSAnRU5DYXN1YWxEYXRlUGFyc2VyJztcblxuICAgIHBhdHRlcm4oKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuUEFUVEVSTjtcbiAgICB9XG5cbiAgICBleHRyYWN0KHRleHQ6IHN0cmluZywgcmVmOiBEYXRlLCBtYXRjaDogUmVnRXhwRXhlY0FycmF5LCBvcHQ6IFBhcnNlT3B0aW9ucyk6IFBhcnNlZFJlc3VsdCB8IG51bGwge1xuICAgICAgICBjb25zdCBpbmRleDogbnVtYmVyID0gbWF0Y2guaW5kZXggKyBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogUGFyc2VkUmVzdWx0ID0gbmV3IFBhcnNlZFJlc3VsdCh7XG4gICAgICAgICAgICB0ZXh0OiBtYXRjaFswXS5zdWJzdHIobWF0Y2hbMV0ubGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcmVmXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlZk1vbWVudDogTW9tZW50ID0gbW9tZW50KHJlZik7XG4gICAgICAgIGNvbnN0IHN0YXJ0TW9tZW50OiBNb21lbnQgPSByZWZNb21lbnQuY2xvbmUoKTtcbiAgICAgICAgY29uc3QgbWF0Y2hlZFRleHQgPSByZXN1bHQudGV4dC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmKG1hdGNoZWRUZXh0ID09PSAndG9uaWdodCcpe1xuICAgICAgICAgICAgLy8gTm9ybWFsbHkgbWVhbnMgdGhpcyBjb21pbmcgbWlkbmlnaHRcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShIT1VSLCAyMik7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTUVSSURJRU0sIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuT1RIRVJfUEFUVEVSTlNbMF0udGVzdChtYXRjaGVkVGV4dCkpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIG5vdCBcIlRvbW9ycm93XCIgb24gbGF0ZSBuaWdodFxuICAgICAgICAgICAgaWYocmVmTW9tZW50LmhvdXIoKSA+IDEpIHtcbiAgICAgICAgICAgICAgICBzdGFydE1vbWVudC5hZGQoMSwgJ2RheScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuT1RIRVJfUEFUVEVSTlNbMV0udGVzdChtYXRjaGVkVGV4dCkpIHtcbiAgICAgICAgICAgIHN0YXJ0TW9tZW50LmFkZCgtMSwgJ2RheScpO1xuICAgICAgICB9IGVsc2UgaWYobWF0Y2hlZFRleHQubWF0Y2godGhpcy5PVEhFUl9QQVRURVJOU1syXSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShIT1VSLCAwKTtcbiAgICAgICAgICAgIGlmIChyZWZNb21lbnQuaG91cigpID4gNikge1xuICAgICAgICAgICAgICAgIHN0YXJ0TW9tZW50LmFkZCgtMSwgJ2RheScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZWRUZXh0Lm1hdGNoKFwibm93XCIpKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKEhPVVIsIHJlZk1vbWVudC5ob3VyKCkpO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihNSU5VVEUsIHJlZk1vbWVudC5taW51dGUoKSk7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKFNFQ09ORCwgcmVmTW9tZW50LnNlY29uZCgpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTUlMTElTRUNPTkQsIHJlZk1vbWVudC5taWxsaXNlY29uZCgpKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihEQVksIHN0YXJ0TW9tZW50LmRhdGUoKSk7XG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTU9OVEgsIHN0YXJ0TW9tZW50Lm1vbnRoKCkgKyAxKTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCBzdGFydE1vbWVudC55ZWFyKCkpO1xuICAgICAgICByZXN1bHQudGFnc1t0aGlzLlRBR10gPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxufSIsImltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tICcuLi8uLi9yZXN1bHQnO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jaHJvbm9cIjtcbmltcG9ydCB7SE9VUn0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFTkNhc3VhbFRpbWVQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIHByaXZhdGUgUEFUVEVSTjogUmVnRXhwID0gLyhcXFd8XikoKHRoaXMpP1xccyoobW9ybmluZ3xhZnRlcm5vb258ZXZlbmluZ3xub29uKSkvaTtcblxuICAgIHByaXZhdGUgVElNRV9NQVRDSDogbnVtYmVyID0gNDtcbiAgICBwcml2YXRlIFRJTUVfTUFUQ0hfQUxUOiBudW1iZXIgPSAzO1xuXG4gICAgcHJpdmF0ZSBUQUc6IHN0cmluZyA9ICdFTkNhc3VhbFRpbWVQYXJzZXInO1xuXG4gICAgcGF0dGVybigpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gdGhpcy5QQVRURVJOO1xuICAgIH1cblxuICAgIGV4dHJhY3QodGV4dDogc3RyaW5nLCByZWY6IERhdGUsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGluZGV4OiBudW1iZXIgPSBtYXRjaC5pbmRleCArIG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBQYXJzZWRSZXN1bHQgPSBuZXcgUGFyc2VkUmVzdWx0KHtcbiAgICAgICAgICAgIHRleHQ6IG1hdGNoWzBdLnN1YnN0cihtYXRjaFsxXS5sZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCBtYXRjaGVkVGV4dDogc3RyaW5nID0gKG1hdGNoW3RoaXMuVElNRV9NQVRDSF0gfHwgbWF0Y2hbdGhpcy5USU1FX01BVENIX0FMVF0pLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWRUZXh0ID09IFwiYWZ0ZXJub29uXCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShIT1VSLCBvcHQuYWZ0ZXJub29uKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVkVGV4dCA9PSBcImV2ZW5pbmdcIikge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KEhPVVIsIG9wdC5ldmVuaW5nKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVkVGV4dCA9PSBcIm1vcm5pbmdcIikge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KEhPVVIsIG9wdC5tb3JuaW5nKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVkVGV4dCA9PSBcIm5vb25cIikge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KEhPVVIsIG9wdC5ub29uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSIsImltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tICcuLi8uLi9yZXN1bHQnO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jaHJvbm9cIjtcbmltcG9ydCB7SU5URUdFUl9XT1JEU19QQVRURVJOLCBtYXRjaEludGVnZXIsIG1hdGNoVW5pdH0gZnJvbSBcIi4uLy4uL3V0aWxzL0VOXCI7XG5pbXBvcnQgKiBhcyBtb21lbnQgZnJvbSBcIm1vbWVudFwiO1xuaW1wb3J0IHtVbml0T2ZUaW1lfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQge2RlYWRsaW5lQ2FsY3VsYXRpb25zfSBmcm9tIFwiLi4vLi4vdXRpbHMvZ2VuZXJhbFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFTkRlYWRsaW5lRm9ybWF0UGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBwcml2YXRlIFBBVFRFUk46IFJlZ0V4cCA9IG5ldyBSZWdFeHAoJyhcXFxcV3xeKScgK1xuICAgICAgICAnKHdpdGhpbnxpbilcXFxccyonICtcbiAgICAgICAgJygnICsgSU5URUdFUl9XT1JEU19QQVRURVJOICsgJ3xbMC05XSt8YW4/KD86XFxcXHMqZmV3KT98aGFsZig/OlxcXFxzKmFuPyk/KVxcXFxzKicgK1xuICAgICAgICAnKHNlY29uZHM/fG1pbig/OnV0ZSk/cz98aG91cnM/fGRheXM/fHdlZWtzP3xtb250aHM/fHllYXJzPylcXFxccyonICtcbiAgICAgICAgJyg/PVxcXFxXfCQpJywgJ2knXG4gICAgKTtcbiAgICBwcml2YXRlIFNUUklDVF9QQVRURVJOOiBSZWdFeHAgPSBuZXcgUmVnRXhwKCcoXFxcXFd8XiknICtcbiAgICAgICAgJyh3aXRoaW58aW4pXFxcXHMqJyArXG4gICAgICAgICcoJyArIElOVEVHRVJfV09SRFNfUEFUVEVSTiArICd8WzAtOV0rfGFuPylcXFxccyonICtcbiAgICAgICAgJyhzZWNvbmRzP3xtaW51dGVzP3xob3Vycz98ZGF5cz8pXFxcXHMqJyArXG4gICAgICAgICcoPz1cXFxcV3wkKScsICdpJ1xuICAgICk7XG5cbiAgICBwcml2YXRlIE5VTV9NQVRDSDogbnVtYmVyID0gMztcbiAgICBwcml2YXRlIFVOSVRfTUFUQ0g6IG51bWJlciA9IDQ7XG5cbiAgICBwcml2YXRlIFRBRzogc3RyaW5nID0gJ0VORGVhZGxpbmVGb3JtYXRQYXJzZXInO1xuXG4gICAgcGF0dGVybigpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1N0cmljdE1vZGUoKSA/IHRoaXMuU1RSSUNUX1BBVFRFUk4gOiB0aGlzLlBBVFRFUk47XG4gICAgfVxuXG4gICAgZXh0cmFjdCh0ZXh0OiBzdHJpbmcsIHJlZjogRGF0ZSwgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSwgb3B0OiBQYXJzZU9wdGlvbnMpOiBQYXJzZWRSZXN1bHQgfCBudWxsIHtcbiAgICAgICAgY29uc3QgaW5kZXg6IG51bWJlciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFJlc3VsdCA9IG5ldyBQYXJzZWRSZXN1bHQoe1xuICAgICAgICAgICAgdGV4dDogbWF0Y2hbMF0uc3Vic3RyKG1hdGNoWzFdLmxlbmd0aCwgbWF0Y2hbMF0ubGVuZ3RoIC0gbWF0Y2hbMV0ubGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcmVmXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3VsdC50YWdzW3RoaXMuVEFHXSA9IHRydWU7XG5cbiAgICAgICAgY29uc3QgbnVtOiBudW1iZXIgPSBtYXRjaEludGVnZXIobWF0Y2hbdGhpcy5OVU1fTUFUQ0hdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBjb25zdCBtYXRjaGVkVW5pdDogVW5pdE9mVGltZSB8IHVuZGVmaW5lZCA9IG1hdGNoVW5pdChtYXRjaFt0aGlzLlVOSVRfTUFUQ0hdLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgIGlmIChudW0gJiYgbWF0Y2hlZFVuaXQgJiYgZGVhZGxpbmVDYWxjdWxhdGlvbnMobnVtLCBtYXRjaGVkVW5pdCwgcmVzdWx0LCBtb21lbnQocmVmKSkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59IiwiLypcbiAgICBJU08gODYwMVxuICAgIGh0dHA6Ly93d3cudzMub3JnL1RSL05PVEUtZGF0ZXRpbWVcbiAgICAtIFlZWVktTU0tRERcbiAgICAtIFlZWVktTU0tRERUaGg6bW1UWkRcbiAgICAtIFlZWVktTU0tRERUaGg6bW06c3NUWkRcbiAgICAtIFlZWVktTU0tRERUaGg6bW06c3Muc1RaRCBcbiAgICAtIFRaRCA9IChaIG9yICtoaDptbSBvciAtaGg6bW0pXG4qL1xuaW1wb3J0IFBhcnNlciBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHtQYXJzZWRSZXN1bHR9IGZyb20gJy4uLy4uL3Jlc3VsdCc7XG5pbXBvcnQge1BhcnNlT3B0aW9uc30gZnJvbSBcIi4uLy4uL2Nocm9ub1wiO1xuaW1wb3J0IHtEQVksIEhPVVIsIE1JTExJU0VDT05ELCBNSU5VVEUsIE1PTlRILCBTRUNPTkQsIFRJTUVaT05FX09GRlNFVCwgWUVBUn0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFTklTT0Zvcm1hdFBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgcHJpdmF0ZSBQQVRURVJOOiBSZWdFeHAgPSBuZXcgUmVnRXhwKCcoXFxcXFd8XiknXG4gICAgICAgICsgJyhbMC05XXs0fSlcXFxcLShbMC05XXsxLDJ9KVxcXFwtKFswLTldezEsMn0pJ1xuICAgICAgICArICcoPzpUJyAvLy4uXG4gICAgICAgICsgJyhbMC05XXsxLDJ9KTooWzAtOV17MSwyfSknIC8vIGhoOm1tXG4gICAgICAgICsgJyg/OjooWzAtOV17MSwyfSkoPzpcXFxcLihcXFxcZHsxLDR9KSk/KT8nIC8vIDpzcy5zXG4gICAgICAgICsgJyg/Olp8KFsrLV1cXFxcZHsyfSk6PyhcXFxcZHsyfSk/KT8nIC8vIFRaRCAoWiBvciDCsWhoOm1tIG9yIMKxaGhtbSBvciDCsWhoKVxuICAgICAgICArICcpPycgIC8vLi5cbiAgICAgICAgKyAnKD89XFxcXFd8JCknLCAnaScpO1xuXG4gICAgcHJpdmF0ZSBZRUFSX05VTUJFUl9HUk9VUDogbnVtYmVyID0gMjtcbiAgICBwcml2YXRlIE1PTlRIX05VTUJFUl9HUk9VUDogbnVtYmVyID0gMztcbiAgICBwcml2YXRlIERBVEVfTlVNQkVSX0dST1VQOiBudW1iZXIgPSA0O1xuICAgIHByaXZhdGUgSE9VUl9OVU1CRVJfR1JPVVA6IG51bWJlciA9IDU7XG4gICAgcHJpdmF0ZSBNSU5VVEVfTlVNQkVSX0dST1VQOiBudW1iZXIgPSA2O1xuICAgIHByaXZhdGUgU0VDT05EX05VTUJFUl9HUk9VUDogbnVtYmVyID0gNztcbiAgICBwcml2YXRlIE1JTExJU0VDT05EX05VTUJFUl9HUk9VUDogbnVtYmVyID0gODtcbiAgICBwcml2YXRlIFRaRF9IT1VSX09GRlNFVF9HUk9VUDogbnVtYmVyID0gOTtcbiAgICBwcml2YXRlIFRaRF9NSU5VVEVfT0ZGU0VUX0dST1VQOiBudW1iZXIgPSAxMDtcblxuICAgIHByaXZhdGUgVEFHOiBzdHJpbmcgPSAnRU5JU09Gb3JtYXRQYXJzZXInO1xuXG4gICAgcGF0dGVybigpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gdGhpcy5QQVRURVJOO1xuICAgIH1cblxuICAgIGV4dHJhY3QodGV4dDogc3RyaW5nLCByZWY6IERhdGUsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGluZGV4OiBudW1iZXIgPSBtYXRjaC5pbmRleCArIG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBQYXJzZWRSZXN1bHQgPSBuZXcgUGFyc2VkUmVzdWx0KHtcbiAgICAgICAgICAgIHRleHQ6IG1hdGNoWzBdLnN1YnN0cihtYXRjaFsxXS5sZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcblxuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKFlFQVIsIHBhcnNlSW50KG1hdGNoW3RoaXMuWUVBUl9OVU1CRVJfR1JPVVBdLCAxMCkpO1xuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1PTlRILCBwYXJzZUludChtYXRjaFt0aGlzLk1PTlRIX05VTUJFUl9HUk9VUF0sIDEwKSk7XG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oREFZLCBwYXJzZUludChtYXRjaFt0aGlzLkRBVEVfTlVNQkVSX0dST1VQXSwgMTApKTtcblxuICAgICAgICBpZiAocmVzdWx0LnN0YXJ0LmdldChNT05USCkgPiAxMiB8fCByZXN1bHQuc3RhcnQuZ2V0KE1PTlRIKSA8IDEgfHxcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5nZXQoREFZKSA+IDMxIHx8IHJlc3VsdC5zdGFydC5nZXQoREFZKSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoW3RoaXMuSE9VUl9OVU1CRVJfR1JPVVBdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oSE9VUiwgcGFyc2VJbnQobWF0Y2hbdGhpcy5IT1VSX05VTUJFUl9HUk9VUF0sIDEwKSk7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1JTlVURSwgcGFyc2VJbnQobWF0Y2hbdGhpcy5NSU5VVEVfTlVNQkVSX0dST1VQXSwgMTApKTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoW3RoaXMuU0VDT05EX05VTUJFUl9HUk9VUF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oU0VDT05ELCBwYXJzZUludChtYXRjaFt0aGlzLlNFQ09ORF9OVU1CRVJfR1JPVVBdLDEwKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXRjaFt0aGlzLk1JTExJU0VDT05EX05VTUJFUl9HUk9VUF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTUlMTElTRUNPTkQsIHBhcnNlSW50KG1hdGNoW3RoaXMuTUlMTElTRUNPTkRfTlVNQkVSX0dST1VQXSwgMTApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hdGNoW3RoaXMuVFpEX0hPVVJfT0ZGU0VUX0dST1VQXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihUSU1FWk9ORV9PRkZTRVQsIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWludXRlT2Zmc2V0OiBudW1iZXIgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhvdXJPZmZzZXQ6IG51bWJlciA9IHBhcnNlSW50KG1hdGNoW3RoaXMuVFpEX0hPVVJfT0ZGU0VUX0dST1VQXSwgMTApO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFt0aGlzLlRaRF9NSU5VVEVfT0ZGU0VUX0dST1VQXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBtaW51dGVPZmZzZXQgPSBwYXJzZUludChtYXRjaFt0aGlzLlRaRF9NSU5VVEVfT0ZGU0VUX0dST1VQXSwgMTApO1xuXG4gICAgICAgICAgICAgICAgbGV0IG9mZnNldDogbnVtYmVyID0gaG91ck9mZnNldCAqIDYwO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCAtPSBtaW51dGVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IG1pbnV0ZU9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKFRJTUVaT05FX09GRlNFVCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSIsImltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tICcuLi8uLi9yZXN1bHQnO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jaHJvbm9cIjtcbmltcG9ydCB7TU9OVEhfT0ZGU0VULCBPUkRJTkFMX1dPUkRTLCBPUkRJTkFMX1dPUkRTX1BBVFRFUk4sIFdFRUtEQVlfT0ZGU0VULCB5ZWFyQ2FsY3VsYXRpb259IGZyb20gXCIuLi8uLi91dGlscy9FTlwiO1xuaW1wb3J0IHtEQVksIE1PTlRILCBXRUVLREFZLCBZRUFSfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQge2dldEFwcHJvcHJpYXRlWWVhcn0gZnJvbSBcIi4uLy4uL3V0aWxzL2dlbmVyYWxcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRU5Nb250aE5hbWVMaXR0bGVFbmRpYW5QYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIHByaXZhdGUgUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cCgnKFxcXFxXfF4pJyArXG4gICAgICAgICcoPzpvblxcXFxzKj8pPycgK1xuICAgICAgICAnKD86KFN1bmRheXxNb25kYXl8VHVlc2RheXxXZWRuZXNkYXl8VGh1cnNkYXl8RnJpZGF5fFNhdHVyZGF5fFN1bnxNb258VHVlfFdlZHxUaHV8RnJpfFNhdClcXFxccyosP1xcXFxzKik/JyArXG4gICAgICAgICcoKFswLTldezEsMn0pKD86c3R8bmR8cmR8dGgpP3wnICsgT1JESU5BTF9XT1JEU19QQVRURVJOICsgJyknICtcbiAgICAgICAgJyg/OlxcXFxzKicgK1xuICAgICAgICAnKD86dG98XFxcXC18XFxcXOKAk3x1bnRpbHx0aHJvdWdofHRpbGx8XFxcXHMpXFxcXHMqJyArXG4gICAgICAgICcoKFswLTldezEsMn0pKD86c3R8bmR8cmR8dGgpP3wnICsgT1JESU5BTF9XT1JEU19QQVRURVJOICsgJyknICtcbiAgICAgICAgJyk/JyArXG4gICAgICAgICcoPzotfFxcL3xcXFxccyooPzpvZik/XFxcXHMqKScgK1xuICAgICAgICAnKEphbig/OnVhcnl8XFxcXC4pP3xGZWIoPzpydWFyeXxcXFxcLik/fE1hcig/OmNofFxcXFwuKT98QXByKD86aWx8XFxcXC4pP3xNYXl8SnVuKD86ZXxcXFxcLik/fEp1bCg/Onl8XFxcXC4pP3xBdWcoPzp1c3R8XFxcXC4pP3xTZXAoPzp0ZW1iZXJ8XFxcXC4pP3xPY3QoPzpvYmVyfFxcXFwuKT98Tm92KD86ZW1iZXJ8XFxcXC4pP3xEZWMoPzplbWJlcnxcXFxcLik/KScgK1xuICAgICAgICAnKD86JyArXG4gICAgICAgICcoPzotfFxcL3wsP1xcXFxzKiknICtcbiAgICAgICAgJygoPzonICtcbiAgICAgICAgJ1sxLTldWzAtOV17MCwzfVxcXFxzKig/OkJFfEFEfEJDKXwnICtcbiAgICAgICAgJ1sxLTJdWzAtOV17M30nICtcbiAgICAgICAgJykoPyFbXlxcXFxzXVxcXFxkKSknICtcbiAgICAgICAgJyk/JyArXG4gICAgICAgICcoPz1cXFxcV3wkKScsICdpJ1xuICAgICk7XG5cbiAgICBwcml2YXRlIFdFRUtEQVlfR1JPVVA6IG51bWJlciA9IDI7XG4gICAgcHJpdmF0ZSBEQVRFX0dST1VQOiBudW1iZXIgPSAzO1xuICAgIHByaXZhdGUgREFURV9OVU1fR1JPVVA6IG51bWJlciA9IDQ7XG4gICAgcHJpdmF0ZSBEQVRFX1RPX0dST1VQOiBudW1iZXIgPSA1O1xuICAgIHByaXZhdGUgREFURV9UT19OVU1fR1JPVVA6IG51bWJlciA9IDY7XG4gICAgcHJpdmF0ZSBNT05USF9OQU1FX0dST1VQOiBudW1iZXIgPSA3O1xuICAgIHByaXZhdGUgWUVBUl9HUk9VUDogbnVtYmVyID0gODtcblxuICAgIHByaXZhdGUgVEFHOiBzdHJpbmcgPSAnRU5Nb250aE5hbWVMaXR0bGVFbmRpYW5QYXJzZXInO1xuXG4gICAgcGF0dGVybigpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gdGhpcy5QQVRURVJOO1xuICAgIH1cblxuICAgIGV4dHJhY3QodGV4dDogc3RyaW5nLCByZWY6IERhdGUsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGluZGV4OiBudW1iZXIgPSBtYXRjaC5pbmRleCArIG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBQYXJzZWRSZXN1bHQgPSBuZXcgUGFyc2VkUmVzdWx0KHtcbiAgICAgICAgICAgIHRleHQ6IG1hdGNoWzBdLnN1YnN0cihtYXRjaFsxXS5sZW5ndGgsIG1hdGNoWzBdLmxlbmd0aCAtIG1hdGNoWzFdLmxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIHJlZlxuICAgICAgICB9KTtcblxuICAgICAgICByZXN1bHQudGFnc1t0aGlzLlRBR10gPSB0cnVlO1xuXG4gICAgICAgIGNvbnN0IG1vbnRoOiBudW1iZXIgPSBNT05USF9PRkZTRVRbbWF0Y2hbdGhpcy5NT05USF9OQU1FX0dST1VQXS50b0xvd2VyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoIShtb250aCB8fCBtb250aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGF5OiBudW1iZXIgPSBtYXRjaFt0aGlzLkRBVEVfTlVNX0dST1VQXSA/XG4gICAgICAgICAgICBwYXJzZUludChtYXRjaFt0aGlzLkRBVEVfTlVNX0dST1VQXSwgMTApIDpcbiAgICAgICAgICAgIE9SRElOQUxfV09SRFNbbWF0Y2hbdGhpcy5EQVRFX0dST1VQXS50cmltKCkucmVwbGFjZSgnLScsICcgJykudG9Mb3dlckNhc2UoKV07XG5cblxuICAgICAgICBpZiAoIWRheSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKERBWSwgZGF5KTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihNT05USCwgbW9udGgpO1xuXG4gICAgICAgIGxldCB5ZWFyOiBudW1iZXIgfCBudWxsID0geWVhckNhbGN1bGF0aW9uKG1hdGNoW3RoaXMuWUVBUl9HUk9VUF0pO1xuXG5cbiAgICAgICAgaWYgKHllYXIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oWUVBUiwgeWVhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRBcHByb3ByaWF0ZVllYXIocmVzdWx0LnN0YXJ0LCByZWYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2Vla2RheSBjb21wb25lbnRcbiAgICAgICAgaWYgKG1hdGNoW3RoaXMuV0VFS0RBWV9HUk9VUF0pIHtcbiAgICAgICAgICAgIGNvbnN0IHdlZWtkYXk6IG51bWJlciA9IFdFRUtEQVlfT0ZGU0VUW21hdGNoW3RoaXMuV0VFS0RBWV9HUk9VUF0udG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICBpZiAod2Vla2RheSB8fCB3ZWVrZGF5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihXRUVLREFZLCB3ZWVrZGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRleHQgY2FuIGJlICdyYW5nZScgdmFsdWUuIFN1Y2ggYXMgJzEyIC0gMTMgSmFudWFyeSAyMDEyJ1xuICAgICAgICBpZiAobWF0Y2hbdGhpcy5EQVRFX1RPX0dST1VQXSkge1xuICAgICAgICAgICAgY29uc3QgZW5kRGF0ZSA9IG1hdGNoW3RoaXMuREFURV9UT19OVU1fR1JPVVBdID9cbiAgICAgICAgICAgICAgICBwYXJzZUludChtYXRjaFt0aGlzLkRBVEVfVE9fTlVNX0dST1VQXSwgMTApIDpcbiAgICAgICAgICAgICAgICBPUkRJTkFMX1dPUkRTW21hdGNoW3RoaXMuREFURV9UT19HUk9VUF0udHJpbSgpLnJlcGxhY2UoJy0nLCAnICcpLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgICAgICBpZiAoZW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5lbmQgPSByZXN1bHQuc3RhcnQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuZW5kLmFzc2lnbihEQVksIGVuZERhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbiIsIi8qXG5cbiAgICBUaGUgcGFyc2VyIGZvciBwYXJzaW5nIFVTJ3MgZGF0ZSBmb3JtYXQgdGhhdCBiZWdpbiB3aXRoIG1vbnRoJ3MgbmFtZS5cblxuICAgIEVYLlxuICAgICAgICAtIEphbnVhcnkgMTNcbiAgICAgICAgLSBKYW51YXJ5IDEzLCAyMDEyXG4gICAgICAgIC0gSmFudWFyeSAxMyAtIDE1LCAyMDEyXG4gICAgICAgIC0gVHVlc2RheSwgSmFudWFyeSAxMywgMjAxMlxuXG4gICAgV2F0Y2ggb3V0IGZvcjpcbiAgICAgICAgLSBKYW51YXJ5IDEyOjAwXG4gICAgICAgIC0gSmFudWFyeSAxMi40NFxuICAgICAgICAtIEphbnVhcnkgMTIyMjM0NFxuKi9cbmltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tICcuLi8uLi9yZXN1bHQnO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jaHJvbm9cIjtcbmltcG9ydCB7TU9OVEhfT0ZGU0VULCBPUkRJTkFMX1dPUkRTLCBPUkRJTkFMX1dPUkRTX1BBVFRFUk4sIFdFRUtEQVlfT0ZGU0VULCB5ZWFyQ2FsY3VsYXRpb259IGZyb20gXCIuLi8uLi91dGlscy9FTlwiO1xuaW1wb3J0IHtEQVksIE1PTlRILCBXRUVLREFZLCBZRUFSfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQge2dldEFwcHJvcHJpYXRlWWVhcn0gZnJvbSBcIi4uLy4uL3V0aWxzL2dlbmVyYWxcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRU5Nb250aE5hbWVNaWRkbGVFbmRpYW5QYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIHByaXZhdGUgUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cCgnKFxcXFxXfF4pJyArXG4gICAgICAgICcoPzonICtcbiAgICAgICAgJyg/Om9uXFxcXHMqPyk/JyArXG4gICAgICAgICcoU3VuZGF5fE1vbmRheXxUdWVzZGF5fFdlZG5lc2RheXxUaHVyc2RheXxGcmlkYXl8U2F0dXJkYXl8U3VuXFxcXC4/fE1vblxcXFwuP3xUdWVcXFxcLj98V2VkXFxcXC4/fFRodVxcXFwuP3xGcmlcXFxcLj98U2F0XFxcXC4/KScgK1xuICAgICAgICAnXFxcXHMqLD9cXFxccyopPycgK1xuICAgICAgICAnKEphblxcXFwuP3xKYW51YXJ5fEZlYlxcXFwuP3xGZWJydWFyeXxNYXJcXFxcLj98TWFyY2h8QXByXFxcXC4/fEFwcmlsfE1heVxcXFwuP3xKdW5cXFxcLj98SnVuZXxKdWxcXFxcLj98SnVseXxBdWdcXFxcLj98QXVndXN0fFNlcFxcXFwuP3xTZXB0XFxcXC4/fFNlcHRlbWJlcnxPY3RcXFxcLj98T2N0b2JlcnxOb3ZcXFxcLj98Tm92ZW1iZXJ8RGVjXFxcXC4/fERlY2VtYmVyKScgK1xuICAgICAgICAnKD86LXxcXC98XFxcXHMqLD9cXFxccyopJyArXG4gICAgICAgICcoKFswLTldezEsMn0pKD86c3R8bmR8cmR8dGgpP3wnICsgT1JESU5BTF9XT1JEU19QQVRURVJOICsgJykoPyFcXFxccyooPzphbXxwbSkpXFxcXHMqJyArICcnICtcbiAgICAgICAgJyg/OicgK1xuICAgICAgICAnKD86dG98XFxcXC0pXFxcXHMqJyArXG4gICAgICAgICcoKFswLTldezEsMn0pKD86c3R8bmR8cmR8dGgpP3wgJyArIE9SRElOQUxfV09SRFNfUEFUVEVSTiArICcpXFxcXHMqJyArXG4gICAgICAgICcpPycgK1xuICAgICAgICAnKD86JyArXG4gICAgICAgICcoPzotfFxcL3xcXFxccyosP1xcXFxzKiknICtcbiAgICAgICAgJyg/OihbMC05XXs0fSlcXFxccyooQkV8QUR8QkMpP3woWzAtOV17MSw0fSlcXFxccyooQUR8QkMpKVxcXFxzKicgK1xuICAgICAgICAnKT8nICtcbiAgICAgICAgJyg/PVxcXFxXfCQpKD8hXFxcXDpcXFxcZCknLCAnaScpO1xuXG4gICAgcHJpdmF0ZSBXRUVLREFZX0dST1VQOiBudW1iZXIgPSAyO1xuICAgIHByaXZhdGUgTU9OVEhfTkFNRV9HUk9VUDogbnVtYmVyID0gMztcbiAgICBwcml2YXRlIERBVEVfR1JPVVA6IG51bWJlciA9IDQ7XG4gICAgcHJpdmF0ZSBEQVRFX05VTV9HUk9VUDogbnVtYmVyID0gNTtcbiAgICBwcml2YXRlIERBVEVfVE9fR1JPVVA6IG51bWJlciA9IDY7XG4gICAgcHJpdmF0ZSBEQVRFX1RPX05VTV9HUk9VUDogbnVtYmVyID0gNztcbiAgICBwcml2YXRlIFlFQVJfR1JPVVA6IG51bWJlciA9IDg7XG4gICAgcHJpdmF0ZSBZRUFSX0JFX0dST1VQOiBudW1iZXIgPSA5O1xuICAgIHByaXZhdGUgWUVBUl9HUk9VUDI6IG51bWJlciA9IDEwO1xuICAgIHByaXZhdGUgWUVBUl9CRV9HUk9VUDI6IG51bWJlciA9IDExO1xuXG4gICAgcHJpdmF0ZSBUQUc6IHN0cmluZyA9ICdFTk1vbnRoTmFtZU1pZGRsZUVuZGlhblBhcnNlcic7XG5cbiAgICBwYXR0ZXJuKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiB0aGlzLlBBVFRFUk47XG4gICAgfVxuXG4gICAgZXh0cmFjdCh0ZXh0OiBzdHJpbmcsIHJlZjogRGF0ZSwgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSwgb3B0OiBQYXJzZU9wdGlvbnMpOiBQYXJzZWRSZXN1bHQgfCBudWxsIHtcbiAgICAgICAgY29uc3QgaW5kZXg6IG51bWJlciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFJlc3VsdCA9IG5ldyBQYXJzZWRSZXN1bHQoe1xuICAgICAgICAgICAgdGV4dDogbWF0Y2hbMF0uc3Vic3RyKG1hdGNoWzFdLmxlbmd0aCwgbWF0Y2hbMF0ubGVuZ3RoIC0gbWF0Y2hbMV0ubGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcmVmXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3VsdC50YWdzW3RoaXMuVEFHXSA9IHRydWU7XG5cbiAgICAgICAgY29uc3QgbW9udGg6IG51bWJlciA9IE1PTlRIX09GRlNFVFttYXRjaFt0aGlzLk1PTlRIX05BTUVfR1JPVVBdLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgIGlmICghKG1vbnRoIHx8IG1vbnRoID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXk6IG51bWJlciA9IG1hdGNoW3RoaXMuREFURV9OVU1fR1JPVVBdID9cbiAgICAgICAgICAgIHBhcnNlSW50KG1hdGNoW3RoaXMuREFURV9OVU1fR1JPVVBdLCAxMCkgOlxuICAgICAgICAgICAgT1JESU5BTF9XT1JEU1ttYXRjaFt0aGlzLkRBVEVfR1JPVVBdLnRyaW0oKS5yZXBsYWNlKCctJywgJyAnKS50b0xvd2VyQ2FzZSgpXTtcblxuXG4gICAgICAgIGlmICghZGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oREFZLCBkYXkpO1xuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1PTlRILCBtb250aCk7XG5cbiAgICAgICAgbGV0IHllYXI6IG51bWJlciB8IG51bGwgPSB5ZWFyQ2FsY3VsYXRpb24oXG4gICAgICAgICAgICBtYXRjaFt0aGlzLllFQVJfR1JPVVBdIHx8IG1hdGNoW3RoaXMuWUVBUl9HUk9VUDJdLFxuICAgICAgICAgICAgbWF0Y2hbdGhpcy5ZRUFSX0JFX0dST1VQXSB8fCBtYXRjaFt0aGlzLllFQVJfQkVfR1JPVVAyXVxuICAgICAgICApO1xuXG4gICAgICAgIGlmICh5ZWFyKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKFlFQVIsIHllYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0QXBwcm9wcmlhdGVZZWFyKHJlc3VsdC5zdGFydCwgcmVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlZWtkYXkgY29tcG9uZW50XG4gICAgICAgIGlmIChtYXRjaFt0aGlzLldFRUtEQVlfR1JPVVBdKSB7XG4gICAgICAgICAgICBjb25zdCB3ZWVrZGF5OiBudW1iZXIgPSBXRUVLREFZX09GRlNFVFttYXRjaFt0aGlzLldFRUtEQVlfR1JPVVBdLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXkgfHwgd2Vla2RheSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oV0VFS0RBWSwgd2Vla2RheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXh0IGNhbiBiZSAncmFuZ2UnIHZhbHVlLiBTdWNoIGFzICcxMiAtIDEzIEphbnVhcnkgMjAxMidcbiAgICAgICAgaWYgKG1hdGNoW3RoaXMuREFURV9UT19HUk9VUF0pIHtcbiAgICAgICAgICAgIGNvbnN0IGVuZERhdGUgPSBtYXRjaFt0aGlzLkRBVEVfVE9fTlVNX0dST1VQXSA/XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQobWF0Y2hbdGhpcy5EQVRFX1RPX05VTV9HUk9VUF0sIDEwKSA6XG4gICAgICAgICAgICAgICAgT1JESU5BTF9XT1JEU1ttYXRjaFt0aGlzLkRBVEVfVE9fR1JPVVBdLnRyaW0oKS5yZXBsYWNlKCctJywgJyAnKS50b0xvd2VyQ2FzZSgpXTtcblxuICAgICAgICAgICAgaWYgKGVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZW5kID0gcmVzdWx0LnN0YXJ0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVuZC5hc3NpZ24oREFZLCBlbmREYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSIsIi8qXG4gICAgXG4gICAgVGhlIHBhcnNlciBmb3IgcGFyc2luZyBtb250aCBuYW1lIGFuZCB5ZWFyLlxuICAgIFxuICAgIEVYLiBcbiAgICAgICAgLSBKYW51YXJ5XG4gICAgICAgIC0gSmFudWFyeSAyMDEyXG4gICAgICAgIC0gSmFudWFyeSwgMjAxMlxuKi9cbmltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tICcuLi8uLi9yZXN1bHQnO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jaHJvbm9cIjtcbmltcG9ydCB7TU9OVEhfT0ZGU0VULCB5ZWFyQ2FsY3VsYXRpb259IGZyb20gXCIuLi8uLi91dGlscy9FTlwiO1xuaW1wb3J0IHtEQVksIE1PTlRILCBZRUFSfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQge2dldEFwcHJvcHJpYXRlWWVhcn0gZnJvbSBcIi4uLy4uL3V0aWxzL2dlbmVyYWxcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRU5Nb250aE5hbWVQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIHByaXZhdGUgUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cCgnKF58XFxcXERcXFxccyt8W15cXFxcd1xcXFxzXSknICtcbiAgICAgICAgJyhKYW5cXFxcLj98SmFudWFyeXxGZWJcXFxcLj98RmVicnVhcnl8TWFyXFxcXC4/fE1hcmNofEFwclxcXFwuP3xBcHJpbHxNYXlcXFxcLj98SnVuXFxcXC4/fEp1bmV8SnVsXFxcXC4/fEp1bHl8QXVnXFxcXC4/fEF1Z3VzdHxTZXBcXFxcLj98U2VwdFxcXFwuP3xTZXB0ZW1iZXJ8T2N0XFxcXC4/fE9jdG9iZXJ8Tm92XFxcXC4/fE5vdmVtYmVyfERlY1xcXFwuP3xEZWNlbWJlciknICtcbiAgICAgICAgJ1xcXFxzKicgK1xuICAgICAgICAnKD86JyArXG4gICAgICAgICdbLC1dP1xcXFxzKihbMC05XXs0fSkoXFxcXHMqQkV8QUR8QkMpPycgK1xuICAgICAgICAnKT8nICtcbiAgICAgICAgJyg/PVteXFxcXHNcXFxcd118XFxcXHMrW14wLTldfFxcXFxzKyR8JCknLCAnaScpO1xuXG4gICAgcHJpdmF0ZSBNT05USF9OQU1FX0dST1VQOiBudW1iZXIgPSAyO1xuICAgIHByaXZhdGUgWUVBUl9HUk9VUDogbnVtYmVyID0gMztcbiAgICBwcml2YXRlIFlFQVJfQkVfR1JPVVA6IG51bWJlciA9IDQ7XG5cbiAgICBwcml2YXRlIFRBRzogc3RyaW5nID0gJ0VOTW9udGhOYW1lUGFyc2VyJztcblxuICAgIHBhdHRlcm4oKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuUEFUVEVSTjtcbiAgICB9XG5cbiAgICBleHRyYWN0KHRleHQ6IHN0cmluZywgcmVmOiBEYXRlLCBtYXRjaDogUmVnRXhwRXhlY0FycmF5LCBvcHQ6IFBhcnNlT3B0aW9ucyk6IFBhcnNlZFJlc3VsdCB8IG51bGwge1xuICAgICAgICBjb25zdCBpbmRleDogbnVtYmVyID0gbWF0Y2guaW5kZXggKyBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogUGFyc2VkUmVzdWx0ID0gbmV3IFBhcnNlZFJlc3VsdCh7XG4gICAgICAgICAgICB0ZXh0OiBtYXRjaFswXS5zdWJzdHIobWF0Y2hbMV0ubGVuZ3RoLCBtYXRjaFswXS5sZW5ndGggLSBtYXRjaFsxXS5sZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCBtb250aDogbnVtYmVyID0gTU9OVEhfT0ZGU0VUW21hdGNoW3RoaXMuTU9OVEhfTkFNRV9HUk9VUF0udG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKCEobW9udGggfHwgbW9udGggPT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oREFZLCAxKTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihNT05USCwgbW9udGgpO1xuXG4gICAgICAgIGxldCB5ZWFyOiBudW1iZXIgfCBudWxsID0geWVhckNhbGN1bGF0aW9uKFxuICAgICAgICAgICAgbWF0Y2hbdGhpcy5ZRUFSX0dST1VQXSxcbiAgICAgICAgICAgIG1hdGNoW3RoaXMuWUVBUl9CRV9HUk9VUF1cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoeWVhcikge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCB5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldEFwcHJvcHJpYXRlWWVhcihyZXN1bHQuc3RhcnQsIHJlZik7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSIsImltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tICcuLi8uLi9yZXN1bHQnO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jaHJvbm9cIjtcbmltcG9ydCB7SU5URUdFUl9XT1JEU19QQVRURVJOLCBtYXRjaEludGVnZXIsIG1hdGNoVW5pdH0gZnJvbSBcIi4uLy4uL3V0aWxzL0VOXCI7XG5pbXBvcnQgKiBhcyBtb21lbnQgZnJvbSBcIm1vbWVudFwiO1xuaW1wb3J0IHtNb21lbnR9IGZyb20gXCJtb21lbnRcIjtcbmltcG9ydCB7REFZLCBIT1VSLCBNSU5VVEUsIE1PTlRILCBTRUNPTkQsIFVuaXRPZlRpbWUsIFdFRUssIFlFQVJ9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRU5SZWxhdGl2ZURhdGVGb3JtYXRQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIHByaXZhdGUgUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cCgnKFxcXFxXfF4pJyArXG4gICAgICAgICcodGhpc3xuZXh0fGxhc3R8cGFzdClcXFxccyonICtcbiAgICAgICAgJygnICsgSU5URUdFUl9XT1JEU19QQVRURVJOICsgJ3xbMC05XSt8ZmV3fGhhbGYoPzpcXFxccyphbj8pPyk/XFxcXHMqJyArXG4gICAgICAgICcoc2Vjb25kcz98bWluKD86dXRlKT9zP3xob3Vycz98ZGF5cz98d2Vla3M/fG1vbnRocz98eWVhcnM/KSg/PVxcXFxzKiknICtcbiAgICAgICAgJyg/PVxcXFxXfCQpJywgJ2knXG4gICAgKTtcblxuICAgIHByaXZhdGUgTU9ESUZJRVJfV09SRF9HUk9VUDogbnVtYmVyID0gMjtcbiAgICBwcml2YXRlIE1VTFRJUExJRVJfV09SRF9HUk9VUDogbnVtYmVyID0gMztcbiAgICBwcml2YXRlIFJFTEFUSVZFX1dPUkRfR1JPVVA6IG51bWJlciA9IDQ7XG5cbiAgICBwcml2YXRlIE9USEVSX1BBVFRFUk5TOiBSZWdFeHBbXSA9IFtcbiAgICAgICAgL15uZXh0LyxcbiAgICAgICAgL150aGlzL1xuICAgIF07XG5cbiAgICBwcml2YXRlIFRBRzogc3RyaW5nID0gJ0VOUmVsYXRpdmVEYXRlRm9ybWF0UGFyc2VyJztcblxuICAgIHBhdHRlcm4oKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuUEFUVEVSTjtcbiAgICB9XG5cbiAgICBleHRyYWN0KHRleHQ6IHN0cmluZywgcmVmOiBEYXRlLCBtYXRjaDogUmVnRXhwRXhlY0FycmF5LCBvcHQ6IFBhcnNlT3B0aW9ucyk6IFBhcnNlZFJlc3VsdCB8IG51bGwge1xuICAgICAgICBjb25zdCBpbmRleDogbnVtYmVyID0gbWF0Y2guaW5kZXggKyBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogUGFyc2VkUmVzdWx0ID0gbmV3IFBhcnNlZFJlc3VsdCh7XG4gICAgICAgICAgICB0ZXh0OiBtYXRjaFswXS5zdWJzdHIobWF0Y2hbMV0ubGVuZ3RoLCBtYXRjaFswXS5sZW5ndGggLSBtYXRjaFsxXS5sZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCBtYXRjaGVkVW5pdDogc3RyaW5nID0gbWF0Y2hbdGhpcy5SRUxBVElWRV9XT1JEX0dST1VQXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB1bml0OiBVbml0T2ZUaW1lIHwgdW5kZWZpbmVkID0gbWF0Y2hVbml0KG1hdGNoZWRVbml0KTtcblxuICAgICAgICBpZiAoIXVuaXQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWF0Y2hlZE11bHRpcGxpZXI6IHN0cmluZyA9IG1hdGNoW3RoaXMuTVVMVElQTElFUl9XT1JEX0dST1VQXTtcbiAgICAgICAgY29uc3QgbWF0Y2hlZE1vZGlmaWVyOiBzdHJpbmcgPSBtYXRjaFt0aGlzLk1PRElGSUVSX1dPUkRfR1JPVVBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IG1vbWVudFJlZjogTW9tZW50ID0gbW9tZW50KHJlZik7XG4gICAgICAgIGNvbnN0IG51bTogbnVtYmVyID0gbWF0Y2hJbnRlZ2VyKG1hdGNoZWRNdWx0aXBsaWVyKTtcblxuICAgICAgICBpZiAobWF0Y2hlZE1vZGlmaWVyLm1hdGNoKHRoaXMuT1RIRVJfUEFUVEVSTlNbMV0pKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hlZE11bHRpcGxpZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBXRUVLOlxuICAgICAgICAgICAgICAgICAgICBtb21lbnRSZWYuc2V0KCd3ZWVrZGF5JywgMCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShEQVksIG1vbWVudFJlZi5kYXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTU9OVEgsIG1vbWVudFJlZi5tb250aCgpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShZRUFSLCBtb21lbnRSZWYueWVhcigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBNT05USDpcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50UmVmLnNldCgnZGF0ZScsIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoREFZLCBtb21lbnRSZWYuZGF0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihNT05USCwgbW9tZW50UmVmLm1vbnRoKCkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCBtb21lbnRSZWYueWVhcigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBZRUFSOlxuICAgICAgICAgICAgICAgICAgICBtb21lbnRSZWYuc2V0KCdkYXlPZlllYXInLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KERBWSwgbW9tZW50UmVmLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNT05USCwgbW9tZW50UmVmLm1vbnRoKCkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCBtb21lbnRSZWYueWVhcigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVyOiBudW1iZXIgPSBtYXRjaGVkTW9kaWZpZXIubWF0Y2godGhpcy5PVEhFUl9QQVRURVJOU1swXSkgPyAxIDogLTE7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQ6IG51bWJlciA9IG1vZGlmaWVyICogKG51bSB8fCAxKTtcbiAgICAgICAgICAgIGxldCB0aW1lTW9kZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFNFQ09ORDpcbiAgICAgICAgICAgICAgICAgICAgdGltZU1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtb21lbnRSZWYuYWRkKG9mZnNldCwgJ3NlY29uZCcpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTUlOVVRFLCBtb21lbnRSZWYubWludXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoU0VDT05ELCBtb21lbnRSZWYuc2Vjb25kKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIE1JTlVURTpcbiAgICAgICAgICAgICAgICAgICAgdGltZU1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtb21lbnRSZWYuYWRkKG9mZnNldCwgJ21pbnV0ZScpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1JTlVURSwgbW9tZW50UmVmLm1pbnV0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KFNFQ09ORCwgbW9tZW50UmVmLnNlY29uZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBIT1VSOlxuICAgICAgICAgICAgICAgICAgICB0aW1lTW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFJlZi5hZGQob2Zmc2V0LCAnaG91cicpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTUlOVVRFLCBtb21lbnRSZWYubWludXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoU0VDT05ELCBtb21lbnRSZWYuc2Vjb25kKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIERBWTpcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50UmVmLmFkZChvZmZzZXQsICdkJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oWUVBUiwgbW9tZW50UmVmLnllYXIoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTU9OVEgsIG1vbWVudFJlZi5tb250aCgpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oREFZLCBtb21lbnRSZWYuZGF0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBXRUVLOlxuICAgICAgICAgICAgICAgICAgICBtb21lbnRSZWYuYWRkKG9mZnNldCAqIDcsICdkJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNT05USCwgbW9tZW50UmVmLm1vbnRoKCkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KFlFQVIsIG1vbWVudFJlZi55ZWFyKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoREFZLCBtb21lbnRSZWYuZGF0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBNT05USDpcbiAgICAgICAgICAgICAgICAgICAgbW9tZW50UmVmLmFkZChvZmZzZXQsICdtb250aCcpO1xuICAgICAgICAgICAgICAgICAgICBtb21lbnRSZWYuc2V0KCdkYXRlJywgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oWUVBUiwgbW9tZW50UmVmLnllYXIoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTU9OVEgsIG1vbWVudFJlZi5tb250aCgpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShEQVksIG1vbWVudFJlZi5kYXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFlFQVI6XG4gICAgICAgICAgICAgICAgICAgIG1vbWVudFJlZi5hZGQob2Zmc2V0LCAneWVhcicpO1xuICAgICAgICAgICAgICAgICAgICBtb21lbnRSZWYuc2V0KCdkYXlPZlllYXInLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KERBWSwgbW9tZW50UmVmLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNT05USCwgbW9tZW50UmVmLm1vbnRoKCkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCBtb21lbnRSZWYueWVhcigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aW1lTW9kZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oSE9VUiwgbW9tZW50UmVmLmhvdXIoKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCBtb21lbnRSZWYueWVhcigpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1PTlRILCBtb21lbnRSZWYubW9udGgoKSArIDEpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oREFZLCBtb21lbnRSZWYuZGF0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59IiwiLypcbiAgICBEYXRlIGZvcm1hdCB3aXRoIHNsYXNoIFwiL1wiIChhbHNvIFwiLVwiIGFuZCBcIi5cIikgYmV0d2VlbiBudW1iZXJzXG4gICAgLSBUdWVzZGF5IDExLzMvMjAxNSBcbiAgICAtIDExLzMvMjAxNVxuICAgIC0gMTEvM1xuXG4gICAgQnkgZGVmYXVsdCB0aGUgcGFzZXIgdXMgXCJtaWRkbGUtZW5kaWVuXCIgZm9ybWF0IChVUyBFbmdsaXNoKSxcbiAgICB0aGVuIGZhbGxiYWNrIHRvIGxpdHRsZS1lbmRpYW4gaWYgZmFpbGVkLlxuICAgIC0gMTEvMy8yMDE1ID0gTm92ZW1iZXIgM3JkLCAyMDE1XG4gICAgLSAyMy80LzIwMTUgPSBBcHJpbCAyM3RoLCAyMDE1XG5cbiAgICBJZiBcImxpdHRsZUVuZGlhblwiIGNvbmZpZyBpcyBzZXQsIHRoZSBwYXJzZXIgd2lsbCB0cnkgdGhlIGxpdHRsZS1lbmRpYW4gZmlyc3QuIFxuICAgIC0gMTEvMy8yMDE1ID0gTWFyY2ggMTF0aCwgMjAxNVxuKi9cblxuaW1wb3J0ICogYXMgbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgUGFyc2VyIGZyb20gJy4uL3BhcnNlcic7XG5pbXBvcnQge1BhcnNlZFJlc3VsdH0gZnJvbSAnLi4vLi4vcmVzdWx0JztcbmltcG9ydCB7UGFyc2VPcHRpb25zfSBmcm9tIFwiLi4vLi4vY2hyb25vXCI7XG5pbXBvcnQge0NvbmZpZ30gZnJvbSBcIi4uLy4uL29wdGlvbnNcIjtcbmltcG9ydCB7REFZLCBNT05USCwgV0VFS0RBWSwgWUVBUn0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHtXRUVLREFZX09GRlNFVH0gZnJvbSBcIi4uLy4uL3V0aWxzL0VOXCI7XG5pbXBvcnQge2NoZWNrTW9udGhEYXlzVmFsaWR9IGZyb20gXCIuLi8uLi91dGlscy9nZW5lcmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVOU2xhc2hEYXRlRm9ybWF0UGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBwcml2YXRlIFBBVFRFUk46IFJlZ0V4cCA9IG5ldyBSZWdFeHAoJyhcXFxcV3xeKScgK1xuICAgICAgICAnKD86JyArXG4gICAgICAgICcoPzpvblxcXFxzKj8pPycgK1xuICAgICAgICAnKCg/OnN1bnxtb258dHVlcz98d2VkKD86bmVzKT98dGh1KD86cnM/KT98ZnJpfHNhdCg/OnVyKT8pKD86ZGF5KT8pJyArXG4gICAgICAgICdcXFxccypcXFxcLD9cXFxccyonICtcbiAgICAgICAgJyk/JyArXG4gICAgICAgICcoWzAtM117MCwxfVswLTldezF9KVtcXFxcL1xcXFwuXFxcXC1dKFswLTNdezAsMX1bMC05XXsxfSknICtcbiAgICAgICAgJyg/OicgK1xuICAgICAgICAnW1xcXFwvXFxcXC5cXFxcLV0nICtcbiAgICAgICAgJyhbMC05XXs0fVxccypcXCw/XFxzKnxbMC05XXsyfVxccypcXCw/XFxzKiknICtcbiAgICAgICAgJyk/JyArXG4gICAgICAgICcoXFxcXFd8JCknLCAnaScpO1xuXG4gICAgcHJpdmF0ZSBPUEVOSU5HX0dST1VQOiBudW1iZXIgPSAxO1xuICAgIHByaXZhdGUgRU5ESU5HX0dST1VQOiBudW1iZXIgPSA2O1xuXG4gICAgcHJpdmF0ZSBXRUVLREFZX0dST1VQOiBudW1iZXIgPSAyO1xuXG4gICAgcHJpdmF0ZSBGSVJTVF9OVU1CRVJTX0dST1VQOiBudW1iZXIgPSAzO1xuICAgIHByaXZhdGUgU0VDT05EX05VTUJFUlNfR1JPVVA6IG51bWJlciA9IDQ7XG5cbiAgICBwcml2YXRlIFlFQVJfR1JPVVA6IG51bWJlciA9IDU7XG5cbiAgICBwcml2YXRlIFRBRzogc3RyaW5nID0gJ0VOU2xhc2hEYXRlRm9ybWF0UGFyc2VyJztcblxuICAgIHByaXZhdGUgTU9OVEhfR1JPVVA6IG51bWJlcjtcbiAgICBwcml2YXRlIERBWV9HUk9VUDogbnVtYmVyO1xuXG4gICAgcHJpdmF0ZSBPVEhFUl9QQVRURVJOUzogUmVnRXhwW10gPSBbXG4gICAgICAgIC9eXFxkXFwuXFxkJC8sXG4gICAgICAgIC9eXFxkXFwuXFxkezEsMn1cXC5cXGR7MSwyfSQvXG4gICAgXTtcblxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZzogQ29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5saXR0bGVFbmRpYW4pIHtcbiAgICAgICAgICAgIHRoaXMuTU9OVEhfR1JPVVAgPSB0aGlzLlNFQ09ORF9OVU1CRVJTX0dST1VQO1xuICAgICAgICAgICAgdGhpcy5EQVlfR1JPVVAgPSB0aGlzLkZJUlNUX05VTUJFUlNfR1JPVVA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLkRBWV9HUk9VUCA9IHRoaXMuU0VDT05EX05VTUJFUlNfR1JPVVA7XG4gICAgICAgICAgICB0aGlzLk1PTlRIX0dST1VQID0gdGhpcy5GSVJTVF9OVU1CRVJTX0dST1VQO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGF0dGVybigpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gdGhpcy5QQVRURVJOO1xuICAgIH1cblxuICAgIGV4dHJhY3QodGV4dDogc3RyaW5nLCByZWY6IERhdGUsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0IHwgbnVsbCB7XG4gICAgICAgIGlmIChtYXRjaFt0aGlzLk9QRU5JTkdfR1JPVVBdID09ICcvJyB8fCBtYXRjaFt0aGlzLkVORElOR19HUk9VUF0gPT0gJy8nKSB7XG4gICAgICAgICAgICAvLyBMb25nIHNraXAsIGlmIHRoZXJlIGlzIHNvbWUgb3ZlcmxhcHBpbmcgbGlrZTpcbiAgICAgICAgICAgIC8vIFhYWy9ZWS9aWl1cbiAgICAgICAgICAgIC8vIFtYWC9ZWS9dWlpcbiAgICAgICAgICAgIG1hdGNoLmluZGV4ICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW5kZXg6IG51bWJlciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFJlc3VsdCA9IG5ldyBQYXJzZWRSZXN1bHQoe1xuICAgICAgICAgICAgdGV4dDogbWF0Y2hbMF0uc3Vic3RyKG1hdGNoW3RoaXMuT1BFTklOR19HUk9VUF0ubGVuZ3RoLCBtYXRjaFswXS5sZW5ndGggLSBtYXRjaFt0aGlzLkVORElOR19HUk9VUF0ubGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcmVmXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3VsdC50YWdzW3RoaXMuVEFHXSA9IHRydWU7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRUZXh0OiBzdHJpbmcgPSByZXN1bHQudGV4dC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmIChtYXRjaGVkVGV4dC5tYXRjaCh0aGlzLk9USEVSX1BBVFRFUk5TWzBdKSB8fCBtYXRjaGVkVGV4dC5tYXRjaCh0aGlzLk9USEVSX1BBVFRFUk5TWzFdKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNTS9kZCAtPiBPS1xuICAgICAgICAvLyBNTS5kZCAtPiBOR1xuICAgICAgICBpZiAoIW1hdGNoW3RoaXMuWUVBUl9HUk9VUF0gJiYgbWF0Y2hbMF0uaW5kZXhPZignLycpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgeWVhcjogbnVtYmVyID0gbWF0Y2hbdGhpcy5ZRUFSX0dST1VQXSA/IHBhcnNlSW50KG1hdGNoW3RoaXMuWUVBUl9HUk9VUF0sIDEwKSA6IG1vbWVudChyZWYpLnllYXIoKTtcbiAgICAgICAgbGV0IG1vbnRoOiBudW1iZXIgPSBwYXJzZUludChtYXRjaFt0aGlzLk1PTlRIX0dST1VQXSwgMTApO1xuICAgICAgICBsZXQgZGF5OiBudW1iZXIgPSBwYXJzZUludChtYXRjaFt0aGlzLkRBWV9HUk9VUF0sIDEwKTtcblxuICAgICAgICBpZiAobW9udGggPCAxIHx8IGRheSA8IDEgfHwgZGF5ID4gMzEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeWVhciA8IDEwMCkge1xuICAgICAgICAgICAgaWYgKHllYXIgPiA1MCkge1xuICAgICAgICAgICAgICAgIHllYXIgPSB5ZWFyICsgMTkwMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeWVhciA9IHllYXIgKyAyMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vbnRoID4gMTIpIHtcbiAgICAgICAgICAgIGlmIChtb250aCA8PSAzMSAmJiBkYXkgPD0gMTIgJiYgY2hlY2tNb250aERheXNWYWxpZChtb250aCwgZGF5LCB5ZWFyKSkge1xuICAgICAgICAgICAgICAgIFttb250aCwgZGF5XSA9IFtkYXksIG1vbnRoXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKERBWSwgZGF5KTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihNT05USCwgbW9udGgpO1xuICAgICAgICBpZiAobWF0Y2hbdGhpcy5ZRUFSX0dST1VQXSkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCB5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShZRUFSLCB5ZWFyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaFt0aGlzLldFRUtEQVlfR1JPVVBdKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKFdFRUtEQVksIFdFRUtEQVlfT0ZGU0VUW21hdGNoW3RoaXMuV0VFS0RBWV9HUk9VUF0udG9Mb3dlckNhc2UoKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59IiwiLypcbiAgICBEYXRlIGZvcm1hdCB3aXRoIHNsYXNoIFwiL1wiIGJldHdlZW4gbnVtYmVycyBsaWtlIEVOU2xhc2hEYXRlRm9ybWF0UGFyc2VyLFxuICAgIGJ1dCB0aGlzIHBhcnNlciBleHBlY3QgeWVhciBiZWZvcmUgbW9udGggYW5kIGRhdGUuIFxuICAgIC0gWVlZWS9NTS9ERFxuICAgIC0gWVlZWS1NTS1ERFxuICAgIC0gWVlZWS5NTS5ERFxuKi9cbmltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tICcuLi8uLi9yZXN1bHQnO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jaHJvbm9cIjtcbmltcG9ydCB7Y2hlY2tNb250aERheXNWYWxpZH0gZnJvbSBcIi4uLy4uL3V0aWxzL2dlbmVyYWxcIjtcbmltcG9ydCB7REFZLCBNT05USCwgWUVBUn0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFTlNsYXNoRGF0ZUZvcm1hdFN0YXJ0V2l0aFllYXJQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIHByaXZhdGUgUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cCgnKFxcXFxXfF4pJ1xuICAgICAgICArICcoWzAtOV17NH0pW1xcXFwtXFxcXC5cXFxcL10oWzAtOV17MSwyfSlbXFxcXC1cXFxcLlxcXFwvXShbMC05XXsxLDJ9KSdcbiAgICAgICAgKyAnKD89XFxcXFd8JCknLCAnaScpO1xuXG4gICAgcHJpdmF0ZSBZRUFSX05VTUJFUl9HUk9VUDogbnVtYmVyID0gMjtcbiAgICBwcml2YXRlIE1PTlRIX05VTUJFUl9HUk9VUDogbnVtYmVyID0gMztcbiAgICBwcml2YXRlIERBVEVfTlVNQkVSX0dST1VQOiBudW1iZXIgPSA0O1xuXG4gICAgcHJpdmF0ZSBUQUc6IHN0cmluZyA9ICdFTlNsYXNoRGF0ZUZvcm1hdFN0YXJ0V2l0aFllYXJQYXJzZXInO1xuXG4gICAgcGF0dGVybigpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gdGhpcy5QQVRURVJOO1xuICAgIH1cblxuICAgIGV4dHJhY3QodGV4dDogc3RyaW5nLCByZWY6IERhdGUsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGluZGV4OiBudW1iZXIgPSBtYXRjaC5pbmRleCArIG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBQYXJzZWRSZXN1bHQgPSBuZXcgUGFyc2VkUmVzdWx0KHtcbiAgICAgICAgICAgIHRleHQ6IG1hdGNoWzBdLnN1YnN0cihtYXRjaFsxXS5sZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCB5ZWFyOiBudW1iZXIgPSBwYXJzZUludChtYXRjaFt0aGlzLllFQVJfTlVNQkVSX0dST1VQXSwgMTApO1xuICAgICAgICBjb25zdCBtb250aDogbnVtYmVyID0gcGFyc2VJbnQobWF0Y2hbdGhpcy5NT05USF9OVU1CRVJfR1JPVVBdLCAxMCk7XG4gICAgICAgIGNvbnN0IGRheTogbnVtYmVyID0gcGFyc2VJbnQobWF0Y2hbdGhpcy5EQVRFX05VTUJFUl9HUk9VUF0sIDEwKTtcblxuICAgICAgICBpZiAobW9udGggPiAxMiB8fCBtb250aCA8IDEgfHwgZGF5ID4gMzEgfHwgZGF5IDwgMSB8fCAhY2hlY2tNb250aERheXNWYWxpZChkYXksIG1vbnRoLCB5ZWFyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKFlFQVIsIHllYXIpO1xuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1PTlRILCBtb250aCk7XG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oREFZLCBkYXkpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSIsIi8qXG4gICAgTW9udGgvWWVhciBkYXRlIGZvcm1hdCB3aXRoIHNsYXNoIFwiL1wiIChhbHNvIFwiLVwiIGFuZCBcIi5cIikgYmV0d2VlbiBudW1iZXJzIFxuICAgIC0gMTEvMDVcbiAgICAtIDA2LzIwMDVcbiovXG5cbmltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tICcuLi8uLi9yZXN1bHQnO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jaHJvbm9cIjtcbmltcG9ydCB7REFZLCBIT1VSLCBNT05USCwgWUVBUn0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFTlNsYXNoTW9udGhGb3JtYXRQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIHByaXZhdGUgUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cCgnKF58W15cXFxcZC9dXFxcXHMrfFteXFxcXHdcXFxcc10pJyArXG4gICAgICAgICcoWzAtOV18MFsxLTldfDFbMDEyXSkvKFswLTldezR9KScgK1xuICAgICAgICAnKFteXFxcXGQvXXwkKScsICdpJyk7XG5cbiAgICBwcml2YXRlIE9QRU5JTkdfR1JPVVA6IG51bWJlciA9IDE7XG4gICAgcHJpdmF0ZSBFTkRJTkdfR1JPVVA6IG51bWJlciA9IDQ7XG4gICAgcHJpdmF0ZSBNT05USF9HUk9VUDogbnVtYmVyID0gMjtcbiAgICBwcml2YXRlIFlFQVJfR1JPVVA6IG51bWJlciA9IDM7XG5cbiAgICBwcml2YXRlIFRBRzogc3RyaW5nID0gJ0VOU2xhc2hNb250aEZvcm1hdFBhcnNlcic7XG5cbiAgICBwYXR0ZXJuKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiB0aGlzLlBBVFRFUk47XG4gICAgfVxuXG4gICAgZXh0cmFjdCh0ZXh0OiBzdHJpbmcsIHJlZjogRGF0ZSwgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSwgb3B0OiBQYXJzZU9wdGlvbnMpOiBQYXJzZWRSZXN1bHQgfCBudWxsIHtcbiAgICAgICAgY29uc3QgaW5kZXg6IG51bWJlciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbdGhpcy5PUEVOSU5HX0dST1VQXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogUGFyc2VkUmVzdWx0ID0gbmV3IFBhcnNlZFJlc3VsdCh7XG4gICAgICAgICAgICB0ZXh0OiBtYXRjaFswXS5zdWJzdHIobWF0Y2hbdGhpcy5PUEVOSU5HX0dST1VQXS5sZW5ndGgsIG1hdGNoWzBdLmxlbmd0aCAtICgxICsgbWF0Y2hbdGhpcy5FTkRJTkdfR1JPVVBdLmxlbmd0aCkpLnRyaW0oKSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcmVmXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3VsdC50YWdzW3RoaXMuVEFHXSA9IHRydWU7XG5cbiAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KERBWSwgMSk7XG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTU9OVEgsIHBhcnNlSW50KG1hdGNoW3RoaXMuTU9OVEhfR1JPVVBdLCAxMCkpO1xuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKFlFQVIsIHBhcnNlSW50KG1hdGNoW3RoaXMuWUVBUl9HUk9VUF0sIDEwKSk7XG5cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0iLCJpbXBvcnQgUGFyc2VyIGZyb20gJy4uL3BhcnNlcic7XG5pbXBvcnQge1BhcnNlZFJlc3VsdH0gZnJvbSAnLi4vLi4vcmVzdWx0JztcbmltcG9ydCB7UGFyc2VPcHRpb25zfSBmcm9tIFwiLi4vLi4vY2hyb25vXCI7XG5pbXBvcnQge0RBWSwgSE9VUiwgTUlOVVRFLCBNT05USCwgU0VDT05ELCBXRUVLREFZLCBZRUFSfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQge1xuICAgIGV4dHJhY3REYXRlVGltZVVuaXRGcmFnbWVudHMsXG4gICAgRnJhZ21lbnRNYXAsXG4gICAgRnJhZ21lbnROYW1lLFxuICAgIFRJTUVfVU5JVF9QQVRURVJOLFxuICAgIFRJTUVfVU5JVF9TVFJJQ1RfUEFUVEVSTlxufSBmcm9tIFwiLi4vLi4vdXRpbHMvRU5cIjtcbmltcG9ydCAqIGFzIG1vbWVudCBmcm9tIFwibW9tZW50XCI7XG5pbXBvcnQge01vbWVudH0gZnJvbSBcIm1vbWVudFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFTlRpbWVBZ29Gb3JtYXRQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIHByaXZhdGUgUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cCgnJyArXG4gICAgICAgICcoXFxcXFd8XiknICtcbiAgICAgICAgJyg/OndpdGhpblxcXFxzKik/JyArXG4gICAgICAgICcoJyArIFRJTUVfVU5JVF9QQVRURVJOICsgJyknICtcbiAgICAgICAgJyg/OmFnb3xiZWZvcmV8ZWFybGllcikoPz0oPzpcXFxcV3wkKSknLCAnaScpO1xuXG4gICAgcHJpdmF0ZSBTVFJJQ1RfUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cCgnJyArXG4gICAgICAgICcoXFxcXFd8XiknICtcbiAgICAgICAgJyg/OndpdGhpblxcXFxzKik/JyArXG4gICAgICAgICcoJyArIFRJTUVfVU5JVF9TVFJJQ1RfUEFUVEVSTiArICcpJyArXG4gICAgICAgICdhZ28oPz0oPzpcXFxcV3wkKSknLCAnaScpO1xuXG4gICAgcHJpdmF0ZSBUQUc6IHN0cmluZyA9ICdFTlRpbWVBZ29Gb3JtYXRQYXJzZXInO1xuXG4gICAgcHJpdmF0ZSBPVEhFUl9QQVRURVJOUzogUmVnRXhwW10gPSBbXG4gICAgICAgIC9cXHcvXG4gICAgXTtcblxuICAgIHBhdHRlcm4oKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTdHJpY3RNb2RlKCkgPyB0aGlzLlNUUklDVF9QQVRURVJOIDogdGhpcy5QQVRURVJOO1xuICAgIH1cblxuICAgIGV4dHJhY3QodGV4dDogc3RyaW5nLCByZWY6IERhdGUsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0IHwgbnVsbCB7XG4gICAgICAgIGlmIChtYXRjaC5pbmRleCA+IDAgJiYgdGV4dFttYXRjaC5pbmRleCAtIDFdLm1hdGNoKHRoaXMuT1RIRVJfUEFUVEVSTlNbMF0pKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBjb25zdCBpbmRleDogbnVtYmVyID0gbWF0Y2guaW5kZXggKyBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogUGFyc2VkUmVzdWx0ID0gbmV3IFBhcnNlZFJlc3VsdCh7XG4gICAgICAgICAgICB0ZXh0OiBtYXRjaFswXS5zdWJzdHIobWF0Y2hbMV0ubGVuZ3RoLCBtYXRjaFswXS5sZW5ndGggLSBtYXRjaFsxXS5sZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCBmcmFnbWVudHM6IEZyYWdtZW50TWFwID0gZXh0cmFjdERhdGVUaW1lVW5pdEZyYWdtZW50cyhtYXRjaFsyXSk7XG4gICAgICAgIGNvbnN0IG1vbWVudFJlZjogTW9tZW50ID0gbW9tZW50KHJlZik7XG5cbiAgICAgICAgKE9iamVjdC5rZXlzKGZyYWdtZW50cykgYXMgRnJhZ21lbnROYW1lW10pLmZvckVhY2goKGZyYWdtZW50OiBGcmFnbWVudE5hbWUpID0+IHtcbiAgICAgICAgICAgIG1vbWVudFJlZi5hZGQoLWZyYWdtZW50c1tmcmFnbWVudF0hLCBmcmFnbWVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICgoZnJhZ21lbnRzWydob3VyJ10gfHwgMCkgPiAwIHx8IChmcmFnbWVudHNbJ21pbnV0ZSddIHx8IDApID4gMCB8fCAoZnJhZ21lbnRzWydzZWNvbmQnXSB8fCAwKSA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oSE9VUiwgbW9tZW50UmVmLmhvdXIoKSk7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1JTlVURSwgbW9tZW50UmVmLm1pbnV0ZSgpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oU0VDT05ELCBtb21lbnRSZWYuc2Vjb25kKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChmcmFnbWVudHNbJ2QnXSB8fCAwKSA+IDAgfHwgKGZyYWdtZW50c1snbW9udGgnXSB8fCAwKSA+IDAgfHwgKGZyYWdtZW50c1sneWVhciddIHx8IDApID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihEQVksIG1vbWVudFJlZi5kYXRlKCkpO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihNT05USCwgbW9tZW50UmVmLm1vbnRoKCkgKyAxKTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oWUVBUiwgbW9tZW50UmVmLnllYXIoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoKGZyYWdtZW50c1snd2VlayddIHx8IDApID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShXRUVLREFZLCBtb21lbnRSZWYuZGF5KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoREFZLCBtb21lbnRSZWYuZGF0ZSgpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNT05USCwgbW9tZW50UmVmLm1vbnRoKCkgKyAxKTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShZRUFSLCBtb21lbnRSZWYueWVhcigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSIsImltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkQ29tcG9uZW50cywgUGFyc2VkUmVzdWx0fSBmcm9tIFwiLi4vLi4vcmVzdWx0XCI7XG5pbXBvcnQge1BhcnNlT3B0aW9uc30gZnJvbSBcIi4uLy4uL2Nocm9ub1wiO1xuaW1wb3J0IHtEQVksIEhPVVIsIE1FUklESUVNLCBNSUxMSVNFQ09ORCwgTUlOVVRFLCBNT05USCwgU0VDT05ELCBZRUFSfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgKiBhcyBtb21lbnQgZnJvbSBcIm1vbWVudFwiO1xuaW1wb3J0IHtNb21lbnR9IGZyb20gXCJtb21lbnRcIjtcblxudHlwZSBUaW1lID0gW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRU5UaW1lRXhwcmVzc2lvblBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgcHJpdmF0ZSBQQVRURVJOOiBSZWdFeHAgPSBuZXcgUmVnRXhwKFwiKF58XFxcXHN8VClcIiArXG4gICAgICAgIFwiKD86KD86YXR8ZnJvbSlcXFxccyopPz9cIiArXG4gICAgICAgIFwiKFxcXFxkezEsNH18bm9vbnxtaWRuaWdodClcIiArXG4gICAgICAgIFwiKD86XCIgK1xuICAgICAgICBcIig/OlxcXFwufFxcXFw6fFxcXFzvvJopKFxcXFxkezEsMn0pXCIgK1xuICAgICAgICBcIig/OlwiICtcbiAgICAgICAgXCIoPzpcXFxcOnxcXFxc77yaKShcXFxcZHsyfSkoPzpcXFxcLihcXFxcZHsxLDZ9KSk/XCIgK1xuICAgICAgICBcIik/XCIgK1xuICAgICAgICBcIik/XCIgK1xuICAgICAgICBcIig/OlxcXFxzKihBXFxcXC5NXFxcXC58UFxcXFwuTVxcXFwufEFNP3xQTT98T1xcXFxXKkNMT0NLKSk/XCIgK1xuICAgICAgICBcIig/PVxcXFxXfCQpXCIsICdpJyk7XG5cbiAgICBwcml2YXRlIEVORF9QQVRURVJOOiBSZWdFeHAgPSBuZXcgUmVnRXhwKFwiXlxcXFxzKlwiICtcbiAgICAgICAgXCIoXFxcXC18XFxcXOKAk3xcXFxcfnxcXFxc44CcfHRvfCg/OnVuKT90aWxsP3xcXFxcPylcXFxccypcIiArXG4gICAgICAgIFwiKFxcXFxkezEsNH0pXCIgK1xuICAgICAgICBcIig/OlwiICtcbiAgICAgICAgXCIoPzpcXFxcLnxcXFxcOnxcXFxc77yaKShcXFxcZHsxLDJ9KVwiICtcbiAgICAgICAgXCIoPzpcIiArXG4gICAgICAgIFwiKD86XFxcXC58XFxcXDp8XFxcXO+8mikoXFxcXGR7MSwyfSkoPzpcXFxcLihcXFxcZHsxLDZ9KSk/XCIgK1xuICAgICAgICBcIik/XCIgK1xuICAgICAgICBcIik/XCIgK1xuICAgICAgICBcIig/OlxcXFxzKihBXFxcXC5NXFxcXC58UFxcXFwuTVxcXFwufEFNP3xQTT98T1xcXFxXKkNMT0NLKSk/XCIgK1xuICAgICAgICBcIig/PVxcXFxXfCQpXCIsICdpJyk7XG5cbiAgICBwcml2YXRlIEhPVVJfR1JPVVAgPSAyO1xuICAgIHByaXZhdGUgTUlOVVRFX0dST1VQID0gMztcbiAgICBwcml2YXRlIFNFQ09ORF9HUk9VUCA9IDQ7XG4gICAgcHJpdmF0ZSBNSUxMSV9TRUNPTkRfR1JPVVAgPSA1O1xuICAgIHByaXZhdGUgQU1fUE1fSE9VUl9HUk9VUCA9IDY7XG5cbiAgICBwcml2YXRlIFRBRzogc3RyaW5nID0gJ0VOVGltZUV4cHJlc3Npb25QYXJzZXInO1xuXG4gICAgcHJpdmF0ZSBPVEhFUl9QQVRURVJOUzogUmVnRXhwW10gPSBbXG4gICAgICAgIC9cXHcvLFxuICAgICAgICAvXlxccyooWytcXC1dKVxcZHszLDR9JC8sXG4gICAgICAgIC9eXFxkKyQvLFxuXG4gICAgXTtcblxuICAgIHBhdHRlcm4oKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuUEFUVEVSTjtcbiAgICB9XG5cbiAgICBleHRyYWN0KHRleHQ6IHN0cmluZywgcmVmOiBEYXRlLCBtYXRjaDogUmVnRXhwRXhlY0FycmF5LCBvcHQ6IFBhcnNlT3B0aW9ucyk6IFBhcnNlZFJlc3VsdCB8IG51bGwge1xuICAgICAgICAvLyBUaGlzIHBhdHRlcm4gY2FuIGJlIG92ZXJsYXBlZCBFeC4gWzEyXSBBTSwgMVsyXSBBTVxuICAgICAgICBpZiAobWF0Y2guaW5kZXggPiAwICYmIHRleHRbbWF0Y2guaW5kZXggLSAxXS5tYXRjaCh0aGlzLk9USEVSX1BBVFRFUk5TWzBdKSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgY29uc3QgcmVmTW9tZW50OiBNb21lbnQgPSBtb21lbnQocmVmKTtcblxuICAgICAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFJlc3VsdCA9IG5ldyBQYXJzZWRSZXN1bHQoe1xuICAgICAgICAgICAgdGV4dDogbWF0Y2hbMF0uc3Vic3RyaW5nKG1hdGNoWzFdLmxlbmd0aCksXG4gICAgICAgICAgICBpbmRleDogbWF0Y2guaW5kZXggKyBtYXRjaFsxXS5sZW5ndGgsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcblxuICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoREFZLCByZWZNb21lbnQuZGF0ZSgpKTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1PTlRILCByZWZNb21lbnQubW9udGgoKSArIDEpO1xuICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoWUVBUiwgcmVmTW9tZW50LnllYXIoKSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmV4dHJhY3RGaXJzdENodW5rKHJlc3VsdCwgbWF0Y2gpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5leHRyYWN0U2Vjb25kQ2h1bmsodGV4dCwgcmVzdWx0KSAmJiByZXN1bHQudGV4dC5tYXRjaCh0aGlzLk9USEVSX1BBVFRFUk5TWzJdKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHByaXZhdGUgZXh0cmFjdEZpcnN0Q2h1bmsocmVzdWx0OiBQYXJzZWRSZXN1bHQsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXkpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgdGltZTogVGltZSB8IGZhbHNlID0gdGhpcy5nZXRUaW1lKG1hdGNoKTtcbiAgICAgICAgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgW2hvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgbWVyaWRpZW1dOiBUaW1lID0gdGltZTtcblxuICAgICAgICBpZiAoc2Vjb25kID4gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oU0VDT05ELCBzZWNvbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kID4gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTUlMTElTRUNPTkQsIG1pbGxpc2Vjb25kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tIEFNICYgUE1cbiAgICAgICAgaWYgKG1hdGNoW3RoaXMuQU1fUE1fSE9VUl9HUk9VUF0pIHtcbiAgICAgICAgICAgIGlmIChob3VyID4gMTIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGFtcG06IHN0cmluZyA9IG1hdGNoW3RoaXMuQU1fUE1fSE9VUl9HUk9VUF1bMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChhbXBtID09PSAnYScpIHtcbiAgICAgICAgICAgICAgICBtZXJpZGllbSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSBob3VyID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYW1wbSA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgbWVyaWRpZW0gPSAxO1xuICAgICAgICAgICAgICAgIGlmIChob3VyICE9PSAxMikgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oSE9VUiwgaG91cik7XG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTUlOVVRFLCBtaW51dGUpO1xuXG4gICAgICAgIGlmIChtZXJpZGllbSA+PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1FUklESUVNLCBtZXJpZGllbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1FUklESUVNLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1FUklESUVNLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgZXh0cmFjdFNlY29uZENodW5rKHRleHQ6IHN0cmluZywgcmVzdWx0OiBQYXJzZWRSZXN1bHQpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGwgPSB0aGlzLkVORF9QQVRURVJOLmV4ZWModGV4dC5zdWJzdHJpbmcocmVzdWx0LmluZGV4ICsgcmVzdWx0LnRleHQubGVuZ3RoKSk7XG5cbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGF0dGVybiBcIllZLllZIC1YWFhYXCIgaXMgbW9yZSBsaWtlIHRpbWV6b25lIG9mZnNldFxuICAgICAgICBpZiAobWF0Y2hbMF0ubWF0Y2godGhpcy5PVEhFUl9QQVRURVJOU1sxXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGltZTogVGltZSB8IGZhbHNlID0gdGhpcy5nZXRUaW1lKG1hdGNoKTtcbiAgICAgICAgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBbaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBtZXJpZGllbV06IFRpbWUgPSB0aW1lO1xuXG4gICAgICAgIGlmICghcmVzdWx0LmVuZCkge1xuICAgICAgICAgICAgcmVzdWx0LmVuZCA9IG5ldyBQYXJzZWRDb21wb25lbnRzKHVuZGVmaW5lZCwgcmVzdWx0LnN0YXJ0LmRhdGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2Vjb25kID4gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lbmQuYXNzaWduKFNFQ09ORCwgc2Vjb25kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaWxsaXNlY29uZCA+IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQuZW5kLmFzc2lnbihNSUxMSVNFQ09ORCwgbWlsbGlzZWNvbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0gQU0gJiBQTVxuICAgICAgICBpZiAobWF0Y2hbdGhpcy5BTV9QTV9IT1VSX0dST1VQXSkge1xuXG4gICAgICAgICAgICBpZiAoaG91ciA+IDEyKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIGNvbnN0IGFtcG06IHN0cmluZyA9IG1hdGNoW3RoaXMuQU1fUE1fSE9VUl9HUk9VUF1bMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChhbXBtID09PSAnYScpIHtcbiAgICAgICAgICAgICAgICBtZXJpZGllbSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5lbmQuaXNDZXJ0YWluKERBWSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lbmQuaW1wbHkoREFZLCByZXN1bHQuZW5kLmdldChEQVkpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbXBtID09PSAncCcpIHtcbiAgICAgICAgICAgICAgICBtZXJpZGllbSA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXIgIT09IDEyKSBob3VyICs9IDEyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5zdGFydC5pc0NlcnRhaW4oTUVSSURJRU0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lcmlkaWVtID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNRVJJRElFTSwgMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGFydC5nZXQoSE9VUikgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKEhPVVIsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1FUklESUVNLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXJ0LmdldChIT1VSKSAhPT0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oSE9VUiwgcmVzdWx0LnN0YXJ0LmdldChIT1VSKSArIDEyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC50ZXh0ID0gcmVzdWx0LnRleHQgKyBtYXRjaFswXTtcbiAgICAgICAgcmVzdWx0LmVuZC5hc3NpZ24oSE9VUiwgaG91cik7XG4gICAgICAgIHJlc3VsdC5lbmQuYXNzaWduKE1JTlVURSwgbWludXRlKTtcbiAgICAgICAgaWYgKG1lcmlkaWVtID49IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5lbmQuYXNzaWduKE1FUklESUVNLCBtZXJpZGllbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydEF0UE06IGJvb2xlYW4gPSByZXN1bHQuc3RhcnQuaXNDZXJ0YWluKE1FUklESUVNKSAmJiByZXN1bHQuc3RhcnQuZ2V0KE1FUklESUVNKSA9PT0gMTtcbiAgICAgICAgICAgIGlmIChzdGFydEF0UE0gJiYgcmVzdWx0LnN0YXJ0LmdldChIT1VSKSA+IGhvdXIpIHtcbiAgICAgICAgICAgICAgICAvLyAxMHBtIC0gMSAoYW0pXG4gICAgICAgICAgICAgICAgcmVzdWx0LmVuZC5pbXBseShNRVJJRElFTSwgMCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaG91ciA+IDEyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVuZC5pbXBseShNRVJJRElFTSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LmVuZC5kYXRlKCkuZ2V0VGltZSgpIDwgcmVzdWx0LnN0YXJ0LmRhdGUoKS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lbmQuaW1wbHkoREFZLCByZXN1bHQuZW5kLmdldChEQVkpICsgMSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGltZShtYXRjaDogUmVnRXhwRXhlY0FycmF5KTogVGltZSB8IGZhbHNlIHtcbiAgICAgICAgbGV0IG1pbGxpc2Vjb25kOiBudW1iZXIgPSAtMTtcbiAgICAgICAgbGV0IHNlY29uZDogbnVtYmVyID0gLTE7XG4gICAgICAgIGxldCBob3VyOiBudW1iZXIgPSAwO1xuICAgICAgICBsZXQgbWludXRlOiBudW1iZXIgPSAwO1xuICAgICAgICBsZXQgbWVyaWRpZW06IG51bWJlciA9IC0xO1xuXG5cbiAgICAgICAgLy8gLS0tLS0gTWlsbGlzZWNvbmRcbiAgICAgICAgaWYgKG1hdGNoW3RoaXMuTUlMTElfU0VDT05EX0dST1VQXSkge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmQgPSBwYXJzZUludChtYXRjaFt0aGlzLk1JTExJX1NFQ09ORF9HUk9VUF0uc3Vic3RyKDAsIDMpLCAxMCk7XG4gICAgICAgICAgICBpZiAobWlsbGlzZWNvbmQgPj0gMTAwMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0gU2Vjb25kXG4gICAgICAgIGlmIChtYXRjaFt0aGlzLlNFQ09ORF9HUk9VUF0pIHtcbiAgICAgICAgICAgIHNlY29uZCA9IHBhcnNlSW50KG1hdGNoW3RoaXMuU0VDT05EX0dST1VQXSwgMTApO1xuICAgICAgICAgICAgaWYgKHNlY29uZCA+PSA2MCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0gSG91cnNcbiAgICAgICAgaWYgKG1hdGNoW3RoaXMuSE9VUl9HUk9VUF0udG9Mb3dlckNhc2UoKSA9PT0gJ25vb24nKSB7XG4gICAgICAgICAgICBtZXJpZGllbSA9IDE7XG4gICAgICAgICAgICBob3VyID0gMTI7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbdGhpcy5IT1VSX0dST1VQXS50b0xvd2VyQ2FzZSgpID09PSAnbWlkbmlnaHQnKSB7XG4gICAgICAgICAgICBtZXJpZGllbSA9IDA7XG4gICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvdXIgPSBwYXJzZUludChtYXRjaFt0aGlzLkhPVVJfR1JPVVBdLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLSBNaW51dGVzXG4gICAgICAgIGlmIChtYXRjaFt0aGlzLk1JTlVURV9HUk9VUF0pIHtcbiAgICAgICAgICAgIG1pbnV0ZSA9IHBhcnNlSW50KG1hdGNoW3RoaXMuTUlOVVRFX0dST1VQXSwgMTApO1xuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPiAxMDApIHtcbiAgICAgICAgICAgIG1pbnV0ZSA9IGhvdXIgJSAxMDA7XG4gICAgICAgICAgICBob3VyID0gTWF0aC5mbG9vcihob3VyIC8gMTAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaW51dGUgPj0gNjApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChob3VyID4gMjQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG91ciA+PSAxMikge1xuICAgICAgICAgICAgbWVyaWRpZW0gPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQsIG1lcmlkaWVtXTtcbiAgICB9XG59IiwiaW1wb3J0IFBhcnNlciBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHtQYXJzZWRSZXN1bHR9IGZyb20gJy4uLy4uL3Jlc3VsdCc7XG5pbXBvcnQge1BhcnNlT3B0aW9uc30gZnJvbSBcIi4uLy4uL2Nocm9ub1wiO1xuaW1wb3J0IHtEQVksIEhPVVIsIE1JTlVURSwgTU9OVEgsIFNFQ09ORCwgV0VFS0RBWSwgWUVBUn0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHtcbiAgICBleHRyYWN0RGF0ZVRpbWVVbml0RnJhZ21lbnRzLFxuICAgIEZyYWdtZW50TWFwLFxuICAgIEZyYWdtZW50TmFtZSxcbiAgICBUSU1FX1VOSVRfUEFUVEVSTixcbiAgICBUSU1FX1VOSVRfU1RSSUNUX1BBVFRFUk5cbn0gZnJvbSBcIi4uLy4uL3V0aWxzL0VOXCI7XG5pbXBvcnQgKiBhcyBtb21lbnQgZnJvbSBcIm1vbWVudFwiO1xuaW1wb3J0IHtNb21lbnR9IGZyb20gXCJtb21lbnRcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRU5UaW1lTGF0ZXJGb3JtYXRQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIHByaXZhdGUgUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cCgnJyArXG4gICAgICAgICcoXFxcXFd8XiknICtcbiAgICAgICAgJygnICsgVElNRV9VTklUX1BBVFRFUk4gKyAnKScgK1xuICAgICAgICAnKD86bGF0ZXJ8YWZ0ZXJ8ZnJvbSBub3d8aGVuY2Vmb3J0aHxmb3J3YXJkfG91dCkoPz0oPzpcXFxcV3wkKSknLCAnaScpO1xuXG4gICAgcHJpdmF0ZSBTVFJJQ1RfUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cCgnJyArXG4gICAgICAgICcoXFxcXFd8XiknICtcbiAgICAgICAgJygnICsgVElNRV9VTklUX1NUUklDVF9QQVRURVJOICsgJyknICtcbiAgICAgICAgJyg/OmxhdGVyfGZyb20gbm93KSg/PSg/OlxcXFxXfCQpKScsICdpJyk7XG5cbiAgICBwcml2YXRlIFRBRzogc3RyaW5nID0gJ0VOVGltZUxhdGVyRm9ybWF0UGFyc2VyJztcblxuICAgIHByaXZhdGUgT1RIRVJfUEFUVEVSTlM6IFJlZ0V4cFtdID0gW1xuICAgICAgICAvXFx3L1xuICAgIF07XG5cbiAgICBwYXR0ZXJuKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU3RyaWN0TW9kZSgpID8gdGhpcy5TVFJJQ1RfUEFUVEVSTiA6IHRoaXMuUEFUVEVSTjtcbiAgICB9XG5cbiAgICBleHRyYWN0KHRleHQ6IHN0cmluZywgcmVmOiBEYXRlLCBtYXRjaDogUmVnRXhwRXhlY0FycmF5LCBvcHQ6IFBhcnNlT3B0aW9ucyk6IFBhcnNlZFJlc3VsdCB8IG51bGwge1xuICAgICAgICBpZiAobWF0Y2guaW5kZXggPiAwICYmIHRleHRbbWF0Y2guaW5kZXggLSAxXS5tYXRjaCh0aGlzLk9USEVSX1BBVFRFUk5TWzBdKSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgY29uc3QgaW5kZXg6IG51bWJlciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFJlc3VsdCA9IG5ldyBQYXJzZWRSZXN1bHQoe1xuICAgICAgICAgICAgdGV4dDogbWF0Y2hbMF0uc3Vic3RyKG1hdGNoWzFdLmxlbmd0aCwgbWF0Y2hbMF0ubGVuZ3RoIC0gbWF0Y2hbMV0ubGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcmVmXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3VsdC50YWdzW3RoaXMuVEFHXSA9IHRydWU7XG5cbiAgICAgICAgY29uc3QgbW9tZW50UmVmOiBNb21lbnQgPSBtb21lbnQocmVmKTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnRzOiBGcmFnbWVudE1hcCA9IGV4dHJhY3REYXRlVGltZVVuaXRGcmFnbWVudHMobWF0Y2hbMl0pO1xuXG4gICAgICAgIChPYmplY3Qua2V5cyhmcmFnbWVudHMpIGFzIEZyYWdtZW50TmFtZVtdKS5mb3JFYWNoKChmcmFnbWVudDogRnJhZ21lbnROYW1lKSA9PiB7XG4gICAgICAgICAgICBtb21lbnRSZWYuYWRkKGZyYWdtZW50c1tmcmFnbWVudF0hLCBmcmFnbWVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICgoZnJhZ21lbnRzWydob3VyJ10gfHwgMCkgPiAwIHx8IChmcmFnbWVudHNbJ21pbnV0ZSddIHx8IDApID4gMCB8fCAoZnJhZ21lbnRzWydzZWNvbmQnXSB8fCAwKSA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oSE9VUiwgbW9tZW50UmVmLmhvdXIoKSk7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1JTlVURSwgbW9tZW50UmVmLm1pbnV0ZSgpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oU0VDT05ELCBtb21lbnRSZWYuc2Vjb25kKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChmcmFnbWVudHNbJ2QnXSB8fCAwKSA+IDAgfHwgKGZyYWdtZW50c1snbW9udGgnXSB8fCAwKSA+IDAgfHwgKGZyYWdtZW50c1sneWVhciddIHx8IDApID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihEQVksIG1vbWVudFJlZi5kYXRlKCkpO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihNT05USCwgbW9tZW50UmVmLm1vbnRoKCkgKyAxKTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oWUVBUiwgbW9tZW50UmVmLnllYXIoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoKGZyYWdtZW50c1snd2VlayddIHx8IDApID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShXRUVLREFZLCBtb21lbnRSZWYuZGF5KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoREFZLCBtb21lbnRSZWYuZGF0ZSgpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNT05USCwgbW9tZW50UmVmLm1vbnRoKCkgKyAxKTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShZRUFSLCBtb21lbnRSZWYueWVhcigpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IFBhcnNlciBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHtQYXJzZWRSZXN1bHR9IGZyb20gXCIuLi8uLi9yZXN1bHRcIjtcbmltcG9ydCB7UGFyc2VPcHRpb25zfSBmcm9tIFwiLi4vLi4vY2hyb25vXCI7XG5pbXBvcnQge1dFRUtEQVlfT0ZGU0VUfSBmcm9tICcuLi8uLi91dGlscy9FTic7XG5pbXBvcnQge01vZGlmaWVyLCB1cGRhdGVQYXJzZWRDb21wb25lbnR9IGZyb20gJy4uLy4uL3V0aWxzL2dlbmVyYWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFTldlZWtkYXlQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIHByaXZhdGUgUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cCgnKFxcXFxXfF4pJyArXG4gICAgICAgICcoPzooPzpcXFxcLHxcXFxcKHxcXFxc77yIKVxcXFxzKik/JyArXG4gICAgICAgICcoPzpvblxcXFxzKj8pPycgK1xuICAgICAgICAnKD86KHRoaXN8bGFzdHxwYXN0fG5leHQpXFxcXHMqKT8nICtcbiAgICAgICAgJygnICsgT2JqZWN0LmtleXMoV0VFS0RBWV9PRkZTRVQpLmpvaW4oJ3wnKSArICcpJyArXG4gICAgICAgICcoPzpcXFxccyooPzpcXFxcLHxcXFxcKXxcXFxc77yJKSk/JyArXG4gICAgICAgICcoPzpcXFxccyoodGhpc3xsYXN0fHBhc3R8bmV4dClcXFxccyp3ZWVrKT8nICtcbiAgICAgICAgJyg/PVxcXFxXfCQpJywgJ2knKTtcblxuICAgIHByaXZhdGUgUFJFRklYX0dST1VQOiBudW1iZXIgPSAyO1xuICAgIHByaXZhdGUgV0VFS0RBWV9HUk9VUDogbnVtYmVyID0gMztcbiAgICBwcml2YXRlIFBPU1RGSVhfR1JPVVA6IG51bWJlciA9IDQ7XG5cbiAgICBwcml2YXRlIFRBRzogc3RyaW5nID0gJ0VOV2Vla2RheVBhcnNlcic7XG5cbiAgICBwYXR0ZXJuKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiB0aGlzLlBBVFRFUk47XG4gICAgfVxuXG4gICAgZXh0cmFjdCh0ZXh0OiBzdHJpbmcsIHJlZjogRGF0ZSwgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSwgb3B0OiBQYXJzZU9wdGlvbnMpOiBQYXJzZWRSZXN1bHQgfCBudWxsIHtcbiAgICAgICAgY29uc3QgaW5kZXg6IG51bWJlciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICBjb25zdCBtYXRjaGVkVGV4dDogc3RyaW5nID0gbWF0Y2hbMF0uc3Vic3RyKG1hdGNoWzFdLmxlbmd0aCwgbWF0Y2hbMF0ubGVuZ3RoIC0gbWF0Y2hbMV0ubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBQYXJzZWRSZXN1bHQgPSBuZXcgUGFyc2VkUmVzdWx0KHtcbiAgICAgICAgICAgIHRleHQ6IG1hdGNoZWRUZXh0LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByZWYsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG9mZnNldDogbnVtYmVyIHwgdW5kZWZpbmVkID0gV0VFS0RBWV9PRkZTRVRbbWF0Y2hbdGhpcy5XRUVLREFZX0dST1VQXS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBjb25zdCBwcmVmaXg6IHN0cmluZyA9IG1hdGNoW3RoaXMuUFJFRklYX0dST1VQXTtcbiAgICAgICAgY29uc3QgcG9zdGZpeDogc3RyaW5nID0gbWF0Y2hbdGhpcy5QT1NURklYX0dST1VQXTtcbiAgICAgICAgY29uc3Qgbm9ybTogc3RyaW5nID0gKHByZWZpeCB8fCBwb3N0Zml4IHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGxldCBtb2RpZmllcjogTW9kaWZpZXIgPSBNb2RpZmllci5VTktOT1dOO1xuICAgICAgICBpZiAobm9ybSA9PT0gJ3RoaXMnKSB7XG4gICAgICAgICAgICBtb2RpZmllciA9IE1vZGlmaWVyLlRISVM7XG4gICAgICAgIH0gZWxzZSBpZiAobm9ybSA9PT0gJ2xhc3QnIHx8IG5vcm0gPT09ICdwYXN0Jykge1xuICAgICAgICAgICAgbW9kaWZpZXIgPSBNb2RpZmllci5MQVNUO1xuICAgICAgICB9IGVsc2UgaWYgKG5vcm0gPT09ICduZXh0Jykge1xuICAgICAgICAgICAgbW9kaWZpZXIgPSBNb2RpZmllci5ORVhUO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcblxuICAgICAgICB1cGRhdGVQYXJzZWRDb21wb25lbnQocmVzdWx0LCByZWYsIG9mZnNldCwgbW9kaWZpZXIpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSIsImltcG9ydCAqIGFzIG1vbWVudCBmcm9tIFwibW9tZW50XCI7XG5pbXBvcnQge01vbWVudH0gZnJvbSBcIm1vbWVudFwiO1xuaW1wb3J0IFBhcnNlciBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHtQYXJzZWRSZXN1bHR9IGZyb20gJy4uLy4uL3Jlc3VsdCc7XG5pbXBvcnQge1BhcnNlT3B0aW9uc30gZnJvbSBcIi4uLy4uL2Nocm9ub1wiO1xuaW1wb3J0IHtEQVksIEhPVVIsIE1FUklESUVNLCBNSUxMSVNFQ09ORCwgTUlOVVRFLCBNT05USCwgU0VDT05ELCBZRUFSfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cbi8qXG4gIFZhbGlkIHBhdHRlcm5zOlxuICAtIGVzdGEgbWHDsWFuYSAtPiB0b2RheSBpbiB0aGUgbW9ybmluZ1xuICAtIGVzdGEgdGFyZGUgLT4gdG9kYXkgaW4gdGhlIGFmdGVybm9vbi9ldmVuaW5nXG4gIC0gZXN0YSBub2NoZSAtPiB0b25pZ2h0XG4gIC0gYXllciBwb3IgbGEgbWHDsWFuYSAtPiB5ZXN0ZXJkYXkgaW4gdGhlIG1vcm5pbmdcbiAgLSBheWVyIHBvciBsYSB0YXJkZSAtPiB5ZXN0ZXJkYXkgaW4gdGhlIGFmdGVybm9vbi9ldmVuaW5nXG4gIC0gYXllciBwb3IgbGEgbm9jaGUgLT4geWVzdGVyZGF5IGF0IG5pZ2h0XG4gIC0gbWHDsWFuYSBwb3IgbGEgbWHDsWFuYSAtPiB0b21vcnJvdyBpbiB0aGUgbW9ybmluZ1xuICAtIG1hw7FhbmEgcG9yIGxhIHRhcmRlIC0+IHRvbW9ycm93IGluIHRoZSBhZnRlcm5vb24vZXZlbmluZ1xuICAtIG1hw7FhbmEgcG9yIGxhIG5vY2hlIC0+IHRvbW9ycm93IGF0IG5pZ2h0XG4gIC0gYW5vY2hlIC0+IHRvbW9ycm93IGF0IG5pZ2h0XG4gIC0gaG95IC0+IHRvZGF5XG4gIC0gYXllciAtPiB5ZXN0ZXJkYXlcbiAgLSBtYcOxYW5hIC0+IHRvbW9ycm93XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRVNDYXN1YWxEYXRlUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBwcml2YXRlIFBBVFRFUk46IFJlZ0V4cCA9IC8oXFxXfF4pKGFob3JhfGVzdGFcXHMqKG1hw7FhbmF8dGFyZGV8bm9jaGUpfChheWVyfG1hw7FhbmEpXFxzKnBvclxccypsYVxccyoobWHDsWFuYXx0YXJkZXxub2NoZSl8aG95fG1hw7FhbmF8YXllcnxhbm9jaGUpKD89XFxXfCQpL2k7XG5cbiAgICBwcml2YXRlIE9USEVSX1BBVFRFUk5TOiBSZWdFeHBbXSA9IFtcbiAgICAgICAgL3BvclxccypsYS8sXG4gICAgICAgIC9haG9yYS9cbiAgICBdO1xuXG4gICAgcHJpdmF0ZSBUQUc6IHN0cmluZyA9ICdFU0Nhc3VhbERhdGVQYXJzZXInO1xuXG4gICAgcGF0dGVybigpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gdGhpcy5QQVRURVJOO1xuICAgIH1cblxuICAgIGV4dHJhY3QodGV4dDogc3RyaW5nLCByZWY6IERhdGUsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGluZGV4OiBudW1iZXIgPSBtYXRjaC5pbmRleCArIG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBQYXJzZWRSZXN1bHQgPSBuZXcgUGFyc2VkUmVzdWx0KHtcbiAgICAgICAgICAgIHRleHQ6IG1hdGNoWzBdLnN1YnN0cihtYXRjaFsxXS5sZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVmTW9tZW50OiBNb21lbnQgPSBtb21lbnQocmVmKTtcbiAgICAgICAgY29uc3Qgc3RhcnRNb21lbnQ6IE1vbWVudCA9IHJlZk1vbWVudC5jbG9uZSgpO1xuICAgICAgICBjb25zdCBtYXRjaGVkVGV4dCA9IHJlc3VsdC50ZXh0LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWRUZXh0ID09PSAnbWHDsWFuYScpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIG5vdCBcIlRvbW9ycm93XCIgb24gbGF0ZSBuaWdodFxuICAgICAgICAgICAgaWYgKHJlZk1vbWVudC5ob3VyKCkgPiAxKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRNb21lbnQuYWRkKDEsICdkYXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVkVGV4dCA9PT0gJ2F5ZXInKSB7XG4gICAgICAgICAgICBzdGFydE1vbWVudC5hZGQoLTEsICdkYXknKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVkVGV4dCA9PT0gJ2Fub2NoZScpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShIT1VSLCAwKTtcbiAgICAgICAgICAgIGlmIChyZWZNb21lbnQuaG91cigpID4gNikge1xuICAgICAgICAgICAgICAgIHN0YXJ0TW9tZW50LmFkZCgtMSwgJ2RheScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZWRUZXh0Lm1hdGNoKFwiZXN0YVwiKSkge1xuICAgICAgICAgICAgY29uc3Qgc2Vjb25kTWF0Y2g6IHN0cmluZyA9IG1hdGNoWzNdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoc2Vjb25kTWF0Y2ggPT09IFwidGFyZGVcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShIT1VSLCAxOCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlY29uZE1hdGNoID09PSBcIm1hw7FhbmFcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShIT1VSLCA2KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2Vjb25kTWF0Y2ggPT09IFwibm9jaGVcIikge1xuICAgICAgICAgICAgICAgIC8vIE5vcm1hbGx5IG1lYW5zIHRoaXMgY29taW5nIG1pZG5pZ2h0XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KEhPVVIsIDIyKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTUVSSURJRU0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZWRUZXh0Lm1hdGNoKHRoaXMuT1RIRVJfUEFUVEVSTlNbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdE1hdGNoOiBzdHJpbmcgPSBtYXRjaFs0XS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGZpcnN0TWF0Y2ggPT09ICdheWVyJykge1xuICAgICAgICAgICAgICAgIHN0YXJ0TW9tZW50LmFkZCgtMSwgJ2RheScpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmaXJzdE1hdGNoID09PSAnbWHDsWFuYScpIHtcbiAgICAgICAgICAgICAgICBzdGFydE1vbWVudC5hZGQoMSwgJ2RheScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2Vjb25kTWF0Y2g6IHN0cmluZyA9IG1hdGNoWzVdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoc2Vjb25kTWF0Y2ggPT09IFwidGFyZGVcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShIT1VSLCAxOCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlY29uZE1hdGNoID09PSBcIm1hw7FhbmFcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShIT1VSLCA5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2Vjb25kTWF0Y2ggPT09IFwibm9jaGVcIikge1xuICAgICAgICAgICAgICAgIC8vIE5vcm1hbGx5IG1lYW5zIHRoaXMgY29taW5nIG1pZG5pZ2h0XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KEhPVVIsIDIyKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTUVSSURJRU0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZWRUZXh0Lm1hdGNoKHRoaXMuT1RIRVJfUEFUVEVSTlNbMV0pKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoSE9VUiwgcmVmTW9tZW50LmhvdXIoKSk7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTUlOVVRFLCByZWZNb21lbnQubWludXRlKCkpO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KFNFQ09ORCwgcmVmTW9tZW50LnNlY29uZCgpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNSUxMSVNFQ09ORCwgcmVmTW9tZW50Lm1pbGxpc2Vjb25kKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihEQVksIHN0YXJ0TW9tZW50LmRhdGUoKSk7XG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTU9OVEgsIHN0YXJ0TW9tZW50Lm1vbnRoKCkgKyAxKTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCBzdGFydE1vbWVudC55ZWFyKCkpO1xuICAgICAgICByZXN1bHQudGFnc1t0aGlzLlRBR10gPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSIsImltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tICcuLi8uLi9yZXN1bHQnO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jaHJvbm9cIjtcbmltcG9ydCAqIGFzIG1vbWVudCBmcm9tIFwibW9tZW50XCI7XG5pbXBvcnQge1VuaXRPZlRpbWV9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCB7ZGVhZGxpbmVDYWxjdWxhdGlvbnN9IGZyb20gXCIuLi8uLi91dGlscy9nZW5lcmFsXCI7XG5pbXBvcnQge21hdGNoTnVtYmVyLCBtYXRjaFVuaXR9IGZyb20gXCIuLi8uLi91dGlscy9FU1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFU0RlYWRsaW5lRm9ybWF0UGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBwcml2YXRlIFBBVFRFUk46IFJlZ0V4cCA9IC8oXFxXfF4pKGRlbnRyb1xccypkZXxlbilcXHMqKFswLTldK3xtZWRpW29hXXx1bmE/KVxccyoobWludXRvcz98aG9yYXM/fGRbacOtXWFzPylcXHMqKD89KD86XFxXfCQpKS9pO1xuXG4gICAgcHJpdmF0ZSBOVU1fTUFUQ0g6IG51bWJlciA9IDM7XG4gICAgcHJpdmF0ZSBVTklUX01BVENIOiBudW1iZXIgPSA0O1xuXG4gICAgcHJpdmF0ZSBUQUc6IHN0cmluZyA9ICdFU0RlYWRsaW5lRm9ybWF0UGFyc2VyJztcblxuICAgIHBhdHRlcm4oKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuUEFUVEVSTjtcbiAgICB9XG5cbiAgICBleHRyYWN0KHRleHQ6IHN0cmluZywgcmVmOiBEYXRlLCBtYXRjaDogUmVnRXhwRXhlY0FycmF5LCBvcHQ6IFBhcnNlT3B0aW9ucyk6IFBhcnNlZFJlc3VsdCB8IG51bGwge1xuICAgICAgICBjb25zdCBpbmRleDogbnVtYmVyID0gbWF0Y2guaW5kZXggKyBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogUGFyc2VkUmVzdWx0ID0gbmV3IFBhcnNlZFJlc3VsdCh7XG4gICAgICAgICAgICB0ZXh0OiBtYXRjaFswXS5zdWJzdHIobWF0Y2hbMV0ubGVuZ3RoLCBtYXRjaFswXS5sZW5ndGggLSBtYXRjaFsxXS5sZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCBudW06IG51bWJlciA9IG1hdGNoTnVtYmVyKG1hdGNoW3RoaXMuTlVNX01BVENIXS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgY29uc3QgbWF0Y2hlZFVuaXQ6IFVuaXRPZlRpbWUgfCB1bmRlZmluZWQgPSBtYXRjaFVuaXQobWF0Y2hbdGhpcy5VTklUX01BVENIXS50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgICBpZiAobnVtICYmIG1hdGNoZWRVbml0ICYmIGRlYWRsaW5lQ2FsY3VsYXRpb25zKG51bSwgbWF0Y2hlZFVuaXQsIHJlc3VsdCwgbW9tZW50KHJlZikpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufSIsImltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tICcuLi8uLi9yZXN1bHQnO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jaHJvbm9cIjtcbmltcG9ydCB7TU9OVEhfT0ZGU0VULCBXRUVLREFZX09GRlNFVCwgeWVhckNhbGN1bGF0aW9ufSBmcm9tIFwiLi4vLi4vdXRpbHMvRVNcIjtcbmltcG9ydCB7REFZLCBNT05USCwgV0VFS0RBWSwgWUVBUn0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHtnZXRBcHByb3ByaWF0ZVllYXJ9IGZyb20gXCIuLi8uLi91dGlscy9nZW5lcmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVTTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBwcml2YXRlIFBBVFRFUk46IFJlZ0V4cCA9IG5ldyBSZWdFeHAoJyhcXFxcV3xeKScgK1xuICAgICAgICAnKD86KERvbWluZ298THVuZXN8TWFydGVzfE1pw6lyY29sZXN8TWllcmNvbGVzfEp1ZXZlc3xWaWVybmVzfFPDoWJhZG98U2FiYWRvfERvbXxMdW58TWFyfE1pZXxKdWV8VmllfFNhYilcXFxccyosP1xcXFxzKik/JyArXG4gICAgICAgICcoWzAtOV17MSwyfSkoPzrCunzCqnzCsCk/JyArXG4gICAgICAgICcoPzpcXFxccyooPzpkZXNkZXxkZXxcXFxcLXxcXFxc4oCTfGFsP3xoYXN0YXxcXFxccylcXFxccyooWzAtOV17MSwyfSkoPzrCunzCqnzCsCk/KT9cXFxccyooPzpkZSk/XFxcXHMqJyArXG4gICAgICAgICcoRW5lKD86cm98XFxcXC4pP3xGZWIoPzpyZXJvfFxcXFwuKT98TWFyKD86em98XFxcXC4pP3xBYnIoPzppbHxcXFxcLik/fE1heSg/Om98XFxcXC4pP3xKdW4oPzppb3xcXFxcLik/fEp1bCg/OmlvfFxcXFwuKT98QWdvKD86c3RvfFxcXFwuKT98U2VwKD86dGllbWJyZXxcXFxcLik/fFNldCg/OmllbWJyZXxcXFxcLik/fE9jdCg/OnVicmV8XFxcXC4pP3xOb3YoPzppZW1icmV8XFxcXC4pP3xEaWMoPzppZW1icmV8XFxcXC4pPyknICtcbiAgICAgICAgJyg/OlxcXFxzKig/OmRlbD8pPyhcXFxccypbMC05XXsxLDR9KD8hW15cXFxcc11cXFxcZCkpKFxcXFxzKlthZF1cXFxcLj9cXFxccypjXFxcXC4/fGFcXFxcLj9cXFxccypkXFxcXC4/KT8pPycgK1xuICAgICAgICAnKD89XFxcXFd8JCknLCAnaSdcbiAgICApO1xuXG4gICAgcHJpdmF0ZSBXRUVLREFZX0dST1VQOiBudW1iZXIgPSAyO1xuICAgIHByaXZhdGUgREFURV9HUk9VUDogbnVtYmVyID0gMztcbiAgICBwcml2YXRlIERBVEVfVE9fR1JPVVA6IG51bWJlciA9IDQ7XG4gICAgcHJpdmF0ZSBNT05USF9OQU1FX0dST1VQOiBudW1iZXIgPSA1O1xuICAgIHByaXZhdGUgWUVBUl9HUk9VUDogbnVtYmVyID0gNjtcbiAgICBwcml2YXRlIFlFQVJfQkVfR1JPVVA6IG51bWJlciA9IDc7XG5cbiAgICBwcml2YXRlIFRBRzogc3RyaW5nID0gJ0VTTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyJztcblxuICAgIHBhdHRlcm4oKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuUEFUVEVSTjtcbiAgICB9XG5cbiAgICBleHRyYWN0KHRleHQ6IHN0cmluZywgcmVmOiBEYXRlLCBtYXRjaDogUmVnRXhwRXhlY0FycmF5LCBvcHQ6IFBhcnNlT3B0aW9ucyk6IFBhcnNlZFJlc3VsdCB8IG51bGwge1xuICAgICAgICBjb25zdCBpbmRleDogbnVtYmVyID0gbWF0Y2guaW5kZXggKyBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogUGFyc2VkUmVzdWx0ID0gbmV3IFBhcnNlZFJlc3VsdCh7XG4gICAgICAgICAgICB0ZXh0OiBtYXRjaFswXS5zdWJzdHIobWF0Y2hbMV0ubGVuZ3RoLCBtYXRjaFswXS5sZW5ndGggLSBtYXRjaFsxXS5sZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCBtb250aDogbnVtYmVyID0gTU9OVEhfT0ZGU0VUW21hdGNoW3RoaXMuTU9OVEhfTkFNRV9HUk9VUF0udG9Mb3dlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKCEobW9udGggfHwgbW9udGggPT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRheTogbnVtYmVyID0gcGFyc2VJbnQobWF0Y2hbdGhpcy5EQVRFX0dST1VQXSwgMTApO1xuXG4gICAgICAgIGlmICghZGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oREFZLCBkYXkpO1xuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1PTlRILCBtb250aCk7XG5cbiAgICAgICAgbGV0IHllYXI6IG51bWJlciB8IG51bGwgPSB5ZWFyQ2FsY3VsYXRpb24obWF0Y2hbdGhpcy5ZRUFSX0dST1VQXSwgbWF0Y2hbdGhpcy5ZRUFSX0JFX0dST1VQXSk7XG5cbiAgICAgICAgaWYgKHllYXIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oWUVBUiwgeWVhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRBcHByb3ByaWF0ZVllYXIocmVzdWx0LnN0YXJ0LCByZWYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2Vla2RheSBjb21wb25lbnRcbiAgICAgICAgaWYgKG1hdGNoW3RoaXMuV0VFS0RBWV9HUk9VUF0pIHtcbiAgICAgICAgICAgIGNvbnN0IHdlZWtkYXk6IG51bWJlciA9IFdFRUtEQVlfT0ZGU0VUW21hdGNoW3RoaXMuV0VFS0RBWV9HUk9VUF0udG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICBpZiAod2Vla2RheSB8fCB3ZWVrZGF5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihXRUVLREFZLCB3ZWVrZGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRleHQgY2FuIGJlICdyYW5nZScgdmFsdWUuIFN1Y2ggYXMgJzEyIC0gMTMgSmFudWFyeSAyMDEyJ1xuICAgICAgICBpZiAobWF0Y2hbdGhpcy5EQVRFX1RPX0dST1VQXSkge1xuICAgICAgICAgICAgY29uc3QgZW5kRGF0ZSA9IHBhcnNlSW50KG1hdGNoW3RoaXMuREFURV9UT19HUk9VUF0sIDEwKTtcblxuICAgICAgICAgICAgaWYgKGVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZW5kID0gcmVzdWx0LnN0YXJ0LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVuZC5hc3NpZ24oREFZLCBlbmREYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSIsIi8qXG4gICAgRGF0ZSBmb3JtYXQgd2l0aCBzbGFzaCBcIi9cIiAoYWxzbyBcIi1cIiBhbmQgXCIuXCIpIGJldHdlZW4gbnVtYmVyc1xuICAgIC0gTWFydGVzIDMvMTEvMjAxNVxuICAgIC0gMy8xMS8yMDE1XG4gICAgLSAzLzExXG4qL1xuXG5pbXBvcnQgUGFyc2VyIGZyb20gJy4uL3BhcnNlcic7XG5pbXBvcnQge1BhcnNlZFJlc3VsdH0gZnJvbSAnLi4vLi4vcmVzdWx0JztcbmltcG9ydCB7UGFyc2VPcHRpb25zfSBmcm9tIFwiLi4vLi4vY2hyb25vXCI7XG5pbXBvcnQge0RBWSwgTU9OVEgsIFdFRUtEQVksIFlFQVJ9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCB7V0VFS0RBWV9PRkZTRVR9IGZyb20gXCIuLi8uLi91dGlscy9FU1wiO1xuaW1wb3J0IHtjaGVja01vbnRoRGF5c1ZhbGlkfSBmcm9tIFwiLi4vLi4vdXRpbHMvZ2VuZXJhbFwiO1xuaW1wb3J0ICogYXMgbW9tZW50IGZyb20gJ21vbWVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVTU2xhc2hEYXRlRm9ybWF0UGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBwcml2YXRlIFBBVFRFUk46IFJlZ0V4cCA9IG5ldyBSZWdFeHAoJyhcXFxcV3xeKScgK1xuICAgICAgICAnKD86JyArXG4gICAgICAgICcoKD86ZG9taW5nb3xkb218bHVuZXN8bHVufG1hcnRlc3xtYXJ8bWlbw6llXXJjb2xlc3xtaWV8anVldmVzfGp1ZXx2aWVybmVzfHZpZXxzW8OhYV1iYWRvfHNhYikpJyArXG4gICAgICAgICdcXFxccypcXFxcLD9cXFxccyonICtcbiAgICAgICAgJyk/JyArXG4gICAgICAgICcoWzAtMV17MCwxfVswLTldezF9KVtcXFxcL1xcXFwuXFxcXC1dKFswLTNdezAsMX1bMC05XXsxfSknICtcbiAgICAgICAgJyg/OicgK1xuICAgICAgICAnW1xcXFwvXFxcXC5cXFxcLV0nICtcbiAgICAgICAgJyhbMC05XXs0fVxccypcXCw/XFxzKnxbMC05XXsyfVxccypcXCw/XFxzKiknICtcbiAgICAgICAgJyk/JyArXG4gICAgICAgICcoXFxcXFd8JCknLCAnaScpO1xuXG4gICAgcHJpdmF0ZSBPUEVOSU5HX0dST1VQOiBudW1iZXIgPSAxO1xuICAgIHByaXZhdGUgRU5ESU5HX0dST1VQOiBudW1iZXIgPSA2O1xuXG4gICAgcHJpdmF0ZSBXRUVLREFZX0dST1VQOiBudW1iZXIgPSAyO1xuICAgIHByaXZhdGUgTU9OVEhfR1JPVVA6IG51bWJlciA9IDQ7XG4gICAgcHJpdmF0ZSBEQVlfR1JPVVA6IG51bWJlciA9IDM7XG4gICAgcHJpdmF0ZSBZRUFSX0dST1VQOiBudW1iZXIgPSA1O1xuXG4gICAgcHJpdmF0ZSBUQUc6IHN0cmluZyA9ICdFU1NsYXNoRGF0ZUZvcm1hdFBhcnNlcic7XG5cbiAgICBwcml2YXRlIE9USEVSX1BBVFRFUk5TOiBSZWdFeHBbXSA9IFtcbiAgICAgICAgL15cXGRcXC5cXGQkLyxcbiAgICAgICAgL15cXGRcXC5cXGR7MSwyfVxcLlxcZHsxLDJ9JC9cbiAgICBdO1xuXG4gICAgcGF0dGVybigpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gdGhpcy5QQVRURVJOO1xuICAgIH1cblxuICAgIGV4dHJhY3QodGV4dDogc3RyaW5nLCByZWY6IERhdGUsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0IHwgbnVsbCB7XG4gICAgICAgIGlmIChtYXRjaFt0aGlzLk9QRU5JTkdfR1JPVVBdID09ICcvJyB8fCBtYXRjaFt0aGlzLkVORElOR19HUk9VUF0gPT0gJy8nKSB7XG4gICAgICAgICAgICAvLyBMb25nIHNraXAsIGlmIHRoZXJlIGlzIHNvbWUgb3ZlcmxhcHBpbmcgbGlrZTpcbiAgICAgICAgICAgIC8vIFhYWy9ZWS9aWl1cbiAgICAgICAgICAgIC8vIFtYWC9ZWS9dWlpcbiAgICAgICAgICAgIG1hdGNoLmluZGV4ICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW5kZXg6IG51bWJlciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFJlc3VsdCA9IG5ldyBQYXJzZWRSZXN1bHQoe1xuICAgICAgICAgICAgdGV4dDogbWF0Y2hbMF0uc3Vic3RyKG1hdGNoW3RoaXMuT1BFTklOR19HUk9VUF0ubGVuZ3RoLCBtYXRjaFswXS5sZW5ndGggLSBtYXRjaFt0aGlzLkVORElOR19HUk9VUF0ubGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcmVmXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3VsdC50YWdzW3RoaXMuVEFHXSA9IHRydWU7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRUZXh0OiBzdHJpbmcgPSByZXN1bHQudGV4dC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmIChtYXRjaGVkVGV4dC5tYXRjaCh0aGlzLk9USEVSX1BBVFRFUk5TWzBdKSB8fCBtYXRjaGVkVGV4dC5tYXRjaCh0aGlzLk9USEVSX1BBVFRFUk5TWzFdKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNTS9kZCAtPiBPS1xuICAgICAgICAvLyBNTS5kZCAtPiBOR1xuICAgICAgICBpZiAoIW1hdGNoW3RoaXMuWUVBUl9HUk9VUF0gJiYgbWF0Y2hbMF0uaW5kZXhPZignLycpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgeWVhcjogbnVtYmVyID0gbWF0Y2hbdGhpcy5ZRUFSX0dST1VQXSA/IHBhcnNlSW50KG1hdGNoW3RoaXMuWUVBUl9HUk9VUF0sIDEwKSA6IG1vbWVudChyZWYpLnllYXIoKTtcbiAgICAgICAgbGV0IG1vbnRoOiBudW1iZXIgPSBwYXJzZUludChtYXRjaFt0aGlzLk1PTlRIX0dST1VQXSwgMTApO1xuICAgICAgICBsZXQgZGF5OiBudW1iZXIgPSBwYXJzZUludChtYXRjaFt0aGlzLkRBWV9HUk9VUF0sIDEwKTtcblxuICAgICAgICBpZiAobW9udGggPCAxIHx8IGRheSA8IDEgfHwgZGF5ID4gMzEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeWVhciA8IDEwMCkge1xuICAgICAgICAgICAgaWYgKHllYXIgPiA1MCkge1xuICAgICAgICAgICAgICAgIHllYXIgPSB5ZWFyICsgMTkwMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeWVhciA9IHllYXIgKyAyMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vbnRoID4gMTIpIHtcbiAgICAgICAgICAgIGlmIChtb250aCA8PSAzMSAmJiBkYXkgPD0gMTIgJiYgY2hlY2tNb250aERheXNWYWxpZChtb250aCwgZGF5LCB5ZWFyKSkge1xuICAgICAgICAgICAgICAgIFttb250aCwgZGF5XSA9IFtkYXksIG1vbnRoXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKERBWSwgZGF5KTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihNT05USCwgbW9udGgpO1xuICAgICAgICBpZiAobWF0Y2hbdGhpcy5ZRUFSX0dST1VQXSkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCB5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShZRUFSLCB5ZWFyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaFt0aGlzLldFRUtEQVlfR1JPVVBdKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKFdFRUtEQVksIFdFRUtEQVlfT0ZGU0VUW21hdGNoW3RoaXMuV0VFS0RBWV9HUk9VUF0udG9Mb3dlckNhc2UoKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59IiwiaW1wb3J0IFBhcnNlciBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHtQYXJzZWRSZXN1bHR9IGZyb20gJy4uLy4uL3Jlc3VsdCc7XG5pbXBvcnQge1BhcnNlT3B0aW9uc30gZnJvbSBcIi4uLy4uL2Nocm9ub1wiO1xuaW1wb3J0IHtEQVksIEhPVVIsIE1JTlVURSwgTU9OVEgsIFVuaXRPZlRpbWUsIFdFRUssIFdFRUtEQVksIFlFQVJ9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCB7bWF0Y2hOdW1iZXIsIG1hdGNoVW5pdH0gZnJvbSBcIi4uLy4uL3V0aWxzL0VTXCI7XG5pbXBvcnQgKiBhcyBtb21lbnQgZnJvbSBcIm1vbWVudFwiO1xuaW1wb3J0IHtNb21lbnR9IGZyb20gXCJtb21lbnRcIjtcblxuZW51bSBNb2RlIHtcbiAgICBOT05FLFxuICAgIFRJTUUsXG4gICAgV0VFSyxcbiAgICBEQVRFXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVTVGltZUFnb0Zvcm1hdFBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgcHJpdmF0ZSBQQVRURVJOOiBSZWdFeHAgPSAvKFxcV3xeKWhhY2VcXHMqKFswLTldK3xtZWRpW29hXXx1bmE/KVxccyoobWludXRvcz98aG9yYXM/fHNlbWFuYXM/fGRbacOtXWFzP3xtZXMoZXMpP3xhw7Fvcz8pKD89KD86XFxXfCQpKS9pO1xuXG4gICAgcHJpdmF0ZSBUQUc6IHN0cmluZyA9ICdFU1RpbWVBZ29Gb3JtYXRQYXJzZXInO1xuXG4gICAgcHJpdmF0ZSBPVEhFUl9QQVRURVJOUzogUmVnRXhwW10gPSBbXG4gICAgICAgIC9cXHcvXG4gICAgXTtcblxuICAgIHByaXZhdGUgTlVNX01BVENIOiBudW1iZXIgPSAyO1xuICAgIHByaXZhdGUgVU5JVF9NQVRDSDogbnVtYmVyID0gMztcblxuICAgIHBhdHRlcm4oKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuUEFUVEVSTjtcbiAgICB9XG5cbiAgICBleHRyYWN0KHRleHQ6IHN0cmluZywgcmVmOiBEYXRlLCBtYXRjaDogUmVnRXhwRXhlY0FycmF5LCBvcHQ6IFBhcnNlT3B0aW9ucyk6IFBhcnNlZFJlc3VsdCB8IG51bGwge1xuICAgICAgICBpZiAobWF0Y2guaW5kZXggPiAwICYmIHRleHRbbWF0Y2guaW5kZXggLSAxXS5tYXRjaCh0aGlzLk9USEVSX1BBVFRFUk5TWzBdKSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgY29uc3QgaW5kZXg6IG51bWJlciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFJlc3VsdCA9IG5ldyBQYXJzZWRSZXN1bHQoe1xuICAgICAgICAgICAgdGV4dDogbWF0Y2hbMF0uc3Vic3RyKG1hdGNoWzFdLmxlbmd0aCwgbWF0Y2hbMF0ubGVuZ3RoIC0gbWF0Y2hbMV0ubGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcmVmXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3VsdC50YWdzW3RoaXMuVEFHXSA9IHRydWU7XG5cbiAgICAgICAgY29uc3QgbnVtOiBudW1iZXIgPSBtYXRjaE51bWJlcihtYXRjaFt0aGlzLk5VTV9NQVRDSF0pO1xuICAgICAgICBjb25zdCBtYXRjaGVkVW5pdDogVW5pdE9mVGltZSB8IHVuZGVmaW5lZCA9IG1hdGNoVW5pdChtYXRjaFt0aGlzLlVOSVRfTUFUQ0hdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBsZXQgbW9kZTogTW9kZSA9IE1vZGUuTk9ORTtcbiAgICAgICAgY29uc3QgbW9tZW50UmVmOiBNb21lbnQgPSBtb21lbnQocmVmKTtcblxuICAgICAgICBzd2l0Y2ggKG1hdGNoZWRVbml0KSB7XG4gICAgICAgICAgICBjYXNlIEhPVVI6XG4gICAgICAgICAgICAgICAgbW9tZW50UmVmLmFkZCgtbnVtLCAnaG91cicpO1xuICAgICAgICAgICAgICAgIG1vZGUgPSBNb2RlLlRJTUU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1JTlVURTpcbiAgICAgICAgICAgICAgICBtb21lbnRSZWYuYWRkKC1udW0sICdtaW51dGUnKTtcbiAgICAgICAgICAgICAgICBtb2RlID0gTW9kZS5USU1FO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXRUVLOlxuICAgICAgICAgICAgICAgIG1vbWVudFJlZi5hZGQoLW51bSwgJ3dlZWsnKTtcbiAgICAgICAgICAgICAgICBtb2RlID0gTW9kZS5XRUVLO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBEQVk6XG4gICAgICAgICAgICAgICAgbW9tZW50UmVmLmFkZCgtbnVtLCAnZCcpO1xuICAgICAgICAgICAgICAgIG1vZGUgPSBNb2RlLkRBVEU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1PTlRIOlxuICAgICAgICAgICAgICAgIG1vbWVudFJlZi5hZGQoLW51bSwgJ21vbnRoJyk7XG4gICAgICAgICAgICAgICAgbW9kZSA9IE1vZGUuREFURTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgWUVBUjpcbiAgICAgICAgICAgICAgICBtb21lbnRSZWYuYWRkKC1udW0sICd5ZWFyJyk7XG4gICAgICAgICAgICAgICAgbW9kZSA9IE1vZGUuREFURTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgTW9kZS5USU1FOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShEQVksIG1vbWVudFJlZi5kYXRlKCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNT05USCwgbW9tZW50UmVmLm1vbnRoKCkgKyAxKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoWUVBUiwgbW9tZW50UmVmLnllYXIoKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihIT1VSLCBtb21lbnRSZWYuaG91cigpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1JTlVURSwgbW9tZW50UmVmLm1pbnV0ZSgpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTW9kZS5EQVRFOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oREFZLCBtb21lbnRSZWYuZGF0ZSgpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1PTlRILCBtb21lbnRSZWYubW9udGgoKSArIDEpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oWUVBUiwgbW9tZW50UmVmLnllYXIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIE1vZGUuV0VFSzpcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoREFZLCBtb21lbnRSZWYuZGF0ZSgpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTU9OVEgsIG1vbWVudFJlZi5tb250aCgpICsgMSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KFlFQVIsIG1vbWVudFJlZi55ZWFyKCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShXRUVLREFZLCBtb21lbnRSZWYuZGF5KCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSIsImltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkQ29tcG9uZW50cywgUGFyc2VkUmVzdWx0fSBmcm9tIFwiLi4vLi4vcmVzdWx0XCI7XG5pbXBvcnQge1BhcnNlT3B0aW9uc30gZnJvbSBcIi4uLy4uL2Nocm9ub1wiO1xuaW1wb3J0IHtEQVksIEhPVVIsIE1FUklESUVNLCBNSU5VVEUsIE1PTlRILCBTRUNPTkQsIFlFQVJ9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCAqIGFzIG1vbWVudCBmcm9tIFwibW9tZW50XCI7XG5pbXBvcnQge01vbWVudH0gZnJvbSBcIm1vbWVudFwiO1xuXG50eXBlIFRpbWUgPSBbbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRVNUaW1lRXhwcmVzc2lvblBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgcHJpdmF0ZSBQQVRURVJOOiBSZWdFeHAgPSBuZXcgUmVnRXhwKFwiKF58XFxcXHN8VClcIiArXG4gICAgXCIoPzooPzphIGxhcz98YWw/fGRlc2RlfGRlKVxcXFxzKik/XCIgK1xuICAgIFwiKFxcXFxkezEsNH18bWVkaW9kW2nDrV1hfG1lZGlhbm9jaGUpXCIgK1xuICAgIFwiKD86XCIgK1xuICAgICAgICBcIig/OlxcXFwufFxcXFw6fFxcXFzvvJopKFxcXFxkezEsMn0pXCIgK1xuICAgICAgICBcIig/OlwiICtcbiAgICAgICAgICAgIFwiKD86XFxcXDp8XFxcXO+8mikoXFxcXGR7Mn0pXCIgK1xuICAgICAgICBcIik/XCIgK1xuICAgIFwiKT9cIiArXG4gICAgXCIoPzpcXFxccyooQVxcXFwuTVxcXFwufFBcXFxcLk1cXFxcLnxBTT98UE0/KSk/XCIgK1xuICAgIFwiKD89XFxcXFd8JClcIiwgJ2knKTtcblxuICAgIHByaXZhdGUgRU5EX1BBVFRFUk46IFJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJeXFxcXHMqXCIgK1xuICAgIFwiKFxcXFwtfFxcXFzigJN8XFxcXH58XFxcXOOAnHxhKD86XFxzKmxhcyk/fFxcXFw/KVxcXFxzKlwiICtcbiAgICBcIihcXFxcZHsxLDR9KVwiICtcbiAgICBcIig/OlwiICtcbiAgICAgICAgXCIoPzpcXFxcLnxcXFxcOnxcXFxc77yaKShcXFxcZHsxLDJ9KVwiICtcbiAgICAgICAgXCIoPzpcIiArXG4gICAgICAgICAgICBcIig/OlxcXFwufFxcXFw6fFxcXFzvvJopKFxcXFxkezEsMn0pXCIgK1xuICAgICAgICBcIik/XCIgK1xuICAgIFwiKT9cIiArXG4gICAgXCIoPzpcXFxccyooQVxcXFwuTVxcXFwufFBcXFxcLk1cXFxcLnxBTT98UE0/KSk/XCIgK1xuICAgIFwiKD89XFxcXFd8JClcIiwgJ2knKTtcblxuICAgIHByaXZhdGUgSE9VUl9HUk9VUCA9IDI7XG4gICAgcHJpdmF0ZSBNSU5VVEVfR1JPVVAgPSAzO1xuICAgIHByaXZhdGUgU0VDT05EX0dST1VQID0gNDtcbiAgICBwcml2YXRlIEFNX1BNX0hPVVJfR1JPVVAgPSA1O1xuXG4gICAgcHJpdmF0ZSBUQUc6IHN0cmluZyA9ICdFU1RpbWVFeHByZXNzaW9uUGFyc2VyJztcblxuICAgIHByaXZhdGUgT1RIRVJfUEFUVEVSTlM6IFJlZ0V4cFtdID0gW1xuICAgICAgICAvXFx3LyxcbiAgICAgICAgL15cXHMqKFsrXFwtXSlcXHMqXFxkezMsNH0kLyxcbiAgICAgICAgL15cXGQrJC8sXG4gICAgICAgIC9tZWRpb2QvXG4gICAgXTtcblxuICAgIHBhdHRlcm4oKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuUEFUVEVSTjtcbiAgICB9XG5cbiAgICBleHRyYWN0KHRleHQ6IHN0cmluZywgcmVmOiBEYXRlLCBtYXRjaDogUmVnRXhwRXhlY0FycmF5LCBvcHQ6IFBhcnNlT3B0aW9ucyk6IFBhcnNlZFJlc3VsdCB8IG51bGwge1xuICAgICAgICAvLyBUaGlzIHBhdHRlcm4gY2FuIGJlIG92ZXJsYXBlZCBFeC4gWzEyXSBBTSwgMVsyXSBBTVxuICAgICAgICBpZiAobWF0Y2guaW5kZXggPiAwICYmIHRleHRbbWF0Y2guaW5kZXggLSAxXS5tYXRjaCh0aGlzLk9USEVSX1BBVFRFUk5TWzBdKSkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgY29uc3QgcmVmTW9tZW50OiBNb21lbnQgPSBtb21lbnQocmVmKTtcblxuICAgICAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFJlc3VsdCA9IG5ldyBQYXJzZWRSZXN1bHQoe1xuICAgICAgICAgICAgdGV4dDogbWF0Y2hbMF0uc3Vic3RyaW5nKG1hdGNoWzFdLmxlbmd0aCksXG4gICAgICAgICAgICBpbmRleDogbWF0Y2guaW5kZXggKyBtYXRjaFsxXS5sZW5ndGgsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcblxuICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoREFZLCByZWZNb21lbnQuZGF0ZSgpKTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1PTlRILCByZWZNb21lbnQubW9udGgoKSArIDEpO1xuICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoWUVBUiwgcmVmTW9tZW50LnllYXIoKSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmV4dHJhY3RGaXJzdENodW5rKHJlc3VsdCwgbWF0Y2gpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5leHRyYWN0U2Vjb25kQ2h1bmsodGV4dCwgcmVzdWx0KSAmJiByZXN1bHQudGV4dC5tYXRjaCh0aGlzLk9USEVSX1BBVFRFUk5TWzJdKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHByaXZhdGUgZXh0cmFjdEZpcnN0Q2h1bmsocmVzdWx0OiBQYXJzZWRSZXN1bHQsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXkpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgdGltZTogVGltZSB8IGZhbHNlID0gdGhpcy5nZXRUaW1lKG1hdGNoKTtcbiAgICAgICAgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgW2hvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtZXJpZGllbV06IFRpbWUgPSB0aW1lO1xuXG4gICAgICAgIGlmIChzZWNvbmQgPiAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihTRUNPTkQsIHNlY29uZCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIC0tLS0tIEFNICYgUE1cbiAgICAgICAgaWYgKG1hdGNoW3RoaXMuQU1fUE1fSE9VUl9HUk9VUF0pIHtcbiAgICAgICAgICAgIGlmIChob3VyID4gMTIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGFtcG06IHN0cmluZyA9IG1hdGNoW3RoaXMuQU1fUE1fSE9VUl9HUk9VUF1bMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChhbXBtID09PSAnYScpIHtcbiAgICAgICAgICAgICAgICBtZXJpZGllbSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSBob3VyID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYW1wbSA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgbWVyaWRpZW0gPSAxO1xuICAgICAgICAgICAgICAgIGlmIChob3VyICE9PSAxMikgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oSE9VUiwgaG91cik7XG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTUlOVVRFLCBtaW51dGUpO1xuXG4gICAgICAgIGlmIChtZXJpZGllbSA+PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1FUklESUVNLCBtZXJpZGllbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1FUklESUVNLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1FUklESUVNLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgZXh0cmFjdFNlY29uZENodW5rKHRleHQ6IHN0cmluZywgcmVzdWx0OiBQYXJzZWRSZXN1bHQpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGwgPSB0aGlzLkVORF9QQVRURVJOLmV4ZWModGV4dC5zdWJzdHJpbmcocmVzdWx0LmluZGV4ICsgcmVzdWx0LnRleHQubGVuZ3RoKSk7XG5cbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGF0dGVybiBcIllZLllZIC1YWFhYXCIgaXMgbW9yZSBsaWtlIHRpbWV6b25lIG9mZnNldFxuICAgICAgICBpZiAobWF0Y2hbMF0ubWF0Y2godGhpcy5PVEhFUl9QQVRURVJOU1sxXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGltZTogVGltZSB8IGZhbHNlID0gdGhpcy5nZXRUaW1lKG1hdGNoKTtcbiAgICAgICAgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBbaG91ciwgbWludXRlLCBzZWNvbmQsIG1lcmlkaWVtXTogVGltZSA9IHRpbWU7XG5cbiAgICAgICAgaWYgKCFyZXN1bHQuZW5kKSB7XG4gICAgICAgICAgICByZXN1bHQuZW5kID0gbmV3IFBhcnNlZENvbXBvbmVudHModW5kZWZpbmVkLCByZXN1bHQuc3RhcnQuZGF0ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWNvbmQgPiAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LmVuZC5hc3NpZ24oU0VDT05ELCBzZWNvbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0gQU0gJiBQTVxuICAgICAgICBpZiAobWF0Y2hbdGhpcy5BTV9QTV9IT1VSX0dST1VQXSkge1xuXG4gICAgICAgICAgICBpZiAoaG91ciA+IDEyKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIGNvbnN0IGFtcG06IHN0cmluZyA9IG1hdGNoW3RoaXMuQU1fUE1fSE9VUl9HUk9VUF1bMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChhbXBtID09PSAnYScpIHtcbiAgICAgICAgICAgICAgICBtZXJpZGllbSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5lbmQuaXNDZXJ0YWluKERBWSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lbmQuaW1wbHkoREFZLCByZXN1bHQuZW5kLmdldChEQVkpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbXBtID09PSAncCcpIHtcbiAgICAgICAgICAgICAgICBtZXJpZGllbSA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXIgIT09IDEyKSBob3VyICs9IDEyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5zdGFydC5pc0NlcnRhaW4oTUVSSURJRU0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lcmlkaWVtID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNRVJJRElFTSwgMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGFydC5nZXQoSE9VUikgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKEhPVVIsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1FUklESUVNLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXJ0LmdldChIT1VSKSAhPT0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oSE9VUiwgcmVzdWx0LnN0YXJ0LmdldChIT1VSKSArIDEyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC50ZXh0ID0gcmVzdWx0LnRleHQgKyBtYXRjaFswXTtcbiAgICAgICAgcmVzdWx0LmVuZC5hc3NpZ24oSE9VUiwgaG91cik7XG4gICAgICAgIHJlc3VsdC5lbmQuYXNzaWduKE1JTlVURSwgbWludXRlKTtcbiAgICAgICAgaWYgKG1lcmlkaWVtID49IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5lbmQuYXNzaWduKE1FUklESUVNLCBtZXJpZGllbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LmVuZC5kYXRlKCkuZ2V0VGltZSgpIDwgcmVzdWx0LnN0YXJ0LmRhdGUoKS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lbmQuaW1wbHkoREFZLCByZXN1bHQuZW5kLmdldChEQVkpICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRpbWUobWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSk6IFRpbWUgfCBmYWxzZSB7XG4gICAgICAgIGxldCBzZWNvbmQ6IG51bWJlciA9IC0xO1xuICAgICAgICBsZXQgaG91cjogbnVtYmVyID0gMDtcbiAgICAgICAgbGV0IG1pbnV0ZTogbnVtYmVyID0gMDtcbiAgICAgICAgbGV0IG1lcmlkaWVtOiBudW1iZXIgPSAtMTtcblxuICAgICAgICAvLyAtLS0tLSBTZWNvbmRcbiAgICAgICAgaWYgKG1hdGNoW3RoaXMuU0VDT05EX0dST1VQXSkge1xuICAgICAgICAgICAgc2Vjb25kID0gcGFyc2VJbnQobWF0Y2hbdGhpcy5TRUNPTkRfR1JPVVBdLCAxMCk7XG4gICAgICAgICAgICBpZiAoc2Vjb25kID49IDYwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLSBIb3Vyc1xuICAgICAgICBpZiAobWF0Y2hbdGhpcy5IT1VSX0dST1VQXS50b0xvd2VyQ2FzZSgpLm1hdGNoKHRoaXMuT1RIRVJfUEFUVEVSTlNbM10pKSB7XG4gICAgICAgICAgICBtZXJpZGllbSA9IDE7XG4gICAgICAgICAgICBob3VyID0gMTI7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbdGhpcy5IT1VSX0dST1VQXS50b0xvd2VyQ2FzZSgpID09PSAnbWVkaWFub2NoZScpIHtcbiAgICAgICAgICAgIG1lcmlkaWVtID0gMDtcbiAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG91ciA9IHBhcnNlSW50KG1hdGNoW3RoaXMuSE9VUl9HUk9VUF0sIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tIE1pbnV0ZXNcbiAgICAgICAgaWYgKG1hdGNoW3RoaXMuTUlOVVRFX0dST1VQXSkge1xuICAgICAgICAgICAgbWludXRlID0gcGFyc2VJbnQobWF0Y2hbdGhpcy5NSU5VVEVfR1JPVVBdLCAxMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA+IDEwMCkge1xuICAgICAgICAgICAgbWludXRlID0gaG91ciAlIDEwMDtcbiAgICAgICAgICAgIGhvdXIgPSBNYXRoLmZsb29yKGhvdXIgLyAxMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pbnV0ZSA+PSA2MCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhvdXIgPiAyNCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob3VyID49IDEyKSB7XG4gICAgICAgICAgICBtZXJpZGllbSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2hvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtZXJpZGllbV07XG4gICAgfVxufSIsImltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tIFwiLi4vLi4vcmVzdWx0XCI7XG5pbXBvcnQge1BhcnNlT3B0aW9uc30gZnJvbSBcIi4uLy4uL2Nocm9ub1wiO1xuaW1wb3J0IHtXRUVLREFZX09GRlNFVH0gZnJvbSAnLi4vLi4vdXRpbHMvRVMnO1xuaW1wb3J0IHtNb2RpZmllciwgdXBkYXRlUGFyc2VkQ29tcG9uZW50fSBmcm9tICcuLi8uLi91dGlscy9nZW5lcmFsJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRVNXZWVrZGF5UGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBwcml2YXRlIFBBVFRFUk46IFJlZ0V4cCA9IG5ldyBSZWdFeHAoJyhcXFxcV3xeKScgK1xuICAgICAgICAnKD86KD86XFxcXCx8XFxcXCh8XFxcXO+8iClcXFxccyopPycgK1xuICAgICAgICAnKD86KGVzdGV8cGFzYWRvfHByW2/Ds114aW1vKVxcXFxzKik/JyArXG4gICAgICAgICcoJyArIE9iamVjdC5rZXlzKFdFRUtEQVlfT0ZGU0VUKS5qb2luKCd8JykgKyAnKScgK1xuICAgICAgICAnKD86XFxcXHMqKD86XFxcXCx8XFxcXCl8XFxcXO+8iSkpPycgK1xuICAgICAgICAnKD86XFxcXHMqKGVzdGV8cGFzYWRvfHByW8Ozb114aW1vKVxcXFxzKndlZWspPycgK1xuICAgICAgICAnKD89XFxcXFd8JCknLCAnaScpO1xuXG4gICAgcHJpdmF0ZSBQUkVGSVhfR1JPVVA6IG51bWJlciA9IDI7XG4gICAgcHJpdmF0ZSBXRUVLREFZX0dST1VQOiBudW1iZXIgPSAzO1xuICAgIHByaXZhdGUgUE9TVEZJWF9HUk9VUDogbnVtYmVyID0gNDtcblxuICAgIHByaXZhdGUgVEFHOiBzdHJpbmcgPSAnRVNXZWVrZGF5UGFyc2VyJztcblxuICAgIHBhdHRlcm4oKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuUEFUVEVSTjtcbiAgICB9XG5cbiAgICBleHRyYWN0KHRleHQ6IHN0cmluZywgcmVmOiBEYXRlLCBtYXRjaDogUmVnRXhwRXhlY0FycmF5LCBvcHQ6IFBhcnNlT3B0aW9ucyk6IFBhcnNlZFJlc3VsdCB8IG51bGwge1xuICAgICAgICBjb25zdCBpbmRleDogbnVtYmVyID0gbWF0Y2guaW5kZXggKyBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRUZXh0OiBzdHJpbmcgPSBtYXRjaFswXS5zdWJzdHIobWF0Y2hbMV0ubGVuZ3RoLCBtYXRjaFswXS5sZW5ndGggLSBtYXRjaFsxXS5sZW5ndGgpO1xuICAgICAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFJlc3VsdCA9IG5ldyBQYXJzZWRSZXN1bHQoe1xuICAgICAgICAgICAgdGV4dDogbWF0Y2hlZFRleHQsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgb2Zmc2V0OiBudW1iZXIgfCB1bmRlZmluZWQgPSBXRUVLREFZX09GRlNFVFttYXRjaFt0aGlzLldFRUtEQVlfR1JPVVBdLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuXG4gICAgICAgIGNvbnN0IHByZWZpeDogc3RyaW5nID0gbWF0Y2hbdGhpcy5QUkVGSVhfR1JPVVBdO1xuICAgICAgICBjb25zdCBwb3N0Zml4OiBzdHJpbmcgPSBtYXRjaFt0aGlzLlBPU1RGSVhfR1JPVVBdO1xuICAgICAgICBjb25zdCBub3JtOiBzdHJpbmcgPSAocHJlZml4IHx8IHBvc3RmaXggfHwgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgbGV0IG1vZGlmaWVyOiBNb2RpZmllciA9IE1vZGlmaWVyLlVOS05PV047XG4gICAgICAgIGlmIChub3JtPT0gJ2VzdGUnKSB7XG4gICAgICAgICAgICBtb2RpZmllciA9IE1vZGlmaWVyLlRISVM7XG4gICAgICAgIH0gZWxzZSBpZiAobm9ybSA9PT0gJ3Bhc2FkbycpIHtcbiAgICAgICAgICAgIG1vZGlmaWVyID0gTW9kaWZpZXIuTEFTVDtcbiAgICAgICAgfSBlbHNlIGlmIChub3JtID09ICdwcsOzeGltbycgfHwgbm9ybSA9PSAncHJveGltbycpIHtcbiAgICAgICAgICAgIG1vZGlmaWVyID0gTW9kaWZpZXIuTkVYVDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC50YWdzW3RoaXMuVEFHXSA9IHRydWU7XG5cbiAgICAgICAgdXBkYXRlUGFyc2VkQ29tcG9uZW50KHJlc3VsdCwgcmVmLCBvZmZzZXQsIG1vZGlmaWVyKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0iLCJpbXBvcnQgKiBhcyBtb21lbnQgZnJvbSBcIm1vbWVudFwiO1xuaW1wb3J0IHtNb21lbnR9IGZyb20gXCJtb21lbnRcIjtcbmltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tICcuLi8uLi9yZXN1bHQnO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jaHJvbm9cIjtcbmltcG9ydCB7REFZLCBIT1VSLCBNRVJJRElFTSwgTUlMTElTRUNPTkQsIE1JTlVURSwgTU9OVEgsIFNFQ09ORCwgWUVBUn0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGUkNhc3VhbERhdGVQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIHByaXZhdGUgUEFUVEVSTjogUmVnRXhwID0gLyhcXFd8XikobWFpbnRlbmFudHxhdWpvdXJkJ2h1aXxhamR8Y2V0dGVcXHMqbnVpdHxsYVxccyp2ZWlsbGV8KGRlbWFpbnxoaWVyKShcXHMqKG1hdGlufHNvaXJ8YXByZW18YXByw6hzLW1pZGkpKT98Y2VcXHMqKG1hdGlufHNvaXIpfGNldFxccyooYXByw6hzLW1pZGl8YXByZW0pKSg/PVxcV3wkKS9pO1xuXG4gICAgcHJpdmF0ZSBPVEhFUl9QQVRURVJOUzogUmVnRXhwW10gPSBbXG4gICAgICAgIC9kZW1haW4vLFxuICAgICAgICAvaGllci8sXG4gICAgICAgIC9jZXR0ZVxccypudWl0LyxcbiAgICAgICAgL2xhXFxzKnZlaWxsZS8sXG4gICAgICAgIC9hcHLDqHMtbWlkaXxhcHJlbS8sXG4gICAgICAgIC9zb2lyLyxcbiAgICAgICAgL21hdGluLyxcbiAgICAgICAgL21haW50ZW5hbnQvXG4gICAgXTtcblxuICAgIHByaXZhdGUgVEFHOiBzdHJpbmcgPSAnRlJDYXN1YWxEYXRlUGFyc2VyJztcblxuICAgIHBhdHRlcm4oKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuUEFUVEVSTjtcbiAgICB9XG5cbiAgICBleHRyYWN0KHRleHQ6IHN0cmluZywgcmVmOiBEYXRlLCBtYXRjaDogUmVnRXhwRXhlY0FycmF5LCBvcHQ6IFBhcnNlT3B0aW9ucyk6IFBhcnNlZFJlc3VsdCB8IG51bGwge1xuICAgICAgICBjb25zdCBpbmRleDogbnVtYmVyID0gbWF0Y2guaW5kZXggKyBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogUGFyc2VkUmVzdWx0ID0gbmV3IFBhcnNlZFJlc3VsdCh7XG4gICAgICAgICAgICB0ZXh0OiBtYXRjaFswXS5zdWJzdHIobWF0Y2hbMV0ubGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcmVmXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlZk1vbWVudDogTW9tZW50ID0gbW9tZW50KHJlZik7XG4gICAgICAgIGNvbnN0IHN0YXJ0TW9tZW50OiBNb21lbnQgPSByZWZNb21lbnQuY2xvbmUoKTtcbiAgICAgICAgY29uc3QgbWF0Y2hlZFRleHQgPSByZXN1bHQudGV4dC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmIChtYXRjaGVkVGV4dC5tYXRjaCh0aGlzLk9USEVSX1BBVFRFUk5TWzBdKSkge1xuICAgICAgICAgICAgaWYgKHJlZk1vbWVudC5ob3VyKCkgPiAxKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRNb21lbnQuYWRkKDEsICdkYXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVkVGV4dC5tYXRjaCh0aGlzLk9USEVSX1BBVFRFUk5TWzFdKSkge1xuICAgICAgICAgICAgc3RhcnRNb21lbnQuYWRkKC0xLCAnZGF5Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2hlZFRleHQubWF0Y2godGhpcy5PVEhFUl9QQVRURVJOU1syXSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShIT1VSLCAyMik7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTUVSSURJRU0sIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZWRUZXh0Lm1hdGNoKHRoaXMuT1RIRVJfUEFUVEVSTlNbM10pKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoSE9VUiwgMCk7XG4gICAgICAgICAgICBpZiAocmVmTW9tZW50LmhvdXIoKSA+IDYpIHtcbiAgICAgICAgICAgICAgICBzdGFydE1vbWVudC5hZGQoLTEsICdkYXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVkVGV4dC5tYXRjaCh0aGlzLk9USEVSX1BBVFRFUk5TWzRdKSkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KEhPVVIsIDE0KTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVkVGV4dC5tYXRjaCh0aGlzLk9USEVSX1BBVFRFUk5TWzVdKSkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KEhPVVIsIDE4KTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVkVGV4dC5tYXRjaCh0aGlzLk9USEVSX1BBVFRFUk5TWzZdKSkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KEhPVVIsIDgpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZWRUZXh0Lm1hdGNoKHRoaXMuT1RIRVJfUEFUVEVSTlNbN10pKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKEhPVVIsIHJlZk1vbWVudC5ob3VyKCkpO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihNSU5VVEUsIHJlZk1vbWVudC5taW51dGUoKSk7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKFNFQ09ORCwgcmVmTW9tZW50LnNlY29uZCgpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTUlMTElTRUNPTkQsIHJlZk1vbWVudC5taWxsaXNlY29uZCgpKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihEQVksIHN0YXJ0TW9tZW50LmRhdGUoKSk7XG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTU9OVEgsIHN0YXJ0TW9tZW50Lm1vbnRoKCkgKyAxKTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCBzdGFydE1vbWVudC55ZWFyKCkpO1xuICAgICAgICByZXN1bHQudGFnc1t0aGlzLlRBR10gPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0iLCJpbXBvcnQgUGFyc2VyIGZyb20gJy4uL3BhcnNlcic7XG5pbXBvcnQge1BhcnNlZFJlc3VsdH0gZnJvbSAnLi4vLi4vcmVzdWx0JztcbmltcG9ydCB7UGFyc2VPcHRpb25zfSBmcm9tIFwiLi4vLi4vY2hyb25vXCI7XG5pbXBvcnQgKiBhcyBtb21lbnQgZnJvbSBcIm1vbWVudFwiO1xuaW1wb3J0IHtVbml0T2ZUaW1lfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQge2RlYWRsaW5lQ2FsY3VsYXRpb25zfSBmcm9tIFwiLi4vLi4vdXRpbHMvZ2VuZXJhbFwiO1xuaW1wb3J0IHtJTlRFR0VSX1dPUkRTX1BBVFRFUk4sIG1hdGNoTnVtYmVyLCBtYXRjaFVuaXR9IGZyb20gXCIuLi8uLi91dGlscy9GUlwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGUkRlYWRsaW5lRm9ybWF0UGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBwcml2YXRlIFBBVFRFUk46IFJlZ0V4cCA9IG5ldyBSZWdFeHAoJyhcXFxcV3xeKScgK1xuICAgICAgICAnKGRhbnN8ZW4pXFxcXHMqJyArXG4gICAgICAgICcoJysgSU5URUdFUl9XT1JEU19QQVRURVJOICsgJ3xbMC05XSt8dW5lP3woPzpcXFxccypxdWVscXVlcyk/fGRlbWkoPzpcXFxccyp8LT8pPylcXFxccyonICtcbiAgICAgICAgJyhzZWNvbmRlcz98bWluKD86dXRlKT9zP3xoZXVyZXM/fGpvdXJzP3xzZW1haW5lcz98bW9pc3xhbm7DqWVzPylcXFxccyonICtcbiAgICAgICAgJyg/PVxcXFxXfCQpJywgJ2knXG4gICAgKTtcblxuICAgIHByaXZhdGUgU1RSSUNUX1BBVFRFUk46IFJlZ0V4cCA9IG5ldyBSZWdFeHAoJyhcXFxcV3xeKScgK1xuICAgICAgICAnKGRhbnN8ZW4pXFxcXHMqJyArXG4gICAgICAgICcoJysgSU5URUdFUl9XT1JEU19QQVRURVJOICsgJ3xbMC05XSt8dW4/KVxcXFxzKicgK1xuICAgICAgICAnKHNlY29uZGVzP3xtaW51dGVzP3xoZXVyZXM/fGpvdXJzPylcXFxccyonICtcbiAgICAgICAgJyg/PVxcXFxXfCQpJywgJ2knXG4gICAgKTtcblxuICAgIHByaXZhdGUgTlVNX01BVENIOiBudW1iZXIgPSAzO1xuICAgIHByaXZhdGUgVU5JVF9NQVRDSDogbnVtYmVyID0gNDtcblxuICAgIHByaXZhdGUgVEFHOiBzdHJpbmcgPSAnRlJEZWFkbGluZUZvcm1hdFBhcnNlcic7XG5cbiAgICBwYXR0ZXJuKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU3RyaWN0TW9kZSgpPyB0aGlzLlNUUklDVF9QQVRURVJOIDogdGhpcy5QQVRURVJOO1xuICAgIH1cblxuICAgIGV4dHJhY3QodGV4dDogc3RyaW5nLCByZWY6IERhdGUsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGluZGV4OiBudW1iZXIgPSBtYXRjaC5pbmRleCArIG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBQYXJzZWRSZXN1bHQgPSBuZXcgUGFyc2VkUmVzdWx0KHtcbiAgICAgICAgICAgIHRleHQ6IG1hdGNoWzBdLnN1YnN0cihtYXRjaFsxXS5sZW5ndGgsIG1hdGNoWzBdLmxlbmd0aCAtIG1hdGNoWzFdLmxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIHJlZlxuICAgICAgICB9KTtcblxuICAgICAgICByZXN1bHQudGFnc1t0aGlzLlRBR10gPSB0cnVlO1xuXG4gICAgICAgIGNvbnN0IG51bTogbnVtYmVyID0gbWF0Y2hOdW1iZXIobWF0Y2hbdGhpcy5OVU1fTUFUQ0hdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBjb25zdCBtYXRjaGVkVW5pdDogVW5pdE9mVGltZSB8IHVuZGVmaW5lZCA9IG1hdGNoVW5pdChtYXRjaFt0aGlzLlVOSVRfTUFUQ0hdLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgIGlmIChudW0gJiYgbWF0Y2hlZFVuaXQgJiYgZGVhZGxpbmVDYWxjdWxhdGlvbnMobnVtLCBtYXRjaGVkVW5pdCwgcmVzdWx0LCBtb21lbnQocmVmKSkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59IiwiaW1wb3J0IFBhcnNlciBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHtQYXJzZWRSZXN1bHR9IGZyb20gJy4uLy4uL3Jlc3VsdCc7XG5pbXBvcnQge1BhcnNlT3B0aW9uc30gZnJvbSBcIi4uLy4uL2Nocm9ub1wiO1xuaW1wb3J0IHtNT05USF9PRkZTRVQsIFdFRUtEQVlfT0ZGU0VULCB5ZWFyQ2FsY3VsYXRpb259IGZyb20gXCIuLi8uLi91dGlscy9GUlwiO1xuaW1wb3J0IHtEQVksIE1PTlRILCBXRUVLREFZLCBZRUFSfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQge2dldEFwcHJvcHJpYXRlWWVhcn0gZnJvbSBcIi4uLy4uL3V0aWxzL2dlbmVyYWxcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRlJNb250aE5hbWVMaXR0bGVFbmRpYW5QYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIHByaXZhdGUgUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cCgnKFxcXFxXfF4pJyArXG4gICAgICAgICcoPzooRGltYW5jaGV8THVuZGl8TWFyZGl8bWVyY3JlZGl8SmV1ZGl8VmVuZHJlZGl8U2FtZWRpfERpbXxMdW58TWFyfE1lcnxKZXV8VmVufFNhbSlcXFxccyosP1xcXFxzKik/JyArXG4gICAgICAgICcoWzAtOV17MSwyfXwxZXIpJyArXG4gICAgICAgICcoPzpcXFxccyooPzphdXxcXFxcLXxcXFxc4oCTfGp1c3F1XFwnYXU/fFxcXFxzKVxcXFxzKihbMC05XXsxLDJ9KSg/OmVyKT8pP1xcXFxzKig/OmRlKT9cXFxccyonICtcbiAgICAgICAgJyhKYW4oPzp2aWVyfFxcXFwuKT98RlvDqWVddig/OnJpZXJ8XFxcXC4pP3xNYXJzfEF2cig/OmlsfFxcXFwuKT98TWFpfEp1aW58SnVpbCg/OmxldHxcXFxcLik/fEFvW3XDu110fFNlcHQoPzplbWJyZXxcXFxcLik/fE9jdCg/Om9icmV8XFxcXC4pP3xOb3YoPzplbWJyZXxcXFxcLik/fGRbw6llXWMoPzplbWJyZXxcXFxcLik/KScgK1xuICAgICAgICAnKD86XFxcXHMqKFxcXFxzKlswLTldezEsNH0oPyFbXlxcXFxzXVxcXFxkKSkoPzpcXFxccyooQUN8W2FwXVxcXFwuP1xcXFxzKmMoPzpoKD86cik/KT9cXFxcLj9cXFxccypuXFxcXC4/KSk/KT8nICtcbiAgICAgICAgJyg/PVxcXFxXfCQpJywgJ2knXG4gICAgKTtcblxuICAgIHByaXZhdGUgV0VFS0RBWV9HUk9VUDogbnVtYmVyID0gMjtcbiAgICBwcml2YXRlIERBVEVfR1JPVVA6IG51bWJlciA9IDM7XG4gICAgcHJpdmF0ZSBEQVRFX1RPX0dST1VQOiBudW1iZXIgPSA0O1xuICAgIHByaXZhdGUgTU9OVEhfTkFNRV9HUk9VUDogbnVtYmVyID0gNTtcbiAgICBwcml2YXRlIFlFQVJfR1JPVVA6IG51bWJlciA9IDY7XG4gICAgcHJpdmF0ZSBZRUFSX0JFX0dST1VQOiBudW1iZXIgPSA3O1xuXG4gICAgcHJpdmF0ZSBUQUc6IHN0cmluZyA9ICdGUk1vbnRoTmFtZUxpdHRsZUVuZGlhblBhcnNlcic7XG5cbiAgICBwYXR0ZXJuKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiB0aGlzLlBBVFRFUk47XG4gICAgfVxuXG4gICAgZXh0cmFjdCh0ZXh0OiBzdHJpbmcsIHJlZjogRGF0ZSwgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSwgb3B0OiBQYXJzZU9wdGlvbnMpOiBQYXJzZWRSZXN1bHQgfCBudWxsIHtcbiAgICAgICAgY29uc3QgaW5kZXg6IG51bWJlciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFJlc3VsdCA9IG5ldyBQYXJzZWRSZXN1bHQoe1xuICAgICAgICAgICAgdGV4dDogbWF0Y2hbMF0uc3Vic3RyKG1hdGNoWzFdLmxlbmd0aCwgbWF0Y2hbMF0ubGVuZ3RoIC0gbWF0Y2hbMV0ubGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcmVmXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3VsdC50YWdzW3RoaXMuVEFHXSA9IHRydWU7XG5cbiAgICAgICAgY29uc3QgbW9udGg6IG51bWJlciA9IE1PTlRIX09GRlNFVFttYXRjaFt0aGlzLk1PTlRIX05BTUVfR1JPVVBdLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgIGlmICghKG1vbnRoIHx8IG1vbnRoID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXk6IG51bWJlciA9IHBhcnNlSW50KG1hdGNoW3RoaXMuREFURV9HUk9VUF0sIDEwKTtcblxuICAgICAgICBpZiAoIWRheSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKERBWSwgZGF5KTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihNT05USCwgbW9udGgpO1xuXG4gICAgICAgIGxldCB5ZWFyOiBudW1iZXIgfCBudWxsID0geWVhckNhbGN1bGF0aW9uKG1hdGNoW3RoaXMuWUVBUl9HUk9VUF0sIG1hdGNoW3RoaXMuWUVBUl9CRV9HUk9VUF0pO1xuXG4gICAgICAgIGlmICh5ZWFyKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKFlFQVIsIHllYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0QXBwcm9wcmlhdGVZZWFyKHJlc3VsdC5zdGFydCwgcmVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlZWtkYXkgY29tcG9uZW50XG4gICAgICAgIGlmIChtYXRjaFt0aGlzLldFRUtEQVlfR1JPVVBdKSB7XG4gICAgICAgICAgICBjb25zdCB3ZWVrZGF5OiBudW1iZXIgPSBXRUVLREFZX09GRlNFVFttYXRjaFt0aGlzLldFRUtEQVlfR1JPVVBdLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXkgfHwgd2Vla2RheSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oV0VFS0RBWSwgd2Vla2RheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXh0IGNhbiBiZSAncmFuZ2UnIHZhbHVlLiBTdWNoIGFzICcxMiAtIDEzIEphbnVhcnkgMjAxMidcbiAgICAgICAgaWYgKG1hdGNoW3RoaXMuREFURV9UT19HUk9VUF0pIHtcbiAgICAgICAgICAgIGNvbnN0IGVuZERhdGUgPSBwYXJzZUludChtYXRjaFt0aGlzLkRBVEVfVE9fR1JPVVBdLCAxMCk7XG5cbiAgICAgICAgICAgIGlmIChlbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVuZCA9IHJlc3VsdC5zdGFydC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5lbmQuYXNzaWduKERBWSwgZW5kRGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0iLCJpbXBvcnQgKiBhcyBtb21lbnQgZnJvbSBcIm1vbWVudFwiO1xuaW1wb3J0IHtNb21lbnQsIHVuaXRPZlRpbWV9IGZyb20gXCJtb21lbnRcIjtcbmltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tICcuLi8uLi9yZXN1bHQnO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jaHJvbm9cIjtcbmltcG9ydCB7bWF0Y2hOdW1iZXIsIG1hdGNoVW5pdCwgSU5URUdFUl9XT1JEU19QQVRURVJOfSBmcm9tIFwiLi4vLi4vdXRpbHMvRlJcIjtcbmltcG9ydCB7REFZLCBIT1VSLCBNSUxMSVNFQ09ORCwgTUlOVVRFLCBNT05USCwgU0VDT05ELCBVbml0T2ZUaW1lLCBXRUVLLCBZRUFSfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cbi8vIEZvcmNlIGxvYWQgZnIgbG9jYWxpemF0aW9uIGRhdGEgZnJvbSBtb21lbnQgZm9yIHRoZSBsb2NhbGUgZmlsZXMgdG8gYmUgbGlua2RlZCBkdXJuaW5nIGJyb3dzZXJpZnkuXG4vLyBOT1RFOiBUaGUgZnVuY3Rpb24gbW9tZW50LmRlZmluZUxvY2FsZSgpIGFsc28gaGFzIGEgc2lkZSBlZmZlY3QgdGhhdCBpdCBjaGFuZ2UgZ2xvYmFsIGxvY2FsZVxuLy8gIFdlIGFsc28gbmVlZCB0byBzYXZlIGFuZCByZXN0b3JlIHRoZSBwcmV2aW91cyBsb2NhbGUgKHNlZS4gbW9tZW50LmpzLCBsb2FkTG9jYWxlKVxuY29uc3Qgb3JpZ2luYWxMb2NhbGUgPSBtb21lbnQubG9jYWxlKCk7XG5jb25zdCBpZ25vcmVkID0gcmVxdWlyZSgnbW9tZW50L2xvY2FsZS9mcicpO1xubW9tZW50LmxvY2FsZShvcmlnaW5hbExvY2FsZSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZSUmVsYXRpdmVEYXRlRm9ybWF0UGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBwcml2YXRlIFBBVFRFUk46IFJlZ0V4cCA9IG5ldyBSZWdFeHAoJyhcXFxcV3xeKScgK1xuICAgICAgICAnKD86bGVzP3xsYXxsXFwnfGR1fGRlcz8pXFxcXHMqJyArXG4gICAgICAgICcoJysgSU5URUdFUl9XT1JEU19QQVRURVJOICsgJ3xcXFxcZCspP1xcXFxzKicgK1xuICAgICAgICAnKHByb2NoYWluZT9zP3xkZXJuaVtlw6hdcmU/cz98cGFzc1vDqWVdZT9zP3xwclvDqWVdY1vDqWVdZGVudHM/fHN1aXZhbnRlP3M/KT9cXFxccyonICtcbiAgICAgICAgJyhzZWNvbmRlcz98bWluKD86dXRlKT9zP3xoZXVyZXM/fGpvdXJzP3xzZW1haW5lcz98bW9pc3x0cmltZXN0cmVzP3xhbm7DqWVzPylcXFxccyonICtcbiAgICAgICAgJyhwcm9jaGFpbmU/cz98ZGVybmlbZcOoXXJlP3M/fHBhc3Nbw6llXWU/cz98cHJbw6llXWNbw6llXWRlbnRzP3xzdWl2YW50ZT9zPyk/JyArXG4gICAgICAgICcoPz1cXFxcV3wkKScsICdpJ1xuICAgICk7XG5cbiAgICBwcml2YXRlIE1VTFRJUExJRVJfR1JPVVA6IG51bWJlciA9IDI7XG4gICAgcHJpdmF0ZSBNT0RJRklFUl8xX0dST1VQOiBudW1iZXIgPSAzO1xuICAgIHByaXZhdGUgUkVMQVRJVkVfV09SRF9HUk9VUDogbnVtYmVyID0gNDtcbiAgICBwcml2YXRlIE1PRElGSUVSXzJfR1JPVVA6IG51bWJlciA9IDU7XG5cbiAgICBwcml2YXRlIE9USEVSX1BBVFRFUk5TOiBSZWdFeHBbXSA9IFtcbiAgICAgICAgL3Byb2NoYWluZT9zP3xzdWl2YW50cz8vLFxuICAgICAgICAvZGVybmlbZcOoXXJlP3M/fHBhc3Nbw6llXWU/cz98cHJbw6llXWNbw6llXWRlbnRzPy9cbiAgICBdO1xuXG4gICAgcHJpdmF0ZSBUQUc6IHN0cmluZyA9ICdGUlJlbGF0aXZlRGF0ZUZvcm1hdFBhcnNlcic7XG5cbiAgICBwYXR0ZXJuKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiB0aGlzLlBBVFRFUk47XG4gICAgfVxuXG4gICAgZXh0cmFjdCh0ZXh0OiBzdHJpbmcsIHJlZjogRGF0ZSwgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSwgb3B0OiBQYXJzZU9wdGlvbnMpOiBQYXJzZWRSZXN1bHQgfCBudWxsIHtcbiAgICAgICAgY29uc3QgaW5kZXg6IG51bWJlciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFJlc3VsdCA9IG5ldyBQYXJzZWRSZXN1bHQoe1xuICAgICAgICAgICAgdGV4dDogbWF0Y2hbMF0uc3Vic3RyKG1hdGNoWzFdLmxlbmd0aCwgbWF0Y2hbMF0ubGVuZ3RoIC0gbWF0Y2hbMV0ubGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcmVmXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3VsdC50YWdzW3RoaXMuVEFHXSA9IHRydWU7XG5cblxuICAgICAgICBjb25zdCBtYXRjaGVkTXVsdGlwbGllcjogc3RyaW5nID0gbWF0Y2hbdGhpcy5NVUxUSVBMSUVSX0dST1VQXTtcbiAgICAgICAgY29uc3QgbnVtOiBudW1iZXIgPSBtYXRjaE51bWJlcihtYXRjaGVkTXVsdGlwbGllcik7XG5cbiAgICAgICAgY29uc3QgbWF0Y2hlZE1vZGlmaWVyOiBzdHJpbmcgPSAobWF0Y2hbdGhpcy5NT0RJRklFUl8xX0dST1VQXSB8fCBtYXRjaFt0aGlzLk1PRElGSUVSXzJfR1JPVVBdIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIW1hdGNoZWRNb2RpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbW9kaWZpZXJGYWN0b3I6IG51bWJlcjtcblxuICAgICAgICBpZiAodGhpcy5PVEhFUl9QQVRURVJOU1swXS50ZXN0KG1hdGNoZWRNb2RpZmllcikpIHtcbiAgICAgICAgICAgIG1vZGlmaWVyRmFjdG9yID0gMTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLk9USEVSX1BBVFRFUk5TWzFdLnRlc3QobWF0Y2hlZE1vZGlmaWVyKSkge1xuICAgICAgICAgICAgbW9kaWZpZXJGYWN0b3IgPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG90YWw6IG51bWJlciA9IG1vZGlmaWVyRmFjdG9yICogKG51bSB8fCAxKTtcbiAgICAgICAgbGV0IGRhdGVGcm9tOiBNb21lbnQgPSBtb21lbnQocmVmKS5sb2NhbGUoJ2ZyJyk7XG4gICAgICAgIGxldCBkYXRlVG86IE1vbWVudCA9IGRhdGVGcm9tLmNsb25lKCk7XG4gICAgICAgIGNvbnN0IHVuaXQ6IFVuaXRPZlRpbWUgfCB1bmRlZmluZWQgPSBtYXRjaFVuaXQoKG1hdGNoW3RoaXMuUkVMQVRJVkVfV09SRF9HUk9VUF0gfHwgJycpLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgIGlmICghdW5pdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RhcnRPZjogdW5pdE9mVGltZS5TdGFydE9mO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgICAgICAgY2FzZSBTRUNPTkQ6XG4gICAgICAgICAgICAgICAgZGF0ZUZyb20uYWRkKHRvdGFsLCAncycpO1xuICAgICAgICAgICAgICAgIGRhdGVUby5hZGQobW9kaWZpZXJGYWN0b3IsICdzJyk7XG4gICAgICAgICAgICAgICAgc3RhcnRPZiA9ICdzZWNvbmQnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNSU5VVEU6XG4gICAgICAgICAgICAgICAgZGF0ZUZyb20uYWRkKHRvdGFsLCAnbScpO1xuICAgICAgICAgICAgICAgIGRhdGVUby5hZGQobW9kaWZpZXJGYWN0b3IsICdtJyk7XG4gICAgICAgICAgICAgICAgc3RhcnRPZiA9ICdtaW51dGUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBIT1VSOlxuICAgICAgICAgICAgICAgIGRhdGVGcm9tLmFkZCh0b3RhbCwgJ2gnKTtcbiAgICAgICAgICAgICAgICBkYXRlVG8uYWRkKG1vZGlmaWVyRmFjdG9yLCAnaCcpO1xuICAgICAgICAgICAgICAgIHN0YXJ0T2YgPSAnaG91cic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERBWTpcbiAgICAgICAgICAgICAgICBkYXRlRnJvbS5hZGQodG90YWwsICdkJyk7XG4gICAgICAgICAgICAgICAgZGF0ZVRvLmFkZChtb2RpZmllckZhY3RvciwgJ2QnKTtcbiAgICAgICAgICAgICAgICBzdGFydE9mID0gJ2RheSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdFRUs6XG4gICAgICAgICAgICAgICAgZGF0ZUZyb20uYWRkKHRvdGFsLCAndycpO1xuICAgICAgICAgICAgICAgIGRhdGVUby5hZGQobW9kaWZpZXJGYWN0b3IsICd3Jyk7XG4gICAgICAgICAgICAgICAgc3RhcnRPZiA9ICd3ZWVrJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTU9OVEg6XG4gICAgICAgICAgICAgICAgZGF0ZUZyb20uYWRkKHRvdGFsLCAnTScpO1xuICAgICAgICAgICAgICAgIGRhdGVUby5hZGQobW9kaWZpZXJGYWN0b3IsICdNJyk7XG4gICAgICAgICAgICAgICAgc3RhcnRPZiA9ICdtb250aCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFlFQVI6XG4gICAgICAgICAgICAgICAgZGF0ZUZyb20uYWRkKHRvdGFsLCAneScpO1xuICAgICAgICAgICAgICAgIGRhdGVUby5hZGQobW9kaWZpZXJGYWN0b3IsICd5Jyk7XG4gICAgICAgICAgICAgICAgc3RhcnRPZiA9ICd5ZWFyJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9kaWZpZXJGYWN0b3IgPiAwKSB7XG4gICAgICAgICAgICBbZGF0ZUZyb20sIGRhdGVUb10gPSBbZGF0ZVRvLCBkYXRlRnJvbV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgc3RhcnQgYW5kIGVuZCBvZiBkYXRlc1xuICAgICAgICBkYXRlRnJvbS5zdGFydE9mKHN0YXJ0T2YpO1xuICAgICAgICBkYXRlVG8uZW5kT2Yoc3RhcnRPZik7XG5cbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCBkYXRlRnJvbS55ZWFyKCkpO1xuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1PTlRILCBkYXRlRnJvbS5tb250aCgpICsgMSk7XG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oREFZLCBkYXRlRnJvbS5kYXRlKCkpO1xuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1JTlVURSwgZGF0ZUZyb20ubWludXRlKCkpO1xuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKFNFQ09ORCwgZGF0ZUZyb20uc2Vjb25kKCkpO1xuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKEhPVVIsIGRhdGVGcm9tLmhvdXIoKSk7XG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTUlMTElTRUNPTkQsIGRhdGVGcm9tLm1pbGxpc2Vjb25kKCkpO1xuXG4gICAgICAgIHJlc3VsdC5lbmQgPSByZXN1bHQuc3RhcnQuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0LmVuZC5hc3NpZ24oWUVBUiwgZGF0ZVRvLnllYXIoKSk7XG4gICAgICAgIHJlc3VsdC5lbmQuYXNzaWduKE1PTlRILCBkYXRlVG8ubW9udGgoKSArIDEpO1xuICAgICAgICByZXN1bHQuZW5kLmFzc2lnbihEQVksIGRhdGVUby5kYXRlKCkpO1xuICAgICAgICByZXN1bHQuZW5kLmFzc2lnbihNSU5VVEUsIGRhdGVUby5taW51dGUoKSk7XG4gICAgICAgIHJlc3VsdC5lbmQuYXNzaWduKFNFQ09ORCwgZGF0ZVRvLnNlY29uZCgpKTtcbiAgICAgICAgcmVzdWx0LmVuZC5hc3NpZ24oSE9VUiwgZGF0ZVRvLmhvdXIoKSk7XG4gICAgICAgIHJlc3VsdC5lbmQuYXNzaWduKE1JTExJU0VDT05ELCBkYXRlVG8ubWlsbGlzZWNvbmQoKSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59IiwiLypcbiAgICBEYXRlIGZvcm1hdCB3aXRoIHNsYXNoIFwiL1wiIChhbHNvIFwiLVwiIGFuZCBcIi5cIikgYmV0d2VlbiBudW1iZXJzXG4gICAgLSBNYXJ0ZXMgMy8xMS8yMDE1XG4gICAgLSAzLzExLzIwMTVcbiAgICAtIDMvMTFcbiovXG5pbXBvcnQgUGFyc2VyIGZyb20gJy4uL3BhcnNlcic7XG5pbXBvcnQge1BhcnNlZFJlc3VsdH0gZnJvbSAnLi4vLi4vcmVzdWx0JztcbmltcG9ydCB7UGFyc2VPcHRpb25zfSBmcm9tIFwiLi4vLi4vY2hyb25vXCI7XG5pbXBvcnQge0RBWSwgTU9OVEgsIFdFRUtEQVksIFlFQVJ9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCB7V0VFS0RBWV9PRkZTRVR9IGZyb20gXCIuLi8uLi91dGlscy9GUlwiO1xuaW1wb3J0IHtjaGVja01vbnRoRGF5c1ZhbGlkLCBnZXRBcHByb3ByaWF0ZVllYXJ9IGZyb20gXCIuLi8uLi91dGlscy9nZW5lcmFsXCI7XG5pbXBvcnQgKiBhcyBtb21lbnQgZnJvbSAnbW9tZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRlJTbGFzaERhdGVGb3JtYXRQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIHByaXZhdGUgUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cCgnKFxcXFxXfF4pJyArXG4gICAgICAgICcoPzonICtcbiAgICAgICAgJygoPzpkaW1hbmNoZXxkaW18bHVuZGl8bHVufG1hcmRpfG1hcnxtZXJjcmVkaXxtZXJ8amV1ZGl8amV1fHZlbmRyZWRpfHZlbnxzYW1lZGl8c2FtfGxlKSknICtcbiAgICAgICAgJ1xcXFxzKlxcXFwsP1xcXFxzKicgK1xuICAgICAgICAnKT8nICtcbiAgICAgICAgJyhbMC0zXXswLDF9WzAtOV17MX0pW1xcXFwvXFxcXC5cXFxcLV0oWzAtM117MCwxfVswLTldezF9KScgK1xuICAgICAgICAnKD86JyArXG4gICAgICAgICdbXFxcXC9cXFxcLlxcXFwtXScgK1xuICAgICAgICAnKFswLTldezR9XFxzKlxcLD9cXHMqfFswLTldezJ9XFxzKlxcLD9cXHMqKScgK1xuICAgICAgICAnKT8nICtcbiAgICAgICAgJyhcXFxcV3wkKScsICdpJyk7XG5cbiAgICBwcml2YXRlIE9QRU5JTkdfR1JPVVA6IG51bWJlciA9IDE7XG4gICAgcHJpdmF0ZSBFTkRJTkdfR1JPVVA6IG51bWJlciA9IDY7XG5cbiAgICBwcml2YXRlIFdFRUtEQVlfR1JPVVA6IG51bWJlciA9IDI7XG4gICAgcHJpdmF0ZSBNT05USF9HUk9VUDogbnVtYmVyID0gNDtcbiAgICBwcml2YXRlIERBWV9HUk9VUDogbnVtYmVyID0gMztcbiAgICBwcml2YXRlIFlFQVJfR1JPVVA6IG51bWJlciA9IDU7XG5cbiAgICBwcml2YXRlIFRBRzogc3RyaW5nID0gJ0ZSU2xhc2hEYXRlRm9ybWF0UGFyc2VyJztcblxuICAgIHByaXZhdGUgT1RIRVJfUEFUVEVSTlM6IFJlZ0V4cFtdID0gW1xuICAgICAgICAvXlxcZFxcLlxcZCQvLFxuICAgICAgICAvXlxcZFxcLlxcZHsxLDJ9XFwuXFxkezEsMn0kL1xuICAgIF07XG5cbiAgICBwYXR0ZXJuKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiB0aGlzLlBBVFRFUk47XG4gICAgfVxuXG4gICAgZXh0cmFjdCh0ZXh0OiBzdHJpbmcsIHJlZjogRGF0ZSwgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSwgb3B0OiBQYXJzZU9wdGlvbnMpOiBQYXJzZWRSZXN1bHQgfCBudWxsIHtcbiAgICAgICAgaWYgKG1hdGNoW3RoaXMuT1BFTklOR19HUk9VUF0gPT0gJy8nIHx8IG1hdGNoW3RoaXMuRU5ESU5HX0dST1VQXSA9PSAnLycpIHtcbiAgICAgICAgICAgIC8vIExvbmcgc2tpcCwgaWYgdGhlcmUgaXMgc29tZSBvdmVybGFwcGluZyBsaWtlOlxuICAgICAgICAgICAgLy8gWFhbL1lZL1paXVxuICAgICAgICAgICAgLy8gW1hYL1lZL11aWlxuICAgICAgICAgICAgbWF0Y2guaW5kZXggKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbmRleDogbnVtYmVyID0gbWF0Y2guaW5kZXggKyBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogUGFyc2VkUmVzdWx0ID0gbmV3IFBhcnNlZFJlc3VsdCh7XG4gICAgICAgICAgICB0ZXh0OiBtYXRjaFswXS5zdWJzdHIobWF0Y2hbdGhpcy5PUEVOSU5HX0dST1VQXS5sZW5ndGgsIG1hdGNoWzBdLmxlbmd0aCAtIG1hdGNoW3RoaXMuRU5ESU5HX0dST1VQXS5sZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgbWF0Y2hlZFRleHQ6IHN0cmluZyA9IHJlc3VsdC50ZXh0LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWRUZXh0Lm1hdGNoKHRoaXMuT1RIRVJfUEFUVEVSTlNbMF0pIHx8IG1hdGNoZWRUZXh0Lm1hdGNoKHRoaXMuT1RIRVJfUEFUVEVSTlNbMV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1NL2RkIC0+IE9LXG4gICAgICAgIC8vIE1NLmRkIC0+IE5HXG4gICAgICAgIGlmICghbWF0Y2hbdGhpcy5ZRUFSX0dST1VQXSAmJiBtYXRjaFswXS5pbmRleE9mKCcvJykgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB5ZWFyOiBudW1iZXIgPSBtYXRjaFt0aGlzLllFQVJfR1JPVVBdID8gcGFyc2VJbnQobWF0Y2hbdGhpcy5ZRUFSX0dST1VQXSwgMTApIDogbW9tZW50KHJlZikueWVhcigpO1xuICAgICAgICBsZXQgbW9udGg6IG51bWJlciA9IHBhcnNlSW50KG1hdGNoW3RoaXMuTU9OVEhfR1JPVVBdLCAxMCk7XG4gICAgICAgIGxldCBkYXk6IG51bWJlciA9IHBhcnNlSW50KG1hdGNoW3RoaXMuREFZX0dST1VQXSwgMTApO1xuXG4gICAgICAgIGlmIChtb250aCA8IDEgfHwgZGF5IDwgMSB8fCBkYXkgPiAzMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeWVhciA8IDEwMCkge1xuICAgICAgICAgICAgeWVhciA9IHllYXIgKyAyMDAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vbnRoID4gMTIpIHtcbiAgICAgICAgICAgIGlmIChtb250aCA8PSAzMSAmJiBkYXkgPD0gMTIgJiYgY2hlY2tNb250aERheXNWYWxpZChtb250aCwgZGF5LCB5ZWFyKSkge1xuICAgICAgICAgICAgICAgIFttb250aCwgZGF5XSA9IFtkYXksIG1vbnRoXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKERBWSwgZGF5KTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihNT05USCwgbW9udGgpO1xuICAgICAgICBpZiAobWF0Y2hbdGhpcy5ZRUFSX0dST1VQXSkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCB5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldEFwcHJvcHJpYXRlWWVhcihyZXN1bHQuc3RhcnQsIHJlZik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hbdGhpcy5XRUVLREFZX0dST1VQXSkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihXRUVLREFZLCBXRUVLREFZX09GRlNFVFttYXRjaFt0aGlzLldFRUtEQVlfR1JPVVBdLnRvTG93ZXJDYXNlKCldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSIsImltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tICcuLi8uLi9yZXN1bHQnO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jaHJvbm9cIjtcbmltcG9ydCB7REFZLCBIT1VSLCBNSU5VVEUsIE1PTlRILCBVbml0T2ZUaW1lLCBXRUVLLCBXRUVLREFZLCBZRUFSfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQge21hdGNoTnVtYmVyLCBtYXRjaFVuaXR9IGZyb20gXCIuLi8uLi91dGlscy9GUlwiO1xuaW1wb3J0ICogYXMgbW9tZW50IGZyb20gXCJtb21lbnRcIjtcbmltcG9ydCB7TW9tZW50fSBmcm9tIFwibW9tZW50XCI7XG5cbmVudW0gTW9kZSB7XG4gICAgTk9ORSxcbiAgICBUSU1FLFxuICAgIFdFRUssXG4gICAgREFURVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGUlRpbWVBZ29Gb3JtYXRQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIHByaXZhdGUgUEFUVEVSTjogUmVnRXhwID0gLyhcXFd8XilpbCB5IGFcXHMqKFswLTldK3x1bmU/KVxccyoobWludXRlcz98aGV1cmVzP3xzZW1haW5lcz98am91cnM/fG1vaXN8YW5uw6llcz98YW5zPykoPz0oPzpcXFd8JCkpL2k7XG5cbiAgICBwcml2YXRlIFRBRzogc3RyaW5nID0gJ0ZSVGltZUFnb0Zvcm1hdFBhcnNlcic7XG5cbiAgICBwcml2YXRlIE9USEVSX1BBVFRFUk5TOiBSZWdFeHBbXSA9IFtcbiAgICAgICAgL1xcdy9cbiAgICBdO1xuXG4gICAgcHJpdmF0ZSBOVU1fTUFUQ0g6IG51bWJlciA9IDI7XG4gICAgcHJpdmF0ZSBVTklUX01BVENIOiBudW1iZXIgPSAzO1xuXG4gICAgcGF0dGVybigpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gdGhpcy5QQVRURVJOO1xuICAgIH1cblxuICAgIGV4dHJhY3QodGV4dDogc3RyaW5nLCByZWY6IERhdGUsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0IHwgbnVsbCB7XG4gICAgICAgIGlmIChtYXRjaC5pbmRleCA+IDAgJiYgdGV4dFttYXRjaC5pbmRleCAtIDFdLm1hdGNoKHRoaXMuT1RIRVJfUEFUVEVSTlNbMF0pKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBjb25zdCBpbmRleDogbnVtYmVyID0gbWF0Y2guaW5kZXggKyBtYXRjaFsxXS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogUGFyc2VkUmVzdWx0ID0gbmV3IFBhcnNlZFJlc3VsdCh7XG4gICAgICAgICAgICB0ZXh0OiBtYXRjaFswXS5zdWJzdHIobWF0Y2hbMV0ubGVuZ3RoLCBtYXRjaFswXS5sZW5ndGggLSBtYXRjaFsxXS5sZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCBudW06IG51bWJlciA9IG1hdGNoTnVtYmVyKG1hdGNoW3RoaXMuTlVNX01BVENIXSk7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRVbml0OiBVbml0T2ZUaW1lIHwgdW5kZWZpbmVkID0gbWF0Y2hVbml0KG1hdGNoW3RoaXMuVU5JVF9NQVRDSF0udG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGxldCBtb2RlOiBNb2RlID0gTW9kZS5OT05FO1xuICAgICAgICBjb25zdCBtb21lbnRSZWY6IE1vbWVudCA9IG1vbWVudChyZWYpO1xuXG4gICAgICAgIHN3aXRjaCAobWF0Y2hlZFVuaXQpIHtcbiAgICAgICAgICAgIGNhc2UgSE9VUjpcbiAgICAgICAgICAgICAgICBtb21lbnRSZWYuYWRkKC1udW0sICdob3VyJyk7XG4gICAgICAgICAgICAgICAgbW9kZSA9IE1vZGUuVElNRTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTUlOVVRFOlxuICAgICAgICAgICAgICAgIG1vbWVudFJlZi5hZGQoLW51bSwgJ21pbnV0ZScpO1xuICAgICAgICAgICAgICAgIG1vZGUgPSBNb2RlLlRJTUU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdFRUs6XG4gICAgICAgICAgICAgICAgbW9tZW50UmVmLmFkZCgtbnVtLCAnd2VlaycpO1xuICAgICAgICAgICAgICAgIG1vZGUgPSBNb2RlLldFRUs7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERBWTpcbiAgICAgICAgICAgICAgICBtb21lbnRSZWYuYWRkKC1udW0sICdkJyk7XG4gICAgICAgICAgICAgICAgbW9kZSA9IE1vZGUuREFURTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTU9OVEg6XG4gICAgICAgICAgICAgICAgbW9tZW50UmVmLmFkZCgtbnVtLCAnbW9udGgnKTtcbiAgICAgICAgICAgICAgICBtb2RlID0gTW9kZS5EQVRFO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBZRUFSOlxuICAgICAgICAgICAgICAgIG1vbWVudFJlZi5hZGQoLW51bSwgJ3llYXInKTtcbiAgICAgICAgICAgICAgICBtb2RlID0gTW9kZS5EQVRFO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgY2FzZSBNb2RlLlRJTUU6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KERBWSwgbW9tZW50UmVmLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1PTlRILCBtb21lbnRSZWYubW9udGgoKSArIDEpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShZRUFSLCBtb21lbnRSZWYueWVhcigpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKEhPVVIsIG1vbWVudFJlZi5ob3VyKCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTUlOVVRFLCBtb21lbnRSZWYubWludXRlKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNb2RlLkRBVEU6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihEQVksIG1vbWVudFJlZi5kYXRlKCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTU9OVEgsIG1vbWVudFJlZi5tb250aCgpICsgMSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCBtb21lbnRSZWYueWVhcigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTW9kZS5XRUVLOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShEQVksIG1vbWVudFJlZi5kYXRlKCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNT05USCwgbW9tZW50UmVmLm1vbnRoKCkgKyAxKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoWUVBUiwgbW9tZW50UmVmLnllYXIoKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KFdFRUtEQVksIG1vbWVudFJlZi5kYXkoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4iLCJpbXBvcnQgUGFyc2VyIGZyb20gJy4uL3BhcnNlcic7XG5pbXBvcnQge1BhcnNlZENvbXBvbmVudHMsIFBhcnNlZFJlc3VsdH0gZnJvbSBcIi4uLy4uL3Jlc3VsdFwiO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jaHJvbm9cIjtcbmltcG9ydCB7REFZLCBIT1VSLCBNRVJJRElFTSwgTUlOVVRFLCBNT05USCwgU0VDT05ELCBZRUFSfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgKiBhcyBtb21lbnQgZnJvbSBcIm1vbWVudFwiO1xuaW1wb3J0IHtNb21lbnR9IGZyb20gXCJtb21lbnRcIjtcblxudHlwZSBUaW1lID0gW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZSVGltZUV4cHJlc3Npb25QYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIHByaXZhdGUgUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cChcIihefFxcXFxzfFQpXCIgK1xuICAgICAgICBcIig/Oig/OlvDoGFdKVxcXFxzKik/XCIgK1xuICAgICAgICBcIihcXFxcZHsxLDJ9KD86aCk/fG1pZGl8bWludWl0KVwiICtcbiAgICAgICAgXCIoPzpcIiArXG4gICAgICAgIFwiKD86XFxcXC58XFxcXDp8XFxcXO+8mnxoKShcXFxcZHsxLDJ9KSg/Om0pP1wiICtcbiAgICAgICAgXCIoPzpcIiArXG4gICAgICAgIFwiKD86XFxcXDp8XFxcXO+8mnxtKShcXFxcZHswLDJ9KSg/OnMpP1wiICtcbiAgICAgICAgXCIpP1wiICtcbiAgICAgICAgXCIpP1wiICtcbiAgICAgICAgXCIoPzpcXFxccyooQVxcXFwuTVxcXFwufFBcXFxcLk1cXFxcLnxBTT98UE0/KSk/XCIgK1xuICAgICAgICBcIig/PVxcXFxXfCQpXCIsICdpJ1xuICAgICk7XG5cbiAgICBwcml2YXRlIEVORF9QQVRURVJOOiBSZWdFeHAgPSBuZXcgUmVnRXhwKFwiXlxcXFxzKlwiICtcbiAgICAgICAgXCIoXFxcXC18XFxcXOKAk3xcXFxcfnxcXFxc44CcfFvDoGFdfFxcXFw/KVxcXFxzKlwiICtcbiAgICAgICAgXCIoXFxcXGR7MSwyfSg/OmgpPylcIiArXG4gICAgICAgIFwiKD86XCIgK1xuICAgICAgICBcIig/OlxcXFwufFxcXFw6fFxcXFzvvJp8aCkoXFxcXGR7MSwyfSkoPzptKT9cIiArXG4gICAgICAgIFwiKD86XCIgK1xuICAgICAgICBcIig/OlxcXFwufFxcXFw6fFxcXFzvvJp8bSkoXFxcXGR7MSwyfSkoPzpzKT9cIiArXG4gICAgICAgIFwiKT9cIiArXG4gICAgICAgIFwiKT9cIiArXG4gICAgICAgIFwiKD86XFxcXHMqKEFcXFxcLk1cXFxcLnxQXFxcXC5NXFxcXC58QU0/fFBNPykpP1wiICtcbiAgICAgICAgXCIoPz1cXFxcV3wkKVwiLCAnaSdcbiAgICApO1xuXG4gICAgcHJpdmF0ZSBIT1VSX0dST1VQID0gMjtcbiAgICBwcml2YXRlIE1JTlVURV9HUk9VUCA9IDM7XG4gICAgcHJpdmF0ZSBTRUNPTkRfR1JPVVAgPSA0O1xuICAgIHByaXZhdGUgQU1fUE1fSE9VUl9HUk9VUCA9IDU7XG5cbiAgICBwcml2YXRlIFRBRzogc3RyaW5nID0gJ0ZSVGltZUV4cHJlc3Npb25QYXJzZXInO1xuXG4gICAgcHJpdmF0ZSBPVEhFUl9QQVRURVJOUzogUmVnRXhwW10gPSBbXG4gICAgICAgIC9cXHcvLFxuICAgICAgICAvXlxccyooWytcXC1dKVxccypcXGR7Myw0fSQvLFxuICAgICAgICAvXlxcZCskL1xuICAgIF07XG5cbiAgICBwYXR0ZXJuKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiB0aGlzLlBBVFRFUk47XG4gICAgfVxuXG4gICAgZXh0cmFjdCh0ZXh0OiBzdHJpbmcsIHJlZjogRGF0ZSwgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSwgb3B0OiBQYXJzZU9wdGlvbnMpOiBQYXJzZWRSZXN1bHQgfCBudWxsIHtcbiAgICAgICAgLy8gVGhpcyBwYXR0ZXJuIGNhbiBiZSBvdmVybGFwZWQgRXguIFsxMl0gQU0sIDFbMl0gQU1cbiAgICAgICAgaWYgKG1hdGNoLmluZGV4ID4gMCAmJiB0ZXh0W21hdGNoLmluZGV4IC0gMV0ubWF0Y2godGhpcy5PVEhFUl9QQVRURVJOU1swXSkpIHJldHVybiBudWxsO1xuXG4gICAgICAgIGNvbnN0IHJlZk1vbWVudDogTW9tZW50ID0gbW9tZW50KHJlZik7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBQYXJzZWRSZXN1bHQgPSBuZXcgUGFyc2VkUmVzdWx0KHtcbiAgICAgICAgICAgIHRleHQ6IG1hdGNoWzBdLnN1YnN0cmluZyhtYXRjaFsxXS5sZW5ndGgpLFxuICAgICAgICAgICAgaW5kZXg6IG1hdGNoLmluZGV4ICsgbWF0Y2hbMV0ubGVuZ3RoLFxuICAgICAgICAgICAgcmVmXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3VsdC50YWdzW3RoaXMuVEFHXSA9IHRydWU7XG5cbiAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KERBWSwgcmVmTW9tZW50LmRhdGUoKSk7XG4gICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNT05USCwgcmVmTW9tZW50Lm1vbnRoKCkgKyAxKTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KFlFQVIsIHJlZk1vbWVudC55ZWFyKCkpO1xuXG4gICAgICAgIGlmICghdGhpcy5leHRyYWN0Rmlyc3RDaHVuayhyZXN1bHQsIG1hdGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuZXh0cmFjdFNlY29uZENodW5rKHRleHQsIHJlc3VsdCkgJiYgcmVzdWx0LnRleHQubWF0Y2godGhpcy5PVEhFUl9QQVRURVJOU1syXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGV4dHJhY3RGaXJzdENodW5rKHJlc3VsdDogUGFyc2VkUmVzdWx0LCBtYXRjaDogUmVnRXhwRXhlY0FycmF5KTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IHRpbWU6IFRpbWUgfCBmYWxzZSA9IHRoaXMuZ2V0VGltZShtYXRjaCk7XG4gICAgICAgIGlmICghdGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IFtob3VyLCBtaW51dGUsIHNlY29uZCwgbWVyaWRpZW1dOiBUaW1lID0gdGltZTtcblxuICAgICAgICBpZiAoc2Vjb25kID4gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oU0VDT05ELCBzZWNvbmQpO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyAtLS0tLSBBTSAmIFBNXG4gICAgICAgIGlmIChtYXRjaFt0aGlzLkFNX1BNX0hPVVJfR1JPVVBdKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA+IDEyKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBhbXBtOiBzdHJpbmcgPSBtYXRjaFt0aGlzLkFNX1BNX0hPVVJfR1JPVVBdWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoYW1wbSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICAgICAgbWVyaWRpZW0gPSAwO1xuICAgICAgICAgICAgICAgIGlmIChob3VyID09PSAxMikgaG91ciA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFtcG0gPT09ICdwJykge1xuICAgICAgICAgICAgICAgIG1lcmlkaWVtID0gMTtcbiAgICAgICAgICAgICAgICBpZiAoaG91ciAhPT0gMTIpIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKEhPVVIsIGhvdXIpO1xuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1JTlVURSwgbWludXRlKTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPj0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihNRVJJRElFTSwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNRVJJRElFTSwgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNRVJJRElFTSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGV4dHJhY3RTZWNvbmRDaHVuayh0ZXh0OiBzdHJpbmcsIHJlc3VsdDogUGFyc2VkUmVzdWx0KTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IG1hdGNoOiBSZWdFeHBFeGVjQXJyYXkgfCBudWxsID0gdGhpcy5FTkRfUEFUVEVSTi5leGVjKHRleHQuc3Vic3RyaW5nKHJlc3VsdC5pbmRleCArIHJlc3VsdC50ZXh0Lmxlbmd0aCkpO1xuXG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhdHRlcm4gXCJZWS5ZWSAtWFhYWFwiIGlzIG1vcmUgbGlrZSB0aW1lem9uZSBvZmZzZXRcbiAgICAgICAgaWYgKG1hdGNoWzBdLm1hdGNoKHRoaXMuT1RIRVJfUEFUVEVSTlNbMV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRpbWU6IFRpbWUgfCBmYWxzZSA9IHRoaXMuZ2V0VGltZShtYXRjaCk7XG4gICAgICAgIGlmICghdGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgW2hvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtZXJpZGllbV06IFRpbWUgPSB0aW1lO1xuXG4gICAgICAgIGlmICghcmVzdWx0LmVuZCkge1xuICAgICAgICAgICAgcmVzdWx0LmVuZCA9IG5ldyBQYXJzZWRDb21wb25lbnRzKHVuZGVmaW5lZCwgcmVzdWx0LnN0YXJ0LmRhdGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2Vjb25kID4gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lbmQuYXNzaWduKFNFQ09ORCwgc2Vjb25kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tIEFNICYgUE1cbiAgICAgICAgaWYgKG1hdGNoW3RoaXMuQU1fUE1fSE9VUl9HUk9VUF0pIHtcblxuICAgICAgICAgICAgaWYgKGhvdXIgPiAxMikgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICBjb25zdCBhbXBtOiBzdHJpbmcgPSBtYXRjaFt0aGlzLkFNX1BNX0hPVVJfR1JPVVBdWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoYW1wbSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICAgICAgbWVyaWRpZW0gPSAwO1xuICAgICAgICAgICAgICAgIGlmIChob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuZW5kLmlzQ2VydGFpbihEQVkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZW5kLmltcGx5KERBWSwgcmVzdWx0LmVuZC5nZXQoREFZKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYW1wbSA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgbWVyaWRpZW0gPSAxO1xuICAgICAgICAgICAgICAgIGlmIChob3VyICE9PSAxMikgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3RhcnQuaXNDZXJ0YWluKE1FUklESUVNKSkge1xuICAgICAgICAgICAgICAgIGlmIChtZXJpZGllbSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTUVSSURJRU0sIDApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhcnQuZ2V0KEhPVVIpID09PSAxMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihIT1VSLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNRVJJRElFTSwgMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGFydC5nZXQoSE9VUikgIT09IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKEhPVVIsIHJlc3VsdC5zdGFydC5nZXQoSE9VUikgKyAxMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQudGV4dCA9IHJlc3VsdC50ZXh0ICsgbWF0Y2hbMF07XG4gICAgICAgIHJlc3VsdC5lbmQuYXNzaWduKEhPVVIsIGhvdXIpO1xuICAgICAgICByZXN1bHQuZW5kLmFzc2lnbihNSU5VVEUsIG1pbnV0ZSk7XG4gICAgICAgIGlmIChtZXJpZGllbSA+PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQuZW5kLmFzc2lnbihNRVJJRElFTSwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRBdFBNOiBib29sZWFuID0gcmVzdWx0LnN0YXJ0LmlzQ2VydGFpbihNRVJJRElFTSkgJiYgcmVzdWx0LnN0YXJ0LmdldChNRVJJRElFTSkgPT09IDE7XG4gICAgICAgICAgICBpZiAoc3RhcnRBdFBNICYmIHJlc3VsdC5zdGFydC5nZXQoSE9VUikgPiBob3VyKSB7XG4gICAgICAgICAgICAgICAgLy8gMTBwbSAtIDEgKGFtKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5lbmQuaW1wbHkoTUVSSURJRU0sIDApO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPiAxMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5lbmQuaW1wbHkoTUVSSURJRU0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5lbmQuZGF0ZSgpLmdldFRpbWUoKSA8IHJlc3VsdC5zdGFydC5kYXRlKCkuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICByZXN1bHQuZW5kLmltcGx5KERBWSwgcmVzdWx0LmVuZC5nZXQoREFZKSArIDEpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRpbWUobWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSk6IFRpbWUgfCBmYWxzZSB7XG4gICAgICAgIGxldCBzZWNvbmQ6IG51bWJlciA9IC0xO1xuICAgICAgICBsZXQgaG91cjogbnVtYmVyID0gMDtcbiAgICAgICAgbGV0IG1pbnV0ZTogbnVtYmVyID0gMDtcbiAgICAgICAgbGV0IG1lcmlkaWVtOiBudW1iZXIgPSAtMTtcblxuICAgICAgICAvLyAtLS0tLSBTZWNvbmRcbiAgICAgICAgaWYgKG1hdGNoW3RoaXMuU0VDT05EX0dST1VQXSkge1xuICAgICAgICAgICAgc2Vjb25kID0gcGFyc2VJbnQobWF0Y2hbdGhpcy5TRUNPTkRfR1JPVVBdLCAxMCk7XG4gICAgICAgICAgICBpZiAoc2Vjb25kID49IDYwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLSBIb3Vyc1xuICAgICAgICBpZiAobWF0Y2hbdGhpcy5IT1VSX0dST1VQXS50b0xvd2VyQ2FzZSgpID09PSAnbWlkaScpIHtcbiAgICAgICAgICAgIG1lcmlkaWVtID0gMTtcbiAgICAgICAgICAgIGhvdXIgPSAxMjtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaFt0aGlzLkhPVVJfR1JPVVBdLnRvTG93ZXJDYXNlKCkgPT09ICdtaW51aXQnKSB7XG4gICAgICAgICAgICBtZXJpZGllbSA9IDA7XG4gICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvdXIgPSBwYXJzZUludChtYXRjaFt0aGlzLkhPVVJfR1JPVVBdLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLSBNaW51dGVzXG4gICAgICAgIGlmIChtYXRjaFt0aGlzLk1JTlVURV9HUk9VUF0pIHtcbiAgICAgICAgICAgIG1pbnV0ZSA9IHBhcnNlSW50KG1hdGNoW3RoaXMuTUlOVVRFX0dST1VQXSwgMTApO1xuICAgICAgICB9IGVsc2UgaWYgKGhvdXIgPiAxMDApIHtcbiAgICAgICAgICAgIG1pbnV0ZSA9IGhvdXIgJSAxMDA7XG4gICAgICAgICAgICBob3VyID0gTWF0aC5mbG9vcihob3VyIC8gMTAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaW51dGUgPj0gNjApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChob3VyID4gMjQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG91ciA+PSAxMikge1xuICAgICAgICAgICAgbWVyaWRpZW0gPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtob3VyLCBtaW51dGUsIHNlY29uZCwgbWVyaWRpZW1dO1xuICAgIH1cbn0iLCJpbXBvcnQgUGFyc2VyIGZyb20gJy4uL3BhcnNlcic7XG5pbXBvcnQge1BhcnNlZFJlc3VsdH0gZnJvbSBcIi4uLy4uL3Jlc3VsdFwiO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jaHJvbm9cIjtcbmltcG9ydCB7V0VFS0RBWV9PRkZTRVR9IGZyb20gJy4uLy4uL3V0aWxzL0ZSJztcbmltcG9ydCB7TW9kaWZpZXIsIHVwZGF0ZVBhcnNlZENvbXBvbmVudH0gZnJvbSAnLi4vLi4vdXRpbHMvZ2VuZXJhbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZSV2Vla2RheVBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgcHJpdmF0ZSBQQVRURVJOOiBSZWdFeHAgPSBuZXcgUmVnRXhwKCcoXFxcXHN8XiknICtcbiAgICAgICAgJyg/Oig/OlxcXFwsfFxcXFwofFxcXFzvvIgpXFxcXHMqKT8nICtcbiAgICAgICAgJyg/OihjZSlcXFxccyopPycgK1xuICAgICAgICAnKCcgKyBPYmplY3Qua2V5cyhXRUVLREFZX09GRlNFVCkuam9pbignfCcpICsgJyknICtcbiAgICAgICAgJyg/OlxcXFxzKig/OlxcXFwsfFxcXFwpfFxcXFzvvIkpKT8nICtcbiAgICAgICAgJyg/OlxcXFxzKihkZXJuaWVyfHByb2NoYWluKVxcXFxzKik/JyArXG4gICAgICAgICcoPz1cXFxcV3wkKScsICdpJyk7XG5cbiAgICBwcml2YXRlIFBSRUZJWF9HUk9VUDogbnVtYmVyID0gMjtcbiAgICBwcml2YXRlIFdFRUtEQVlfR1JPVVA6IG51bWJlciA9IDM7XG4gICAgcHJpdmF0ZSBQT1NURklYX0dST1VQOiBudW1iZXIgPSA0O1xuXG4gICAgcHJpdmF0ZSBUQUc6IHN0cmluZyA9ICdGUldlZWtkYXlQYXJzZXInO1xuXG4gICAgcGF0dGVybigpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gdGhpcy5QQVRURVJOO1xuICAgIH1cblxuICAgIGV4dHJhY3QodGV4dDogc3RyaW5nLCByZWY6IERhdGUsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGluZGV4OiBudW1iZXIgPSBtYXRjaC5pbmRleCArIG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbWF0Y2hlZFRleHQ6IHN0cmluZyA9IG1hdGNoWzBdLnN1YnN0cihtYXRjaFsxXS5sZW5ndGgsIG1hdGNoWzBdLmxlbmd0aCAtIG1hdGNoWzFdLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogUGFyc2VkUmVzdWx0ID0gbmV3IFBhcnNlZFJlc3VsdCh7XG4gICAgICAgICAgICB0ZXh0OiBtYXRjaGVkVGV4dCxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcmVmLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBvZmZzZXQ6IG51bWJlciB8IHVuZGVmaW5lZCA9IFdFRUtEQVlfT0ZGU0VUW21hdGNoW3RoaXMuV0VFS0RBWV9HUk9VUF0udG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgY29uc3QgcHJlZml4OiBzdHJpbmcgPSBtYXRjaFt0aGlzLlBSRUZJWF9HUk9VUF07XG4gICAgICAgIGNvbnN0IHBvc3RmaXg6IHN0cmluZyA9IG1hdGNoW3RoaXMuUE9TVEZJWF9HUk9VUF07XG4gICAgICAgIGNvbnN0IG5vcm06IHN0cmluZyA9IChwcmVmaXggfHwgcG9zdGZpeCB8fCAnJykudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBsZXQgbW9kaWZpZXI6IE1vZGlmaWVyID0gTW9kaWZpZXIuVU5LTk9XTjtcbiAgICAgICAgaWYgKG5vcm09PSAnY2UnKSB7XG4gICAgICAgICAgICBtb2RpZmllciA9IE1vZGlmaWVyLlRISVM7XG4gICAgICAgIH0gZWxzZSBpZiAobm9ybSA9PT0gJ2Rlcm5pZXInKSB7XG4gICAgICAgICAgICBtb2RpZmllciA9IE1vZGlmaWVyLkxBU1Q7XG4gICAgICAgIH0gZWxzZSBpZiAobm9ybSA9PSAncHJvY2hhaW4nKSB7XG4gICAgICAgICAgICBtb2RpZmllciA9IE1vZGlmaWVyLk5FWFQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQudGFnc1t0aGlzLlRBR10gPSB0cnVlO1xuXG4gICAgICAgIHVwZGF0ZVBhcnNlZENvbXBvbmVudChyZXN1bHQsIHJlZiwgb2Zmc2V0LCBtb2RpZmllcik7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59IiwiaW1wb3J0ICogYXMgbW9tZW50IGZyb20gXCJtb21lbnRcIjtcbmltcG9ydCB7TW9tZW50fSBmcm9tIFwibW9tZW50XCI7XG5pbXBvcnQgUGFyc2VyIGZyb20gJy4uL3BhcnNlcic7XG5pbXBvcnQge1BhcnNlZFJlc3VsdH0gZnJvbSAnLi4vLi4vcmVzdWx0JztcbmltcG9ydCB7UGFyc2VPcHRpb25zfSBmcm9tIFwiLi4vLi4vY2hyb25vXCI7XG5pbXBvcnQge0RBWSwgSE9VUiwgTUVSSURJRU0sIE1PTlRILCBZRUFSfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEpQQ2FzdWFsRGF0ZVBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgcHJpdmF0ZSBQQVRURVJOOiBSZWdFeHAgPSAv5LuK5pelfOW9k+aXpXzmmKjml6V85piO5pelfOS7iuWknHzku4rlpJV85LuK5pmpfOS7iuacnS9pO1xuXG4gICAgcHJpdmF0ZSBUQUc6IHN0cmluZyA9ICdKUENhc3VhbERhdGVQYXJzZXInO1xuXG4gICAgcGF0dGVybigpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gdGhpcy5QQVRURVJOO1xuICAgIH1cblxuICAgIGV4dHJhY3QodGV4dDogc3RyaW5nLCByZWY6IERhdGUsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGluZGV4OiBudW1iZXIgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBQYXJzZWRSZXN1bHQgPSBuZXcgUGFyc2VkUmVzdWx0KHtcbiAgICAgICAgICAgIHRleHQ6IG1hdGNoWzBdLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVmTW9tZW50OiBNb21lbnQgPSBtb21lbnQocmVmKTtcbiAgICAgICAgY29uc3Qgc3RhcnRNb21lbnQ6IE1vbWVudCA9IHJlZk1vbWVudC5jbG9uZSgpO1xuICAgICAgICBjb25zdCBtYXRjaGVkVGV4dCA9IHJlc3VsdC50ZXh0O1xuXG4gICAgICAgIGlmIChtYXRjaGVkVGV4dCA9PT0gJ+S7iuWknCcgfHwgbWF0Y2hlZFRleHQgPT09ICfku4rlpJUnIHx8IG1hdGNoZWRUZXh0ID09PSAn5LuK5pmpJykge1xuICAgICAgICAgICAgLy8gTm9ybWFsbHkgbWVhbnMgdGhpcyBjb21pbmcgbWlkbmlnaHRcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShIT1VSLCAyMik7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTUVSSURJRU0sIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZWRUZXh0ID09PSAn5piO5pelJykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgbm90IFwiVG9tb3Jyb3dcIiBvbiBsYXRlIG5pZ2h0XG4gICAgICAgICAgICBpZiAocmVmTW9tZW50LmhvdXIoKSA+IDQpIHtcbiAgICAgICAgICAgICAgICBzdGFydE1vbWVudC5hZGQoMSwgJ2RheScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZWRUZXh0ID09PSAn5pio5pelJykge1xuICAgICAgICAgICAgc3RhcnRNb21lbnQuYWRkKC0xLCAnZGF5Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2hlZFRleHQubWF0Y2goXCLku4rmnJ1cIikpIHtcblxuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KEhPVVIsIDYpO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1FUklESUVNLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oREFZLCBzdGFydE1vbWVudC5kYXRlKCkpO1xuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1PTlRILCBzdGFydE1vbWVudC5tb250aCgpICsgMSk7XG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oWUVBUiwgc3RhcnRNb21lbnQueWVhcigpKTtcbiAgICAgICAgcmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0iLCJpbXBvcnQgKiBhcyBtb21lbnQgZnJvbSBcIm1vbWVudFwiO1xuaW1wb3J0IHtNb21lbnR9IGZyb20gXCJtb21lbnRcIjtcbmltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tICcuLi8uLi9yZXN1bHQnO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jaHJvbm9cIjtcbmltcG9ydCB7REFZLCBNT05USCwgWUVBUn0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHt0b0hhbmtha3V9IGZyb20gXCIuLi8uLi91dGlscy9KUFwiO1xuaW1wb3J0IHtnZXRBcHByb3ByaWF0ZVllYXJ9IGZyb20gXCIuLi8uLi91dGlscy9nZW5lcmFsXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEpQU3RhbmRhcmRQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIHByaXZhdGUgUEFUVEVSTjogUmVnRXhwID0gLyg/OijlkIx8KCjmmK3lkox85bmz5oiQKT8oWzAtOe+8kC3vvJldezIsNH0pKSnlubRcXHMqKT8oWzAtOe+8kC3vvJldezEsMn0p5pyIXFxzKihbMC0577yQLe+8mV17MSwyfSnml6UvaTtcblxuICAgIHByaXZhdGUgWUVBUl9HUk9VUDogbnVtYmVyID0gMjtcbiAgICBwcml2YXRlIEVSQV9HUk9VUDogbnVtYmVyID0gMztcbiAgICBwcml2YXRlIFlFQVJfTlVNQkVSX0dST1VQOiBudW1iZXIgPSA0O1xuICAgIHByaXZhdGUgTU9OVEhfR1JPVVA6IG51bWJlciA9IDU7XG4gICAgcHJpdmF0ZSBEQVlfR1JPVVA6IG51bWJlciA9IDY7XG5cbiAgICBwcml2YXRlIE9USEVSX1BBVFRFUk5TOiBSZWdFeHBbXSA9IFtcbiAgICAgICAgL+WQjOW5tC9cbiAgICBdO1xuXG4gICAgcHJpdmF0ZSBUQUc6IHN0cmluZyA9ICdKUFN0YW5kYXJkUGFyc2VyJztcblxuICAgIHBhdHRlcm4oKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuUEFUVEVSTjtcbiAgICB9XG5cbiAgICBleHRyYWN0KHRleHQ6IHN0cmluZywgcmVmOiBEYXRlLCBtYXRjaDogUmVnRXhwRXhlY0FycmF5LCBvcHQ6IFBhcnNlT3B0aW9ucyk6IFBhcnNlZFJlc3VsdCB8IG51bGwge1xuICAgICAgICBjb25zdCBpbmRleDogbnVtYmVyID0gbWF0Y2guaW5kZXg7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogUGFyc2VkUmVzdWx0ID0gbmV3IFBhcnNlZFJlc3VsdCh7XG4gICAgICAgICAgICB0ZXh0OiBtYXRjaFswXSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcmVmXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlc3VsdC50YWdzW3RoaXMuVEFHXSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHN0YXJ0TW9tZW50OiBNb21lbnQgPSBtb21lbnQocmVmKTtcblxuICAgICAgICBjb25zdCBtb250aDogbnVtYmVyID0gcGFyc2VJbnQodG9IYW5rYWt1KG1hdGNoW3RoaXMuTU9OVEhfR1JPVVBdKSwgMTApO1xuICAgICAgICBjb25zdCBkYXk6IG51bWJlciA9IHBhcnNlSW50KHRvSGFua2FrdShtYXRjaFt0aGlzLkRBWV9HUk9VUF0pLCAxMCk7XG5cbiAgICAgICAgc3RhcnRNb21lbnQuc2V0KCdkYXRlJywgZGF5KTtcbiAgICAgICAgc3RhcnRNb21lbnQuc2V0KCdtb250aCcsIG1vbnRoIC0gMSk7XG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oREFZLCBzdGFydE1vbWVudC5kYXRlKCkpO1xuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1PTlRILCBzdGFydE1vbWVudC5tb250aCgpICsgMSk7XG5cbiAgICAgICAgY29uc3QgbWF0Y2hlZFllYXI6IHN0cmluZyA9IG1hdGNoW3RoaXMuWUVBUl9HUk9VUF0gfHwgJyc7XG5cbiAgICAgICAgaWYgKG1hdGNoZWRZZWFyLm1hdGNoKHRoaXMuT1RIRVJfUEFUVEVSTlNbMF0pKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKFlFQVIsIHN0YXJ0TW9tZW50LnllYXIoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2hlZFllYXIpIHtcbiAgICAgICAgICAgIGxldCB5ZWFyOiBudW1iZXIgPSBwYXJzZUludCh0b0hhbmtha3UobWF0Y2hbdGhpcy5ZRUFSX05VTUJFUl9HUk9VUF0pLCAxMCk7XG4gICAgICAgICAgICBpZiAobWF0Y2hbdGhpcy5FUkFfR1JPVVBdID09PSAn5bmz5oiQJykge1xuICAgICAgICAgICAgICAgIHllYXIgKz0gMTk4ODtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbdGhpcy5FUkFfR1JPVVBdID09PSAn5pit5ZKMJykge1xuICAgICAgICAgICAgICAgIHllYXIgKz0gMTkyNTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCB5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldEFwcHJvcHJpYXRlWWVhcihyZXN1bHQuc3RhcnQsIHJlZik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbiIsImltcG9ydCAqIGFzIG1vbWVudCBmcm9tIFwibW9tZW50XCI7XG5pbXBvcnQge01vbWVudH0gZnJvbSBcIm1vbWVudFwiO1xuaW1wb3J0IFBhcnNlciBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHtQYXJzZWRSZXN1bHR9IGZyb20gJy4uLy4uL3Jlc3VsdCc7XG5pbXBvcnQge1BhcnNlT3B0aW9uc30gZnJvbSBcIi4uLy4uL2Nocm9ub1wiO1xuaW1wb3J0IHtEQVksIEhPVVIsIE1FUklESUVNLCBNSUxMSVNFQ09ORCwgTUlOVVRFLCBNT05USCwgU0VDT05ELCBZRUFSfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFpISGFudENhc3VhbERhdGVQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIHByaXZhdGUgUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cChcbiAgICAgICAgJyjogIzlrrZ856uLKD865Yi7fOWNsyl85Y2z5Yi7KXwnICtcbiAgICAgICAgJyjku4p85piOfOiBvXzmmKh85bCLfOeQtCko5pepfOacnXzmmZopfCcgK1xuICAgICAgICAnKOS4iig/OuWNiHzmmZ0pfOacnSg/OuaXqSl85pepKD865LiKKXzkuIsoPzrljYh85pmdKXzmmY8oPzrmmZ0pfOaZmig/OuS4iil85aScKD865pmaKT985LitKD865Y2IKXzlh4woPzrmmagpKXwnICtcbiAgICAgICAgJyjku4p85piOfOiBvXzmmKh85bCLfOeQtCkoPzrml6V85aSpKScgK1xuICAgICAgICAnKD86W1xcXFxzfCx877yMXSopJyArXG4gICAgICAgICcoPzoo5LiKKD865Y2IfOaZnSl85pydKD865pepKXzml6koPzrkuIopfOS4iyg/OuWNiHzmmZ0pfOaZjyg/OuaZnSl85pmaKD865LiKKXzlpJwoPzrmmZopP3zkuK0oPzrljYgpfOWHjCg/OuaZqCkpKT8nLCAnaScpO1xuXG4gICAgcHJpdmF0ZSBOT1dfR1JPVVA6IG51bWJlciA9IDE7XG4gICAgcHJpdmF0ZSBEQVlfR1JPVVBfMTogbnVtYmVyID0gMjtcbiAgICBwcml2YXRlIFRJTUVfR1JPVVBfMTogbnVtYmVyID0gMztcbiAgICBwcml2YXRlIFRJTUVfR1JPVVBfMjogbnVtYmVyID0gNDtcbiAgICBwcml2YXRlIERBWV9HUk9VUF8zOiBudW1iZXIgPSA1O1xuICAgIHByaXZhdGUgVElNRV9HUk9VUF8zOiBudW1iZXIgPSA2O1xuXG5cbiAgICBwcml2YXRlIFRBRzogc3RyaW5nID0gJ1pIQ2FzdWFsRGF0ZVBhcnNlcic7XG5cbiAgICBwYXR0ZXJuKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiB0aGlzLlBBVFRFUk47XG4gICAgfVxuXG4gICAgZXh0cmFjdCh0ZXh0OiBzdHJpbmcsIHJlZjogRGF0ZSwgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSwgb3B0OiBQYXJzZU9wdGlvbnMpOiBQYXJzZWRSZXN1bHQgfCBudWxsIHtcbiAgICAgICAgY29uc3QgaW5kZXg6IG51bWJlciA9IG1hdGNoLmluZGV4O1xuICAgICAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFJlc3VsdCA9IG5ldyBQYXJzZWRSZXN1bHQoe1xuICAgICAgICAgICAgdGV4dDogbWF0Y2hbMF0sXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIHJlZlxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByZWZNb21lbnQ6IE1vbWVudCA9IG1vbWVudChyZWYpO1xuICAgICAgICBjb25zdCBzdGFydE1vbWVudDogTW9tZW50ID0gcmVmTW9tZW50LmNsb25lKCk7XG5cbiAgICAgICAgaWYgKG1hdGNoW3RoaXMuTk9XX0dST1VQXSkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KEhPVVIsIHJlZk1vbWVudC5ob3VyKCkpO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1JTlVURSwgcmVmTW9tZW50Lm1pbnV0ZSgpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShTRUNPTkQsIHJlZk1vbWVudC5zZWNvbmQoKSk7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTUlMTElTRUNPTkQsIHJlZk1vbWVudC5taWxsaXNlY29uZCgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaFt0aGlzLkRBWV9HUk9VUF8xXSkge1xuICAgICAgICAgICAgY29uc3QgZGF5MTogc3RyaW5nID0gbWF0Y2hbdGhpcy5EQVlfR1JPVVBfMV07XG4gICAgICAgICAgICBjb25zdCB0aW1lMTogc3RyaW5nID0gbWF0Y2hbdGhpcy5USU1FX0dST1VQXzFdO1xuXG4gICAgICAgICAgICBpZiAoZGF5MSA9PT0gJ+aYjicgfHwgZGF5MSA9PT0gJ+iBvScpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBub3QgXCJUb21vcnJvd1wiIG9uIGxhdGUgbmlnaHRcbiAgICAgICAgICAgICAgICBpZiAocmVmTW9tZW50LmhvdXIoKSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNb21lbnQuYWRkKDEsICdkYXknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRheTEgPT09ICfmmKgnIHx8IGRheTEgPT09ICflsIsnIHx8IGRheTEgPT09ICfnkLQnKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRNb21lbnQuYWRkKC0xLCAnZGF5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZTEgPT09ICfml6knIHx8IHRpbWUxID09PSAn5pydJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShIT1VSLCA2KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZTEgPT09ICfmmZonKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KEhPVVIsIDIyKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTUVSSURJRU0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoW3RoaXMuVElNRV9HUk9VUF8yXSkge1xuICAgICAgICAgICAgY29uc3QgdGltZVN0cmluZzI6IHN0cmluZyA9IG1hdGNoW3RoaXMuVElNRV9HUk9VUF8yXTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWUyOiBzdHJpbmcgPSB0aW1lU3RyaW5nMlswXTtcbiAgICAgICAgICAgIGlmICh0aW1lMiA9PT0gJ+aXqScgfHwgdGltZTIgPT09ICfmnJ0nIHx8IHRpbWUyID09PSAn5LiKJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShIT1VSLCA2KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZTIgPT09ICfkuIsnIHx8IHRpbWUyID09PSAn5pmPJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShIT1VSLCAxNSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1FUklESUVNLCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZTIgPT09ICfkuK0nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KEhPVVIsIDEyKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTUVSSURJRU0sIDEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lMiA9PT0gJ+WknCcgfHwgdGltZTIgPT09ICfmmZonKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KEhPVVIsIDIyKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTUVSSURJRU0sIDEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lMiA9PT0gJ+WHjCcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoSE9VUiwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaFt0aGlzLkRBWV9HUk9VUF8zXSkge1xuICAgICAgICAgICAgY29uc3QgZGF5Mzogc3RyaW5nID0gbWF0Y2hbdGhpcy5EQVlfR1JPVVBfM107XG5cbiAgICAgICAgICAgIGlmIChkYXkzID09PSAn5piOJyB8fCBkYXkzID09PSAn6IG9Jykge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIG5vdCBcIlRvbW9ycm93XCIgb24gbGF0ZSBuaWdodFxuICAgICAgICAgICAgICAgIGlmIChyZWZNb21lbnQuaG91cigpID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydE1vbWVudC5hZGQoMSwgJ2RheScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF5MyA9PT0gJ+aYqCcgfHwgZGF5MyA9PT0gJ+WwiycgfHwgZGF5MyA9PT0gJ+eQtCcpIHtcbiAgICAgICAgICAgICAgICBzdGFydE1vbWVudC5hZGQoLTEsICdkYXknKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBjb25zdCB0aW1lU3RyaW5nMzogc3RyaW5nID0gbWF0Y2hbdGhpcy5USU1FX0dST1VQXzNdO1xuICAgICAgICAgICAgaWYgKHRpbWVTdHJpbmczKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZTM6IHN0cmluZyA9IHRpbWVTdHJpbmczWzBdO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lMyA9PT0gJ+aXqScgfHwgdGltZTMgPT09ICfmnJ0nIHx8IHRpbWUzID09PSAn5LiKJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoSE9VUiwgNik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lMyA9PT0gJ+S4iycgfHwgdGltZTMgPT09ICfmmY8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShIT1VSLCAxNSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNRVJJRElFTSwgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lMyA9PT0gJ+S4rScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KEhPVVIsIDEyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1FUklESUVNLCAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRpbWUzID09PSAn5aScJyB8fCB0aW1lMyA9PT0gJ+aZmicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KEhPVVIsIDIyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KE1FUklESUVNLCAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRpbWUzID09PSAn5YeMJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoSE9VUiwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihEQVksIHN0YXJ0TW9tZW50LmRhdGUoKSk7XG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTU9OVEgsIHN0YXJ0TW9tZW50Lm1vbnRoKCkgKyAxKTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCBzdGFydE1vbWVudC55ZWFyKCkpO1xuICAgICAgICByZXN1bHQudGFnc1t0aGlzLlRBR10gPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSIsImltcG9ydCAqIGFzIG1vbWVudCBmcm9tIFwibW9tZW50XCI7XG5pbXBvcnQge01vbWVudH0gZnJvbSBcIm1vbWVudFwiO1xuaW1wb3J0IFBhcnNlciBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHtQYXJzZWRSZXN1bHR9IGZyb20gJy4uLy4uL3Jlc3VsdCc7XG5pbXBvcnQge1BhcnNlT3B0aW9uc30gZnJvbSBcIi4uLy4uL2Nocm9ub1wiO1xuaW1wb3J0IHtEQVksIE1PTlRILCBZRUFSfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQge05VTUJFUiwgemhTdHJpbmdUb051bWJlciwgemhTdHJpbmdUb1llYXJ9IGZyb20gXCIuLi8uLi91dGlscy9aSC1IYW50XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFpISGFudERhdGVQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIHByaXZhdGUgUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cChcbiAgICAgICAgJyhcXFxcZHsyLDR9fFsnICsgT2JqZWN0LmtleXMoTlVNQkVSKS5qb2luKCcnKSArICddezIsNH0pPycgK1xuICAgICAgICAnKD86XFxcXHMqKScgK1xuICAgICAgICAnKD865bm0KT8nICtcbiAgICAgICAgJyg/OltcXFxcc3wsfO+8jF0qKScgK1xuICAgICAgICAnKFxcXFxkezEsMn18WycgKyBPYmplY3Qua2V5cyhOVU1CRVIpLmpvaW4oJycpICsgJ117MSwyfSknICtcbiAgICAgICAgJyg/OlxcXFxzKiknICtcbiAgICAgICAgJyg/OuaciCknICtcbiAgICAgICAgJyg/OlxcXFxzKiknICtcbiAgICAgICAgJyhcXFxcZHsxLDJ9fFsnICsgT2JqZWN0LmtleXMoTlVNQkVSKS5qb2luKCcnKSArICddezEsMn0pPycgK1xuICAgICAgICAnKD86XFxcXHMqKScgK1xuICAgICAgICAnKD865pelfOiZnyk/J1xuICAgICk7XG5cbiAgICBwcml2YXRlIFlFQVJfR1JPVVA6IG51bWJlciA9IDE7XG4gICAgcHJpdmF0ZSBNT05USF9HUk9VUDogbnVtYmVyID0gMjtcbiAgICBwcml2YXRlIERBWV9HUk9VUDogbnVtYmVyID0gMztcblxuXG4gICAgcHJpdmF0ZSBUQUc6IHN0cmluZyA9ICdaSERhdGVQYXJzZXInO1xuXG4gICAgcGF0dGVybigpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gdGhpcy5QQVRURVJOO1xuICAgIH1cblxuICAgIGV4dHJhY3QodGV4dDogc3RyaW5nLCByZWY6IERhdGUsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGluZGV4OiBudW1iZXIgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBQYXJzZWRSZXN1bHQgPSBuZXcgUGFyc2VkUmVzdWx0KHtcbiAgICAgICAgICAgIHRleHQ6IG1hdGNoWzBdLFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcblxuICAgICAgICBjb25zdCBzdGFydE1vbWVudDogTW9tZW50ID0gbW9tZW50KHJlZik7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRNb250aCA9IG1hdGNoW3RoaXMuTU9OVEhfR1JPVVBdO1xuICAgICAgICBjb25zdCBtYXRjaGVkRGF5ID0gbWF0Y2hbdGhpcy5EQVlfR1JPVVBdO1xuICAgICAgICBjb25zdCBtYXRjaGVkWWVhciA9IG1hdGNoW3RoaXMuWUVBUl9HUk9VUF07XG5cbiAgICAgICAgbGV0IG1vbnRoOiBudW1iZXIgPSBwYXJzZUludChtYXRjaGVkTW9udGgsIDEwKTtcbiAgICAgICAgaWYgKGlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgbW9udGggPSB6aFN0cmluZ1RvTnVtYmVyKG1hdGNoZWRNb250aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1PTlRILCBtb250aCk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWREYXkpIHtcbiAgICAgICAgICAgIGxldCBkYXk6IG51bWJlciA9IHBhcnNlSW50KG1hdGNoZWREYXksIDEwKTtcbiAgICAgICAgICAgIGlmIChpc05hTihkYXkpKSB7XG4gICAgICAgICAgICAgICAgZGF5ID0gemhTdHJpbmdUb051bWJlcihtYXRjaGVkRGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oREFZLCBkYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihEQVksIHN0YXJ0TW9tZW50LmRhdGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2hlZFllYXIpIHtcbiAgICAgICAgICAgIGxldCB5ZWFyOiBudW1iZXIgPSBwYXJzZUludChtYXRjaGVkWWVhciwgMTApO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHllYXIpKSB7XG4gICAgICAgICAgICAgICAgeWVhciA9IHpoU3RyaW5nVG9ZZWFyKG1hdGNoZWRZZWFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oWUVBUiwgeWVhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKFlFQVIsIHN0YXJ0TW9tZW50LnllYXIoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0iLCJpbXBvcnQgKiBhcyBtb21lbnQgZnJvbSBcIm1vbWVudFwiO1xuaW1wb3J0IHtNb21lbnR9IGZyb20gXCJtb21lbnRcIjtcbmltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tICcuLi8uLi9yZXN1bHQnO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jaHJvbm9cIjtcbmltcG9ydCB7REFZLCBIT1VSLCBNSU5VVEUsIE1PTlRILCBTRUNPTkQsIFlFQVJ9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCB7TlVNQkVSLCB6aFN0cmluZ1RvTnVtYmVyfSBmcm9tIFwiLi4vLi4vdXRpbHMvWkgtSGFudFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBaSEhhbnREZWFkbGluZUZvcm1hdFBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgcHJpdmF0ZSBQQVRURVJOOiBSZWdFeHAgPSBuZXcgUmVnRXhwKFxuICAgICAgICAnKFxcXFxkK3xbJyArIE9iamVjdC5rZXlzKE5VTUJFUikuam9pbignJykgKyAnXSt85Y2KfOW5vikoPzpcXFxccyopJyArXG4gICAgICAgICcoPzrlgIspPycgK1xuICAgICAgICAnKOenkig/OumQmCk/fOWIhumQmHzlsI/mmYJ86ZCYfOaXpXzlpKl85pif5pyffOemruaLnHzmnIh85bm0KScgK1xuICAgICAgICAnKD86KD865LmLfOmBjik/5b6MfCg/OuS5iyk/5YWnKScsICdpJ1xuICAgICk7XG5cbiAgICBwcml2YXRlIE5VTUJFUl9HUk9VUDogbnVtYmVyID0gMTtcbiAgICBwcml2YXRlIFVOSVRfR1JPVVA6IG51bWJlciA9IDI7XG5cblxuICAgIHByaXZhdGUgVEFHOiBzdHJpbmcgPSAnWkhEZWFkbGluZUZvcm1hdFBhcnNlcic7XG5cbiAgICBwYXR0ZXJuKCk6IFJlZ0V4cCB7XG4gICAgICAgIHJldHVybiB0aGlzLlBBVFRFUk47XG4gICAgfVxuXG4gICAgZXh0cmFjdCh0ZXh0OiBzdHJpbmcsIHJlZjogRGF0ZSwgbWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSwgb3B0OiBQYXJzZU9wdGlvbnMpOiBQYXJzZWRSZXN1bHQgfCBudWxsIHtcbiAgICAgICAgY29uc3QgaW5kZXg6IG51bWJlciA9IG1hdGNoLmluZGV4O1xuICAgICAgICBjb25zdCByZXN1bHQ6IFBhcnNlZFJlc3VsdCA9IG5ldyBQYXJzZWRSZXN1bHQoe1xuICAgICAgICAgICAgdGV4dDogbWF0Y2hbMF0sXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIHJlZlxuICAgICAgICB9KTtcblxuICAgICAgICByZXN1bHQudGFnc1t0aGlzLlRBR10gPSB0cnVlO1xuXG4gICAgICAgIGNvbnN0IG1hdGNoZWROdW1iZXI6IHN0cmluZyA9IG1hdGNoW3RoaXMuTlVNQkVSX0dST1VQXTtcbiAgICAgICAgbGV0IG51bWJlcjogbnVtYmVyID0gcGFyc2VJbnQobWF0Y2hlZE51bWJlciwgMTApO1xuXG4gICAgICAgIGlmIChpc05hTihudW1iZXIpKSB7XG4gICAgICAgICAgICBudW1iZXIgPSB6aFN0cmluZ1RvTnVtYmVyKG1hdGNoZWROdW1iZXIpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZE51bWJlciA9PT0gJ+W5vicpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyID0gMztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZWROdW1iZXIgPT09ICfljYonKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bWJlciA9IDAuNTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXRlOiBNb21lbnQgPSBtb21lbnQocmVmKTtcbiAgICAgICAgY29uc3QgdW5pdEFiYnI6IHN0cmluZyA9IG1hdGNoW3RoaXMuVU5JVF9HUk9VUF1bMF07XG4gICAgICAgIGxldCBkYXRlTW9kZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdEFiYnIpIHtcbiAgICAgICAgICAgIGNhc2UgJ+aXpSc6XG4gICAgICAgICAgICBjYXNlICflpKknOlxuICAgICAgICAgICAgICAgIGRhdGUuYWRkKG51bWJlciwgJ2QnKTtcbiAgICAgICAgICAgICAgICBkYXRlTW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICfmmJ8nOlxuICAgICAgICAgICAgY2FzZSAn56auJzpcbiAgICAgICAgICAgICAgICBkYXRlLmFkZChudW1iZXIgKiA3LCAnZCcpO1xuICAgICAgICAgICAgICAgIGRhdGVNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ+aciCc6XG4gICAgICAgICAgICAgICAgZGF0ZS5hZGQobnVtYmVyLCAnbW9udGgnKTtcbiAgICAgICAgICAgICAgICBkYXRlTW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICflubQnOlxuICAgICAgICAgICAgICAgIGRhdGUuYWRkKG51bWJlciwgJ3llYXInKTtcbiAgICAgICAgICAgICAgICBkYXRlTW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICfnp5InOlxuICAgICAgICAgICAgICAgIGRhdGUuYWRkKG51bWJlciwgJ3NlY29uZCcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAn5YiGJzpcbiAgICAgICAgICAgICAgICBkYXRlLmFkZChudW1iZXIsICdtaW51dGUnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ+Wwjyc6XG4gICAgICAgICAgICBjYXNlICfpkJgnOlxuICAgICAgICAgICAgICAgIGRhdGUuYWRkKG51bWJlciwgJ2hvdXInKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0ZU1vZGUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oWUVBUiwgZGF0ZS55ZWFyKCkpO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihNT05USCwgZGF0ZS5tb250aCgpICsgMSk7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKERBWSwgZGF0ZS5kYXRlKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KFlFQVIsIGRhdGUueWVhcigpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNT05USCwgZGF0ZS5tb250aCgpICsgMSk7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoREFZLCBkYXRlLmRhdGUoKSk7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKEhPVVIsIGRhdGUuaG91cigpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTUlOVVRFLCBkYXRlLm1pbnV0ZSgpKTtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oU0VDT05ELCBkYXRlLnNlY29uZCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSIsImltcG9ydCBQYXJzZXIgZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7UGFyc2VkQ29tcG9uZW50cywgUGFyc2VkUmVzdWx0fSBmcm9tIFwiLi4vLi4vcmVzdWx0XCI7XG5pbXBvcnQge1BhcnNlT3B0aW9uc30gZnJvbSBcIi4uLy4uL2Nocm9ub1wiO1xuaW1wb3J0IHtEQVksIEhPVVIsIE1FUklESUVNLCBNSU5VVEUsIE1PTlRILCBTRUNPTkQsIFlFQVJ9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCAqIGFzIG1vbWVudCBmcm9tIFwibW9tZW50XCI7XG5pbXBvcnQge01vbWVudH0gZnJvbSBcIm1vbWVudFwiO1xuaW1wb3J0IHtOVU1CRVIsIHpoU3RyaW5nVG9OdW1iZXJ9IGZyb20gXCIuLi8uLi91dGlscy9aSC1IYW50XCI7XG5cbnR5cGUgVGltZSA9IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBaSEhhbnRUaW1lRXhwcmVzc2lvblBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgcHJpdmF0ZSBQQVRURVJOOiBSZWdFeHAgPSBuZXcgUmVnRXhwKCcoPzrnlLF85b6efOiHqik/JyArXG4gICAgICAgICcoPzonICtcbiAgICAgICAgJyjku4p85piOfOiBvXzmmKh85bCLfOeQtCko5pepfOacnXzmmZopfCcgK1xuICAgICAgICAnKOS4iig/OuWNiHzmmZ0pfOacnSg/OuaXqSl85pepKD865LiKKXzkuIsoPzrljYh85pmdKXzmmY8oPzrmmZ0pfOaZmig/OuS4iil85aScKD865pmaKT985LitKD865Y2IKXzlh4woPzrmmagpKXwnICtcbiAgICAgICAgJyjku4p85piOfOiBvXzmmKh85bCLfOeQtCkoPzrml6V85aSpKScgK1xuICAgICAgICAnKD86W1xcXFxzLO+8jF0qKScgK1xuICAgICAgICAnKD86KOS4iig/OuWNiHzmmZ0pfOacnSg/OuaXqSl85pepKD865LiKKXzkuIsoPzrljYh85pmdKXzmmY8oPzrmmZ0pfOaZmig/OuS4iil85aScKD865pmaKT985LitKD865Y2IKXzlh4woPzrmmagpKSk/JyArXG4gICAgICAgICcpPycgK1xuICAgICAgICAnKD86W1xcXFxzLO+8jF0qKScgK1xuICAgICAgICAnKD86KFxcXFxkK3xbJyArIE9iamVjdC5rZXlzKE5VTUJFUikuam9pbignJykgKyAnXSspKD86XFxcXHMqKSg/Oum7nnzmmYJ8OnzvvJopJyArXG4gICAgICAgICcoPzpcXFxccyopJyArXG4gICAgICAgICcoXFxcXGQrfOWNinzmraN85pW0fFsnICsgT2JqZWN0LmtleXMoTlVNQkVSKS5qb2luKCcnKSArICddKyk/KD86XFxcXHMqKSg/OuWIhnw6fO+8mik/JyArXG4gICAgICAgICcoPzpcXFxccyopJyArXG4gICAgICAgICcoXFxcXGQrfFsnICsgT2JqZWN0LmtleXMoTlVNQkVSKS5qb2luKCcnKSArICddKyk/KD86XFxcXHMqKSg/Ouenkik/KScgK1xuICAgICAgICAnKD86XFxcXHMqKEFcXC5NXFwufFBcXC5NXFwufEFNP3xQTT8pKT8nLCAnaScpO1xuXG4gICAgcHJpdmF0ZSBFTkRfUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cCgnKD86XFxcXHMqKD865YiwfOiHs3xcXFxcLXxcXFxc4oCTfFxcXFx+fFxcXFzjgJwpXFxcXHMqKScgK1xuICAgICAgICAnKD86JyArXG4gICAgICAgICco5LuKfOaYjnzogb185piofOWwi3znkLQpKOaXqXzmnJ185pmaKXwnICtcbiAgICAgICAgJyjkuIooPzrljYh85pmdKXzmnJ0oPzrml6kpfOaXqSg/OuS4iil85LiLKD865Y2IfOaZnSl85pmPKD865pmdKXzmmZooPzrkuIopfOWknCg/OuaZmik/fOS4rSg/OuWNiCl85YeMKD865pmoKSl8JyArXG4gICAgICAgICco5LuKfOaYjnzogb185piofOWwi3znkLQpKD865pelfOWkqSknICtcbiAgICAgICAgJyg/OltcXFxccyzvvIxdKiknICtcbiAgICAgICAgJyg/OijkuIooPzrljYh85pmdKXzmnJ0oPzrml6kpfOaXqSg/OuS4iil85LiLKD865Y2IfOaZnSl85pmPKD865pmdKXzmmZooPzrkuIopfOWknCg/OuaZmik/fOS4rSg/OuWNiCl85YeMKD865pmoKSkpPycgK1xuICAgICAgICAnKT8nICtcbiAgICAgICAgJyg/OltcXFxccyzvvIxdKiknICtcbiAgICAgICAgJyg/OihcXFxcZCt8WycgKyBPYmplY3Qua2V5cyhOVU1CRVIpLmpvaW4oJycpICsgJ10rKSg/OlxcXFxzKikoPzrpu5585pmCfDp877yaKScgK1xuICAgICAgICAnKD86XFxcXHMqKScgK1xuICAgICAgICAnKFxcXFxkK3zljYp85q2jfOaVtHxbJyArIE9iamVjdC5rZXlzKE5VTUJFUikuam9pbignJykgKyAnXSspPyg/OlxcXFxzKikoPzrliIZ8OnzvvJopPycgK1xuICAgICAgICAnKD86XFxcXHMqKScgK1xuICAgICAgICAnKFxcXFxkK3xbJyArIE9iamVjdC5rZXlzKE5VTUJFUikuam9pbignJykgKyAnXSspPyg/OlxcXFxzKikoPzrnp5IpPyknICtcbiAgICAgICAgJyg/OlxcXFxzKihBXFwuTVxcLnxQXFwuTVxcLnxBTT98UE0/KSk/JywgJ2knKTtcblxuICAgIHByaXZhdGUgREFZX0dST1VQXzE6IG51bWJlciA9IDE7XG4gICAgcHJpdmF0ZSBaSF9BTV9QTV9IT1VSX0dST1VQXzE6IG51bWJlciA9IDI7XG4gICAgcHJpdmF0ZSBaSF9BTV9QTV9IT1VSX0dST1VQXzI6IG51bWJlciA9IDM7XG4gICAgcHJpdmF0ZSBEQVlfR1JPVVBfMzogbnVtYmVyID0gNDtcbiAgICBwcml2YXRlIFpIX0FNX1BNX0hPVVJfR1JPVVBfMzogbnVtYmVyID0gNTtcbiAgICBwcml2YXRlIEhPVVJfR1JPVVA6IG51bWJlciA9IDY7XG4gICAgcHJpdmF0ZSBNSU5VVEVfR1JPVVA6IG51bWJlciA9IDc7XG4gICAgcHJpdmF0ZSBTRUNPTkRfR1JPVVA6IG51bWJlciA9IDg7XG4gICAgcHJpdmF0ZSBBTV9QTV9IT1VSX0dST1VQOiBudW1iZXIgPSA5O1xuXG4gICAgcHJpdmF0ZSBUQUc6IHN0cmluZyA9ICdaSFRpbWVFeHByZXNzaW9uUGFyc2VyJztcblxuICAgIHByaXZhdGUgT1RIRVJfUEFUVEVSTlM6IFJlZ0V4cFtdID0gW1xuICAgICAgICAvXFx3LyxcbiAgICAgICAgL15cXHMqKFsrXFwtXSlcXHMqXFxkezMsNH0kLyxcbiAgICAgICAgL15cXGQrJC9cbiAgICBdO1xuXG4gICAgcGF0dGVybigpOiBSZWdFeHAge1xuICAgICAgICByZXR1cm4gdGhpcy5QQVRURVJOO1xuICAgIH1cblxuICAgIGV4dHJhY3QodGV4dDogc3RyaW5nLCByZWY6IERhdGUsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0IHwgbnVsbCB7XG4gICAgICAgIC8vIFRoaXMgcGF0dGVybiBjYW4gYmUgb3ZlcmxhcGVkIEV4LiBbMTJdIEFNLCAxWzJdIEFNXG4gICAgICAgIGlmIChtYXRjaC5pbmRleCA+IDAgJiYgdGV4dFttYXRjaC5pbmRleCAtIDFdLm1hdGNoKHRoaXMuT1RIRVJfUEFUVEVSTlNbMF0pKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBjb25zdCByZWZNb21lbnQ6IE1vbWVudCA9IG1vbWVudChyZWYpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdDogUGFyc2VkUmVzdWx0ID0gbmV3IFBhcnNlZFJlc3VsdCh7XG4gICAgICAgICAgICB0ZXh0OiBtYXRjaFswXSxcbiAgICAgICAgICAgIGluZGV4OiBtYXRjaC5pbmRleCxcbiAgICAgICAgICAgIHJlZlxuICAgICAgICB9KTtcblxuICAgICAgICByZXN1bHQudGFnc1t0aGlzLlRBR10gPSB0cnVlO1xuXG4gICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShEQVksIHJlZk1vbWVudC5kYXRlKCkpO1xuICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTU9OVEgsIHJlZk1vbWVudC5tb250aCgpICsgMSk7XG4gICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShZRUFSLCByZWZNb21lbnQueWVhcigpKTtcblxuICAgICAgICBjb25zdCBzdGFydE1vbWVudDogTW9tZW50ID0gcmVmTW9tZW50LmNsb25lKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmV4dHJhY3RGaXJzdENodW5rKHJlc3VsdCwgbWF0Y2gsIHJlZk1vbWVudCwgc3RhcnRNb21lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVuZE1vbWVudCA9IHN0YXJ0TW9tZW50LmNsb25lKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmV4dHJhY3RTZWNvbmRDaHVuayh0ZXh0LCByZXN1bHQsIHJlZk1vbWVudCwgZW5kTW9tZW50KSAmJiByZXN1bHQudGV4dC5tYXRjaCh0aGlzLk9USEVSX1BBVFRFUk5TWzJdKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHByaXZhdGUgZXh0cmFjdEZpcnN0Q2h1bmsocmVzdWx0OiBQYXJzZWRSZXN1bHQsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIHJlZk1vbWVudDogTW9tZW50LCBzdGFydE1vbWVudDogTW9tZW50KTogYm9vbGVhbiB7XG4gICAgICAgIHRoaXMuZ2V0RGF5KG1hdGNoLCByZXN1bHQuc3RhcnQsIHJlZk1vbWVudCwgc3RhcnRNb21lbnQpO1xuXG4gICAgICAgIGNvbnN0IHRpbWU6IFRpbWUgfCBmYWxzZSA9IHRoaXMuZ2V0VGltZShtYXRjaCk7XG4gICAgICAgIGlmICghdGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IFtob3VyLCBtaW51dGUsIHNlY29uZCwgbWVyaWRpZW1dOiBUaW1lID0gdGltZTtcblxuICAgICAgICBpZiAoc2Vjb25kID4gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oU0VDT05ELCBzZWNvbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZ290TWVyaWRpZW06IFtudW1iZXIsIG51bWJlcl0gfCBudWxsID0gdGhpcy5nZXRNZXJpZGllbShtYXRjaCwgbWVyaWRpZW0sIGhvdXIpO1xuICAgICAgICBpZiAoIWdvdE1lcmlkaWVtKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBbbWVyaWRpZW0sIGhvdXJdID0gZ290TWVyaWRpZW07XG5cbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihIT1VSLCBob3VyKTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihNSU5VVEUsIG1pbnV0ZSk7XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID49IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTUVSSURJRU0sIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTUVSSURJRU0sIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTUVSSURJRU0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHRyYWN0U2Vjb25kQ2h1bmsodGV4dDogc3RyaW5nLCByZXN1bHQ6IFBhcnNlZFJlc3VsdCwgcmVmTW9tZW50OiBNb21lbnQsIGVuZE1vbWVudDogTW9tZW50KTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IG1hdGNoOiBSZWdFeHBFeGVjQXJyYXkgfCBudWxsID0gdGhpcy5FTkRfUEFUVEVSTi5leGVjKHRleHQuc3Vic3RyaW5nKHJlc3VsdC5pbmRleCArIHJlc3VsdC50ZXh0Lmxlbmd0aCkpO1xuXG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhdHRlcm4gXCJZWS5ZWSAtWFhYWFwiIGlzIG1vcmUgbGlrZSB0aW1lem9uZSBvZmZzZXRcbiAgICAgICAgaWYgKG1hdGNoWzBdLm1hdGNoKHRoaXMuT1RIRVJfUEFUVEVSTlNbMV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzdWx0LmVuZCkge1xuICAgICAgICAgICAgcmVzdWx0LmVuZCA9IG5ldyBQYXJzZWRDb21wb25lbnRzKHVuZGVmaW5lZCwgcmVzdWx0LnN0YXJ0LmRhdGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdldERheShtYXRjaCwgcmVzdWx0LmVuZCwgcmVmTW9tZW50LCBlbmRNb21lbnQpO1xuXG4gICAgICAgIGNvbnN0IHRpbWU6IFRpbWUgfCBmYWxzZSA9IHRoaXMuZ2V0VGltZShtYXRjaCk7XG4gICAgICAgIGlmICghdGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgW2hvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtZXJpZGllbV06IFRpbWUgPSB0aW1lO1xuXG4gICAgICAgIGlmIChzZWNvbmQgPiAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LmVuZC5hc3NpZ24oU0VDT05ELCBzZWNvbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZ290TWVyaWRpZW06IFtudW1iZXIsIG51bWJlcl0gfCBudWxsID0gdGhpcy5nZXRNZXJpZGllbShtYXRjaCwgbWVyaWRpZW0sIGhvdXIpO1xuICAgICAgICBpZiAoIWdvdE1lcmlkaWVtKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBbbWVyaWRpZW0sIGhvdXJdID0gZ290TWVyaWRpZW07XG5cbiAgICAgICAgcmVzdWx0LnRleHQgPSByZXN1bHQudGV4dCArIG1hdGNoWzBdO1xuICAgICAgICByZXN1bHQuZW5kLmFzc2lnbihIT1VSLCBob3VyKTtcbiAgICAgICAgcmVzdWx0LmVuZC5hc3NpZ24oTUlOVVRFLCBtaW51dGUpO1xuICAgICAgICBpZiAobWVyaWRpZW0gPj0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LmVuZC5hc3NpZ24oTUVSSURJRU0sIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0QXRQTTogYm9vbGVhbiA9IHJlc3VsdC5zdGFydC5pc0NlcnRhaW4oTUVSSURJRU0pICYmIHJlc3VsdC5zdGFydC5nZXQoTUVSSURJRU0pID09PSAxO1xuICAgICAgICAgICAgaWYgKHN0YXJ0QXRQTSAmJiByZXN1bHQuc3RhcnQuZ2V0KEhPVVIpID4gaG91cikge1xuICAgICAgICAgICAgICAgIC8vIDEwcG0gLSAxIChhbSlcbiAgICAgICAgICAgICAgICByZXN1bHQuZW5kLmltcGx5KE1FUklESUVNLCAwKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChob3VyID4gMTIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZW5kLmltcGx5KE1FUklESUVNLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQuZW5kLmRhdGUoKS5nZXRUaW1lKCkgPCByZXN1bHQuc3RhcnQuZGF0ZSgpLmdldFRpbWUoKSkge1xuICAgICAgICAgICAgcmVzdWx0LmVuZC5pbXBseShEQVksIHJlc3VsdC5lbmQuZ2V0KERBWSkgKyAxKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUaW1lKG1hdGNoOiBSZWdFeHBFeGVjQXJyYXkpOiBUaW1lIHwgZmFsc2Uge1xuICAgICAgICBsZXQgc2Vjb25kOiBudW1iZXIgPSAtMTtcbiAgICAgICAgbGV0IGhvdXI6IG51bWJlcjtcbiAgICAgICAgbGV0IG1pbnV0ZTogbnVtYmVyID0gMDtcbiAgICAgICAgbGV0IG1lcmlkaWVtOiBudW1iZXIgPSAtMTtcblxuICAgICAgICAvLyAtLS0tLSBTZWNvbmRcbiAgICAgICAgaWYgKG1hdGNoW3RoaXMuU0VDT05EX0dST1VQXSkge1xuICAgICAgICAgICAgc2Vjb25kID0gcGFyc2VJbnQobWF0Y2hbdGhpcy5TRUNPTkRfR1JPVVBdLCAxMCk7XG4gICAgICAgICAgICBpZiAoaXNOYU4oc2Vjb25kKSkge1xuICAgICAgICAgICAgICAgIHNlY29uZCA9IHpoU3RyaW5nVG9OdW1iZXIobWF0Y2hbdGhpcy5TRUNPTkRfR1JPVVBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWNvbmQgPj0gNjApIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tIEhvdXJzXG4gICAgICAgIGhvdXIgPSBwYXJzZUludChtYXRjaFt0aGlzLkhPVVJfR1JPVVBdLCAxMCk7XG4gICAgICAgIGlmIChpc05hTihob3VyKSkge1xuICAgICAgICAgICAgaG91ciA9IHpoU3RyaW5nVG9OdW1iZXIobWF0Y2hbdGhpcy5IT1VSX0dST1VQXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLSBNaW51dGVzXG4gICAgICAgIGlmIChtYXRjaFt0aGlzLk1JTlVURV9HUk9VUF0pIHtcbiAgICAgICAgICAgIGlmIChtYXRjaFt0aGlzLk1JTlVURV9HUk9VUF0gPT09ICfljYonKSB7XG4gICAgICAgICAgICAgICAgbWludXRlID0gMzA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoW3RoaXMuTUlOVVRFX0dST1VQXSA9PT0gJ+atoycgfHwgbWF0Y2hbdGhpcy5NSU5VVEVfR1JPVVBdID09PSAn5pW0Jykge1xuICAgICAgICAgICAgICAgIG1pbnV0ZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pbnV0ZSA9IHBhcnNlSW50KG1hdGNoW3RoaXMuTUlOVVRFX0dST1VQXSwgMTApO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihtaW51dGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZSA9IHpoU3RyaW5nVG9OdW1iZXIobWF0Y2hbdGhpcy5NSU5VVEVfR1JPVVBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaG91ciA+IDEwMCkge1xuICAgICAgICAgICAgbWludXRlID0gaG91ciAlIDEwMDtcbiAgICAgICAgICAgIGhvdXIgPSBNYXRoLmZsb29yKGhvdXIgLyAxMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pbnV0ZSA+PSA2MCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhvdXIgPiAyNCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob3VyID49IDEyKSB7XG4gICAgICAgICAgICBtZXJpZGllbSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW2hvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtZXJpZGllbV07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXREYXkobWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSwgY3VycmVudDogUGFyc2VkQ29tcG9uZW50cywgcmVmTW9tZW50OiBNb21lbnQsIHRhcmdldE1vbWVudDogTW9tZW50KTogdm9pZCB7XG4gICAgICAgIC8vIC0tLS0tIERheVxuICAgICAgICBpZiAobWF0Y2hbdGhpcy5EQVlfR1JPVVBfMV0pIHtcbiAgICAgICAgICAgIGNvbnN0IGRheTE6IHN0cmluZyA9IG1hdGNoW3RoaXMuREFZX0dST1VQXzFdO1xuICAgICAgICAgICAgaWYgKGRheTEgPT09ICfmmI4nIHx8IGRheTEgPT09ICfogb0nKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgbm90IFwiVG9tb3Jyb3dcIiBvbiBsYXRlIG5pZ2h0XG4gICAgICAgICAgICAgICAgaWYocmVmTW9tZW50LmhvdXIoKSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TW9tZW50LmFkZCgxLCAnZGF5Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXkxID09PSAn5pioJyB8fCBkYXkxID09PSAn5bCLJyB8fCBkYXkxID09PSAn55C0Jykge1xuICAgICAgICAgICAgICAgIHRhcmdldE1vbWVudC5hZGQoLTEsICdkYXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQuYXNzaWduKERBWSwgdGFyZ2V0TW9tZW50LmRhdGUoKSk7XG4gICAgICAgICAgICBjdXJyZW50LmFzc2lnbihNT05USCwgdGFyZ2V0TW9tZW50Lm1vbnRoKCkgKyAxKTtcbiAgICAgICAgICAgIGN1cnJlbnQuYXNzaWduKFlFQVIsIHRhcmdldE1vbWVudC55ZWFyKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoW3RoaXMuREFZX0dST1VQXzNdKSB7XG4gICAgICAgICAgICBjb25zdCBkYXkzOiBzdHJpbmcgPSBtYXRjaFt0aGlzLkRBWV9HUk9VUF8zXTtcbiAgICAgICAgICAgIGlmIChkYXkzID09PSAn5piOJyB8fCBkYXkzID09PSAn6IG9Jykge1xuICAgICAgICAgICAgICAgIHRhcmdldE1vbWVudC5hZGQoMSwgJ2RheScpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXkzID09PSAn5pioJyB8fCBkYXkzID09PSAn5bCLJyB8fCBkYXkzID09PSAn55C0Jykge1xuICAgICAgICAgICAgICAgIHRhcmdldE1vbWVudC5hZGQoLTEsICdkYXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQuYXNzaWduKERBWSwgdGFyZ2V0TW9tZW50LmRhdGUoKSk7XG4gICAgICAgICAgICBjdXJyZW50LmFzc2lnbihNT05USCwgdGFyZ2V0TW9tZW50Lm1vbnRoKCkgKyAxKTtcbiAgICAgICAgICAgIGN1cnJlbnQuYXNzaWduKFlFQVIsIHRhcmdldE1vbWVudC55ZWFyKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudC5pbXBseShEQVksIHRhcmdldE1vbWVudC5kYXRlKCkpO1xuICAgICAgICAgICAgY3VycmVudC5pbXBseShNT05USCwgdGFyZ2V0TW9tZW50Lm1vbnRoKCkgKyAxKTtcbiAgICAgICAgICAgIGN1cnJlbnQuaW1wbHkoWUVBUiwgdGFyZ2V0TW9tZW50LnllYXIoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE1lcmlkaWVtKG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIG1lcmlkaWVtOiBudW1iZXIsIGhvdXI6IG51bWJlcik6IFtudW1iZXIsIG51bWJlcl0gfCBudWxsIHtcbiAgICAgICAgLy8gLS0tLS0gQU0gJiBQTVxuICAgICAgICBpZiAobWF0Y2hbdGhpcy5BTV9QTV9IT1VSX0dST1VQXSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPiAxMikgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb25zdCBhbXBtOiBzdHJpbmcgPSBtYXRjaFt0aGlzLkFNX1BNX0hPVVJfR1JPVVBdWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoYW1wbSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICAgICAgbWVyaWRpZW0gPSAwO1xuICAgICAgICAgICAgICAgIGlmIChob3VyID09PSAxMikgaG91ciA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFtcG0gPT09ICdwJykge1xuICAgICAgICAgICAgICAgIG1lcmlkaWVtID0gMTtcbiAgICAgICAgICAgICAgICBpZiAoaG91ciAhPT0gMTIpIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbdGhpcy5aSF9BTV9QTV9IT1VSX0dST1VQXzFdKSB7XG4gICAgICAgICAgICBjb25zdCBhbXBtOiBzdHJpbmcgPSBtYXRjaFt0aGlzLlpIX0FNX1BNX0hPVVJfR1JPVVBfMV1bMF07XG4gICAgICAgICAgICBpZiAoYW1wbSA9PT0gJ+acnScgfHwgYW1wbSA9PT0gJ+aXqScpIHtcbiAgICAgICAgICAgICAgICBtZXJpZGllbSA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKSBob3VyID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYW1wbSA9PT0gJ+aZmicpIHtcbiAgICAgICAgICAgICAgICBtZXJpZGllbSA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXIgIT09IDEyKSBob3VyICs9IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoW3RoaXMuWkhfQU1fUE1fSE9VUl9HUk9VUF8yXSkge1xuICAgICAgICAgICAgY29uc3QgYW1wbTogc3RyaW5nID0gbWF0Y2hbdGhpcy5aSF9BTV9QTV9IT1VSX0dST1VQXzJdWzBdO1xuICAgICAgICAgICAgaWYgKGFtcG0gPT09ICfkuIonIHx8IGFtcG0gPT09ICfmnJ0nIHx8IGFtcG0gPT09ICfml6knIHx8IGFtcG0gPT09ICflh4wnKSB7XG4gICAgICAgICAgICAgICAgbWVyaWRpZW0gPSAwO1xuICAgICAgICAgICAgICAgIGlmIChob3VyID09PSAxMikgaG91ciA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFtcG0gPT09ICfkuIsnIHx8IGFtcG0gPT09ICfmmY8nIHx8IGFtcG0gPT09ICfmmZonKSB7XG4gICAgICAgICAgICAgICAgbWVyaWRpZW0gPSAxO1xuICAgICAgICAgICAgICAgIGlmIChob3VyICE9PSAxMikgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaFt0aGlzLlpIX0FNX1BNX0hPVVJfR1JPVVBfM10pIHtcbiAgICAgICAgICAgIGNvbnN0IGFtcG06IHN0cmluZyA9IG1hdGNoW3RoaXMuWkhfQU1fUE1fSE9VUl9HUk9VUF8zXVswXTtcbiAgICAgICAgICAgIGlmIChhbXBtID09PSAn5LiKJyB8fCBhbXBtID09PSAn5pydJyB8fCBhbXBtID09PSAn5pepJyB8fCBhbXBtID09PSAn5YeMJykge1xuICAgICAgICAgICAgICAgIG1lcmlkaWVtID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoaG91ciA9PT0gMTIpIGhvdXIgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhbXBtID09PSAn5LiLJyB8fCBhbXBtID09PSAn5pmPJyB8fCBhbXBtID09PSAn5pmaJykge1xuICAgICAgICAgICAgICAgIG1lcmlkaWVtID0gMTtcbiAgICAgICAgICAgICAgICBpZiAoaG91ciAhPT0gMTIpIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW21lcmlkaWVtLCBob3VyXTtcbiAgICB9XG59IiwiaW1wb3J0IFBhcnNlciBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHtQYXJzZWRSZXN1bHR9IGZyb20gXCIuLi8uLi9yZXN1bHRcIjtcbmltcG9ydCB7UGFyc2VPcHRpb25zfSBmcm9tIFwiLi4vLi4vY2hyb25vXCI7XG5pbXBvcnQge1dFRUtEQVlfT0ZGU0VUfSBmcm9tICcuLi8uLi91dGlscy9aSC1IYW50JztcbmltcG9ydCB7TW9kaWZpZXIsIHVwZGF0ZVBhcnNlZENvbXBvbmVudH0gZnJvbSAnLi4vLi4vdXRpbHMvZ2VuZXJhbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFpISGFudFdlZWtkYXlQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIHByaXZhdGUgUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cChcbiAgICAgICAgJyjkuIp85LuKfOS4i3zpgJl85ZGiKT8nICtcbiAgICAgICAgJyg/OuWAiyk/JyArXG4gICAgICAgICcoPzrmmJ/mnJ9856au5oucKScgK1xuICAgICAgICAnKCcgKyBPYmplY3Qua2V5cyhXRUVLREFZX09GRlNFVCkuam9pbignfCcpICsgJyknXG4gICAgKTtcblxuICAgIHByaXZhdGUgUFJFRklYX0dST1VQOiBudW1iZXIgPSAxO1xuICAgIHByaXZhdGUgV0VFS0RBWV9HUk9VUDogbnVtYmVyID0gMjtcblxuICAgIHByaXZhdGUgVEFHOiBzdHJpbmcgPSAnWkhXZWVrZGF5UGFyc2VyJztcblxuICAgIHBhdHRlcm4oKTogUmVnRXhwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuUEFUVEVSTjtcbiAgICB9XG5cbiAgICBleHRyYWN0KHRleHQ6IHN0cmluZywgcmVmOiBEYXRlLCBtYXRjaDogUmVnRXhwRXhlY0FycmF5LCBvcHQ6IFBhcnNlT3B0aW9ucyk6IFBhcnNlZFJlc3VsdCB8IG51bGwge1xuICAgICAgICBjb25zdCBpbmRleDogbnVtYmVyID0gbWF0Y2guaW5kZXg7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRUZXh0OiBzdHJpbmcgPSBtYXRjaFswXTtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBQYXJzZWRSZXN1bHQgPSBuZXcgUGFyc2VkUmVzdWx0KHtcbiAgICAgICAgICAgIHRleHQ6IG1hdGNoZWRUZXh0LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICByZWYsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG9mZnNldDogbnVtYmVyIHwgdW5kZWZpbmVkID0gV0VFS0RBWV9PRkZTRVRbKG1hdGNoW3RoaXMuV0VFS0RBWV9HUk9VUF0gfHwgJycpLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuXG4gICAgICAgIGNvbnN0IG5vcm06IHN0cmluZyA9IChtYXRjaFt0aGlzLlBSRUZJWF9HUk9VUF0gfHwgJycpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgbGV0IG1vZGlmaWVyOiBNb2RpZmllciA9IE1vZGlmaWVyLlVOS05PV047XG4gICAgICAgIGlmIChub3JtID09ICfku4onIHx8IG5vcm0gPT0gJ+mAmScgfHwgbm9ybSA9PSAn5ZGiJykge1xuICAgICAgICAgICAgbW9kaWZpZXIgPSBNb2RpZmllci5USElTO1xuICAgICAgICB9IGVsc2UgaWYgKG5vcm0gPT09ICfkuIonKSB7XG4gICAgICAgICAgICBtb2RpZmllciA9IE1vZGlmaWVyLkxBU1Q7XG4gICAgICAgIH0gZWxzZSBpZiAobm9ybSA9PSAn5LiLJykge1xuICAgICAgICAgICAgbW9kaWZpZXIgPSBNb2RpZmllci5ORVhUO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcblxuICAgICAgICB1cGRhdGVQYXJzZWRDb21wb25lbnQocmVzdWx0LCByZWYsIG9mZnNldCwgbW9kaWZpZXIpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufSIsImltcG9ydCB7Q29uZmlnfSBmcm9tIFwiLi4vb3B0aW9uc1wiO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi9jaHJvbm9cIjtcbmltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tIFwiLi4vcmVzdWx0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFBhcnNlciB7XG4gICAgc3RyaWN0TW9kZTogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZzogQ29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5zdHJpY3RNb2RlID0gISFjb25maWcuc3RyaWN0O1xuICAgIH1cblxuICAgIGlzU3RyaWN0TW9kZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaWN0TW9kZTtcbiAgICB9XG5cbiAgICBhYnN0cmFjdCBwYXR0ZXJuKCk6IFJlZ0V4cDtcblxuICAgIGFic3RyYWN0IGV4dHJhY3QodGV4dDogc3RyaW5nLCByZWY6IERhdGUsIG1hdGNoOiBSZWdFeHBFeGVjQXJyYXksIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0IHwgbnVsbDtcblxuICAgIGV4ZWN1dGUodGV4dDogc3RyaW5nLCByZWY6IERhdGUsIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0W10ge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdHM6IFBhcnNlZFJlc3VsdFtdID0gW107XG4gICAgICAgIGNvbnN0IHJlZ2V4OiBSZWdFeHAgPSB0aGlzLnBhdHRlcm4oKTtcblxuICAgICAgICBsZXQgcmVtYWluaW5nVGV4dDogc3RyaW5nID0gdGV4dDtcbiAgICAgICAgbGV0IG1hdGNoOiBSZWdFeHBFeGVjQXJyYXkgfCBudWxsID0gcmVnZXguZXhlYyhyZW1haW5pbmdUZXh0KTtcblxuXG4gICAgICAgIHdoaWxlIChtYXRjaCkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIG1hdGNoIGluZGV4IG9uIHRoZSBmdWxsIHRleHQ7XG4gICAgICAgICAgICBtYXRjaC5pbmRleCArPSB0ZXh0Lmxlbmd0aCAtIHJlbWFpbmluZ1RleHQubGVuZ3RoO1xuXG4gICAgICAgICAgICBsZXQgcmVzdWx0OiBQYXJzZWRSZXN1bHQgfCBudWxsID0gdGhpcy5leHRyYWN0KHRleHQsIHJlZiwgbWF0Y2gsIG9wdCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgc3VjY2Vzcywgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAgICByZW1haW5pbmdUZXh0ID0gdGV4dC5zdWJzdHJpbmcocmVzdWx0LmluZGV4ICsgcmVzdWx0LnRleHQubGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1N0cmljdE1vZGUoKSB8fCByZXN1bHQuaGFzUG9zc2libGVEYXRlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgZmFpbCwgbW92ZSBvbiBieSAxIC0gVGhpcyBzaG91bGQgcmFyZWx5LCBpZiBldmVyIGhhcHBlbiAod2UgbWF0Y2hlZCBidXQgY291bGRuJ3QgY3JlYXRlIGEgcmVzdWx0IGZyb20gaXQpXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nVGV4dCA9IHRleHQuc3Vic3RyaW5nKG1hdGNoLmluZGV4ICsgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hdGNoID0gcmVnZXguZXhlYyhyZW1haW5pbmdUZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbn1cblxuZXhwb3J0IHtkZWZhdWx0IGFzIEVOSVNPRm9ybWF0UGFyc2VyfSBmcm9tICcuL0VOL0VOSVNPRm9ybWF0UGFyc2VyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBFTkRlYWRsaW5lRm9ybWF0UGFyc2VyfSBmcm9tICcuL0VOL0VORGVhZGxpbmVGb3JtYXRQYXJzZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEVOUmVsYXRpdmVEYXRlRm9ybWF0UGFyc2VyfSBmcm9tICcuL0VOL0VOUmVsYXRpdmVEYXRlRm9ybWF0UGFyc2VyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBFTk1vbnRoTmFtZUxpdHRsZUVuZGlhblBhcnNlcn0gZnJvbSAnLi9FTi9FTk1vbnRoTmFtZUxpdHRsZUVuZGlhblBhcnNlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgRU5Nb250aE5hbWVNaWRkbGVFbmRpYW5QYXJzZXJ9IGZyb20gJy4vRU4vRU5Nb250aE5hbWVNaWRkbGVFbmRpYW5QYXJzZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEVOTW9udGhOYW1lUGFyc2VyfSBmcm9tICcuL0VOL0VOTW9udGhOYW1lUGFyc2VyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBFTlNsYXNoRGF0ZUZvcm1hdFBhcnNlcn0gZnJvbSAnLi9FTi9FTlNsYXNoRGF0ZUZvcm1hdFBhcnNlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgRU5TbGFzaERhdGVGb3JtYXRTdGFydFdpdGhZZWFyUGFyc2VyfSBmcm9tICcuL0VOL0VOU2xhc2hEYXRlRm9ybWF0U3RhcnRXaXRoWWVhclBhcnNlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgRU5TbGFzaE1vbnRoRm9ybWF0UGFyc2VyfSBmcm9tICcuL0VOL0VOU2xhc2hNb250aEZvcm1hdFBhcnNlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgRU5UaW1lQWdvRm9ybWF0UGFyc2VyfSBmcm9tICcuL0VOL0VOVGltZUFnb0Zvcm1hdFBhcnNlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgRU5UaW1lRXhwcmVzc2lvblBhcnNlcn0gZnJvbSAnLi9FTi9FTlRpbWVFeHByZXNzaW9uUGFyc2VyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBFTlRpbWVMYXRlckZvcm1hdFBhcnNlcn0gZnJvbSAnLi9FTi9FTlRpbWVMYXRlckZvcm1hdFBhcnNlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgRU5XZWVrZGF5UGFyc2VyfSBmcm9tICcuL0VOL0VOV2Vla2RheVBhcnNlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgRU5DYXN1YWxEYXRlUGFyc2VyfSBmcm9tICcuL0VOL0VOQ2FzdWFsRGF0ZVBhcnNlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgRU5DYXN1YWxUaW1lUGFyc2VyfSBmcm9tICcuL0VOL0VOQ2FzdWFsVGltZVBhcnNlcic7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBKUFN0YW5kYXJkUGFyc2VyfSBmcm9tICcuL0pQL0pQU3RhbmRhcmRQYXJzZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEpQQ2FzdWFsRGF0ZVBhcnNlcn0gZnJvbSAnLi9KUC9KUENhc3VhbERhdGVQYXJzZXInO1xuXG5leHBvcnQge2RlZmF1bHQgYXMgRVNDYXN1YWxEYXRlUGFyc2VyfSBmcm9tICcuL0VTL0VTQ2FzdWFsRGF0ZVBhcnNlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgRVNEZWFkbGluZUZvcm1hdFBhcnNlcn0gZnJvbSAnLi9FUy9FU0RlYWRsaW5lRm9ybWF0UGFyc2VyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBFU1RpbWVBZ29Gb3JtYXRQYXJzZXJ9IGZyb20gJy4vRVMvRVNUaW1lQWdvRm9ybWF0UGFyc2VyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBFU1RpbWVFeHByZXNzaW9uUGFyc2VyfSBmcm9tICcuL0VTL0VTVGltZUV4cHJlc3Npb25QYXJzZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEVTV2Vla2RheVBhcnNlcn0gZnJvbSAnLi9FUy9FU1dlZWtkYXlQYXJzZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEVTTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyfSBmcm9tICcuL0VTL0VTTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBFU1NsYXNoRGF0ZUZvcm1hdFBhcnNlcn0gZnJvbSAnLi9FUy9FU1NsYXNoRGF0ZUZvcm1hdFBhcnNlcic7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBGUkNhc3VhbERhdGVQYXJzZXJ9IGZyb20gJy4vRlIvRlJDYXN1YWxEYXRlUGFyc2VyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBGUkRlYWRsaW5lRm9ybWF0UGFyc2VyfSBmcm9tICcuL0ZSL0ZSRGVhZGxpbmVGb3JtYXRQYXJzZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEZSTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyfSBmcm9tICcuL0ZSL0ZSTW9udGhOYW1lTGl0dGxlRW5kaWFuUGFyc2VyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBGUlNsYXNoRGF0ZUZvcm1hdFBhcnNlcn0gZnJvbSAnLi9GUi9GUlNsYXNoRGF0ZUZvcm1hdFBhcnNlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgRlJUaW1lQWdvRm9ybWF0UGFyc2VyfSBmcm9tICcuL0ZSL0ZSVGltZUFnb0Zvcm1hdFBhcnNlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgRlJUaW1lRXhwcmVzc2lvblBhcnNlcn0gZnJvbSAnLi9GUi9GUlRpbWVFeHByZXNzaW9uUGFyc2VyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBGUldlZWtkYXlQYXJzZXJ9IGZyb20gJy4vRlIvRlJXZWVrZGF5UGFyc2VyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBGUlJlbGF0aXZlRGF0ZUZvcm1hdFBhcnNlcn0gZnJvbSAnLi9GUi9GUlJlbGF0aXZlRGF0ZUZvcm1hdFBhcnNlcic7XG5cbmV4cG9ydCB7ZGVmYXVsdCBhcyBaSEhhbnREYXRlUGFyc2VyfSBmcm9tICcuL1pILUhhbnQvWkhIYW50RGF0ZVBhcnNlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgWkhIYW50V2Vla2RheVBhcnNlcn0gZnJvbSAnLi9aSC1IYW50L1pISGFudFdlZWtkYXlQYXJzZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFpISGFudFRpbWVFeHByZXNzaW9uUGFyc2VyfSBmcm9tICcuL1pILUhhbnQvWkhIYW50VGltZUV4cHJlc3Npb25QYXJzZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFpISGFudENhc3VhbERhdGVQYXJzZXJ9IGZyb20gJy4vWkgtSGFudC9aSEhhbnRDYXN1YWxEYXRlUGFyc2VyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBaSEhhbnREZWFkbGluZUZvcm1hdFBhcnNlcn0gZnJvbSAnLi9aSC1IYW50L1pISGFudERlYWRsaW5lRm9ybWF0UGFyc2VyJztcblxuZXhwb3J0IHtkZWZhdWx0IGFzIERFRGVhZGxpbmVGb3JtYXRQYXJzZXJ9IGZyb20gJy4vREUvREVEZWFkbGluZUZvcm1hdFBhcnNlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgREVNb250aE5hbWVMaXR0bGVFbmRpYW5QYXJzZXJ9IGZyb20gJy4vREUvREVNb250aE5hbWVMaXR0bGVFbmRpYW5QYXJzZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIERFTW9udGhOYW1lUGFyc2VyfSBmcm9tICcuL0RFL0RFTW9udGhOYW1lUGFyc2VyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBERVNsYXNoRGF0ZUZvcm1hdFBhcnNlcn0gZnJvbSAnLi9ERS9ERVNsYXNoRGF0ZUZvcm1hdFBhcnNlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgREVUaW1lQWdvRm9ybWF0UGFyc2VyfSBmcm9tICcuL0RFL0RFVGltZUFnb0Zvcm1hdFBhcnNlcic7XG5leHBvcnQge2RlZmF1bHQgYXMgREVUaW1lRXhwcmVzc2lvblBhcnNlcn0gZnJvbSAnLi9ERS9ERVRpbWVFeHByZXNzaW9uUGFyc2VyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBERVdlZWtkYXlQYXJzZXJ9IGZyb20gJy4vREUvREVXZWVrZGF5UGFyc2VyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBERUNhc3VhbERhdGVQYXJzZXJ9IGZyb20gJy4vREUvREVDYXN1YWxEYXRlUGFyc2VyJztcbiIsImltcG9ydCB7TWVyZ2VEYXRlUmFuZ2VSZWZpbmVyfSBmcm9tICcuLi9FTi9FTk1lcmdlRGF0ZVJhbmdlUmVmaW5lcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERFTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyIGV4dGVuZHMgTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyIHtcbiAgICBQQVRURVJOOiBSZWdFeHAgPSAvXlxccyooYmlzKD86XFxzKig/OmFtfHp1bSkpP3xcXC0pXFxzKiQvaTtcbiAgICBUQUc6IHN0cmluZyA9ICdERU1lcmdlRGF0ZVJhbmdlUmVmaW5lcic7XG59IiwiaW1wb3J0IHtNZXJnZURhdGVUaW1lUmVmaW5lcn0gZnJvbSBcIi4uL0VOL0VOTWVyZ2VEYXRlVGltZVJlZmluZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgREVNZXJnZURhdGVUaW1lUmVmaW5lciBleHRlbmRzIE1lcmdlRGF0ZVRpbWVSZWZpbmVyIHtcbiAgICBUQUc6IHN0cmluZyA9ICdERU1lcmdlRGF0ZVRpbWVSZWZpbmVyJztcbiAgICBQQVRURVJOOiBSZWdFeHAgPSBuZXcgUmVnRXhwKFwiXlxcXFxzKihUfHVtfGFtfCx8LSk/XFxcXHMqJFwiKTtcbn0iLCJpbXBvcnQgUmVmaW5lciBmcm9tICcuLi9yZWZpbmVyJztcbmltcG9ydCB7Q09NUE9ORU5UX05BTUUsIFBhcnNlZENvbXBvbmVudHMsIFBhcnNlZFJlc3VsdH0gZnJvbSBcIi4uLy4uL3Jlc3VsdFwiO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jaHJvbm9cIjtcbmltcG9ydCB7REFZLCBNT05USCwgV0VFS0RBWSwgWUVBUn0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHtNb21lbnR9IGZyb20gXCJtb21lbnRcIjtcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE1lcmdlRGF0ZVJhbmdlUmVmaW5lciBleHRlbmRzIFJlZmluZXIge1xuICAgIGFic3RyYWN0IFRBRzogc3RyaW5nO1xuICAgIGFic3RyYWN0IFBBVFRFUk46IFJlZ0V4cDtcblxuXG4gICAgcmVmaW5lKHRleHQ6IHN0cmluZywgcmVzdWx0czogUGFyc2VkUmVzdWx0W10sIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0W10ge1xuICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1lcmdlZFJlc3VsdDogUGFyc2VkUmVzdWx0W10gPSBbXTtcbiAgICAgICAgbGV0IGN1cnJSZXN1bHQ6IFBhcnNlZFJlc3VsdCB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgcHJldlJlc3VsdDogUGFyc2VkUmVzdWx0IHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIGN1cnJSZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgICAgICAgICAgcHJldlJlc3VsdCA9IHJlc3VsdHNbaSAtIDFdO1xuXG4gICAgICAgICAgICBpZiAoIXByZXZSZXN1bHQuZW5kICYmICFjdXJyUmVzdWx0LmVuZCAmJiB0aGlzLmlzQWJsZVRvTWVyZ2UodGV4dCwgcHJldlJlc3VsdCwgY3VyclJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICBwcmV2UmVzdWx0ID0gdGhpcy5tZXJnZVJlc3VsdCh0ZXh0LCBwcmV2UmVzdWx0LCBjdXJyUmVzdWx0KTtcbiAgICAgICAgICAgICAgICBjdXJyUmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1lcmdlZFJlc3VsdC5wdXNoKHByZXZSZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJSZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWVyZ2VkUmVzdWx0LnB1c2goY3VyclJlc3VsdCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiBtZXJnZWRSZXN1bHQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc0FibGVUb01lcmdlKHRleHQ6IHN0cmluZywgcmVzdWx0MTogUGFyc2VkUmVzdWx0LCByZXN1bHQyOiBQYXJzZWRSZXN1bHQpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhdGV4dC5zdWJzdHJpbmcocmVzdWx0MS5pbmRleCArIHJlc3VsdDEudGV4dC5sZW5ndGgsIHJlc3VsdDIuaW5kZXgpLm1hdGNoKHRoaXMuUEFUVEVSTik7XG4gICAgfTtcblxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU01ldGhvZENhbkJlU3RhdGljXG4gICAgcHJpdmF0ZSBpc1dlZWtkYXlSZXN1bHQocmVzdWx0OiBQYXJzZWRSZXN1bHQpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdGFydC5pc0NlcnRhaW4oV0VFS0RBWSkgJiYgIXJlc3VsdC5zdGFydC5pc0NlcnRhaW4oREFZKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG1lcmdlUmVzdWx0KHRleHQ6IHN0cmluZywgZnJvbVJlc3VsdDogUGFyc2VkUmVzdWx0LCB0b1Jlc3VsdDogUGFyc2VkUmVzdWx0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1dlZWtkYXlSZXN1bHQoZnJvbVJlc3VsdCkgJiYgIXRoaXMuaXNXZWVrZGF5UmVzdWx0KHRvUmVzdWx0KSkge1xuICAgICAgICAgICAgdGhpcy5tZXJnZVZhbHVlcyh0b1Jlc3VsdC5zdGFydCwgZnJvbVJlc3VsdC5zdGFydCk7XG4gICAgICAgICAgICB0aGlzLm1lcmdlVmFsdWVzKGZyb21SZXN1bHQuc3RhcnQsIHRvUmVzdWx0LnN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcm9tUmVzdWx0LnN0YXJ0LmRhdGUoKS5nZXRUaW1lKCkgPiB0b1Jlc3VsdC5zdGFydC5kYXRlKCkuZ2V0VGltZSgpKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGZyb21Nb21lbnQ6IE1vbWVudCA9IGZyb21SZXN1bHQuc3RhcnQubW9tZW50KCk7XG4gICAgICAgICAgICBjb25zdCB0b01vbWVudDogTW9tZW50ID0gdG9SZXN1bHQuc3RhcnQubW9tZW50KCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzV2Vla2RheVJlc3VsdChmcm9tUmVzdWx0KSAmJiBmcm9tTW9tZW50LmNsb25lKCkuYWRkKC03LCAnZGF5cycpLmlzQmVmb3JlKHRvTW9tZW50KSkge1xuICAgICAgICAgICAgICAgIGZyb21Nb21lbnQuYWRkKC03LCAnZGF5cycpO1xuICAgICAgICAgICAgICAgIGZyb21SZXN1bHQuc3RhcnQuaW1wbHkoREFZLCBmcm9tTW9tZW50LmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgZnJvbVJlc3VsdC5zdGFydC5pbXBseShNT05USCwgZnJvbU1vbWVudC5tb250aCgpICsgMSk7XG4gICAgICAgICAgICAgICAgZnJvbVJlc3VsdC5zdGFydC5pbXBseShZRUFSLCBmcm9tTW9tZW50LnllYXIoKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNXZWVrZGF5UmVzdWx0KHRvUmVzdWx0KSAmJiB0b01vbWVudC5jbG9uZSgpLmFkZCg3LCAnZGF5cycpLmlzQWZ0ZXIoZnJvbU1vbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0b01vbWVudC5hZGQoNywgJ2RheXMnKTtcbiAgICAgICAgICAgICAgICB0b1Jlc3VsdC5zdGFydC5pbXBseShEQVksIHRvTW9tZW50LmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgdG9SZXN1bHQuc3RhcnQuaW1wbHkoTU9OVEgsIHRvTW9tZW50Lm1vbnRoKCkgKyAxKTtcbiAgICAgICAgICAgICAgICB0b1Jlc3VsdC5zdGFydC5pbXBseShZRUFSLCB0b01vbWVudC55ZWFyKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBbdG9SZXN1bHQsIGZyb21SZXN1bHRdID0gW2Zyb21SZXN1bHQsIHRvUmVzdWx0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZyb21SZXN1bHQuZW5kID0gdG9SZXN1bHQuc3RhcnQ7XG5cbiAgICAgICAgT2JqZWN0LmtleXModG9SZXN1bHQudGFncykuZm9yRWFjaCgodGFnKSA9PiBmcm9tUmVzdWx0LnRhZ3NbdGFnXSA9IHRydWUpO1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXg6IG51bWJlciA9IE1hdGgubWluKGZyb21SZXN1bHQuaW5kZXgsIHRvUmVzdWx0LmluZGV4KTtcbiAgICAgICAgY29uc3QgZW5kSW5kZXg6IG51bWJlciA9IE1hdGgubWF4KFxuICAgICAgICAgICAgZnJvbVJlc3VsdC5pbmRleCArIGZyb21SZXN1bHQudGV4dC5sZW5ndGgsXG4gICAgICAgICAgICB0b1Jlc3VsdC5pbmRleCArIHRvUmVzdWx0LnRleHQubGVuZ3RoKTtcblxuICAgICAgICBmcm9tUmVzdWx0LmluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgZnJvbVJlc3VsdC50ZXh0ID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgICBmcm9tUmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZyb21SZXN1bHQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtZXJnZVZhbHVlcyhmcm9tOiBQYXJzZWRDb21wb25lbnRzLCB0bzogUGFyc2VkQ29tcG9uZW50cykge1xuICAgICAgICAoT2JqZWN0LmtleXMoZnJvbS5rbm93blZhbHVlcykgYXMgQ09NUE9ORU5UX05BTUVbXSkuZm9yRWFjaCgoa2V5OiBDT01QT05FTlRfTkFNRSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0by5pc0NlcnRhaW4oa2V5KSkge1xuICAgICAgICAgICAgICAgIHRvLmFzc2lnbihrZXksIGZyb20uZ2V0KGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVOTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyIGV4dGVuZHMgTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyIHtcbiAgICBUQUcgPSAnRU5NZXJnZURhdGVSYW5nZVJlZmluZXInO1xuICAgIFBBVFRFUk4gPSAvXlxccyoodG98LXzjg7wpXFxzKiQvaTtcbn0iLCJpbXBvcnQgUmVmaW5lciBmcm9tICcuLi9yZWZpbmVyJztcbmltcG9ydCB7UGFyc2VkQ29tcG9uZW50cywgUGFyc2VkUmVzdWx0fSBmcm9tIFwiLi4vLi4vcmVzdWx0XCI7XG5pbXBvcnQge1BhcnNlT3B0aW9uc30gZnJvbSBcIi4uLy4uL2Nocm9ub1wiO1xuaW1wb3J0IHtEQVksIEhPVVIsIE1FUklESUVNLCBNSUxMSVNFQ09ORCwgTUlOVVRFLCBNT05USCwgU0VDT05ELCBXRUVLREFZfSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBNZXJnZURhdGVUaW1lUmVmaW5lciBleHRlbmRzIFJlZmluZXIge1xuICAgIGFic3RyYWN0IFRBRzogc3RyaW5nO1xuICAgIGFic3RyYWN0IFBBVFRFUk46IFJlZ0V4cDtcblxuICAgIHJlZmluZSh0ZXh0OiBzdHJpbmcsIHJlc3VsdHM6IFBhcnNlZFJlc3VsdFtdLCBvcHQ6IFBhcnNlT3B0aW9ucyk6IFBhcnNlZFJlc3VsdFtdIHtcbiAgICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtZXJnZWRSZXN1bHQ6IFBhcnNlZFJlc3VsdFtdID0gW107XG4gICAgICAgIGxldCBjdXJyUmVzdWx0OiBQYXJzZWRSZXN1bHQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IHByZXZSZXN1bHQ6IFBhcnNlZFJlc3VsdCB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICBjdXJyUmVzdWx0ID0gcmVzdWx0c1tpXTtcbiAgICAgICAgICAgIHByZXZSZXN1bHQgPSByZXN1bHRzW2kgLSAxXTtcblxuICAgICAgICAgICAgaWYgKE1lcmdlRGF0ZVRpbWVSZWZpbmVyLmlzRGF0ZU9ubHkocHJldlJlc3VsdCkgJiYgTWVyZ2VEYXRlVGltZVJlZmluZXIuaXNUaW1lT25seShjdXJyUmVzdWx0KVxuICAgICAgICAgICAgICAgICYmIHRoaXMuaXNBYmxlVG9NZXJnZSh0ZXh0LCBwcmV2UmVzdWx0LCBjdXJyUmVzdWx0KSkge1xuXG4gICAgICAgICAgICAgICAgcHJldlJlc3VsdCA9IHRoaXMubWVyZ2VSZXN1bHQodGV4dCwgcHJldlJlc3VsdCwgY3VyclJlc3VsdCk7XG4gICAgICAgICAgICAgICAgY3VyclJlc3VsdCA9IHJlc3VsdHNbaSArIDFdIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgaSArPSAxO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1lcmdlRGF0ZVRpbWVSZWZpbmVyLmlzRGF0ZU9ubHkoY3VyclJlc3VsdCkgJiYgTWVyZ2VEYXRlVGltZVJlZmluZXIuaXNUaW1lT25seShwcmV2UmVzdWx0KVxuICAgICAgICAgICAgICAgICYmIHRoaXMuaXNBYmxlVG9NZXJnZSh0ZXh0LCBwcmV2UmVzdWx0LCBjdXJyUmVzdWx0KSkge1xuXG4gICAgICAgICAgICAgICAgcHJldlJlc3VsdCA9IHRoaXMubWVyZ2VSZXN1bHQodGV4dCwgY3VyclJlc3VsdCwgcHJldlJlc3VsdCk7XG4gICAgICAgICAgICAgICAgY3VyclJlc3VsdCA9IHJlc3VsdHNbaSArIDFdIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJldlJlc3VsdCkge1xuICAgICAgICAgICAgICAgIG1lcmdlZFJlc3VsdC5wdXNoKHByZXZSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJSZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1lcmdlZFJlc3VsdC5wdXNoKGN1cnJSZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1lcmdlZFJlc3VsdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGlzQWJsZVRvTWVyZ2UodGV4dDogc3RyaW5nLCByZXN1bHQxOiBQYXJzZWRSZXN1bHQsIHJlc3VsdDI6IFBhcnNlZFJlc3VsdCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISF0ZXh0LnN1YnN0cmluZyhyZXN1bHQxLmluZGV4ICsgcmVzdWx0MS50ZXh0Lmxlbmd0aCwgcmVzdWx0Mi5pbmRleCkubWF0Y2godGhpcy5QQVRURVJOKTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBtZXJnZVJlc3VsdCh0ZXh0OiBzdHJpbmcsIGRhdGVSZXN1bHQ6IFBhcnNlZFJlc3VsdCwgdGltZVJlc3VsdDogUGFyc2VkUmVzdWx0KTogUGFyc2VkUmVzdWx0IHtcbiAgICAgICAgY29uc3QgYmVnaW5EYXRlOiBQYXJzZWRDb21wb25lbnRzID0gZGF0ZVJlc3VsdC5zdGFydDtcbiAgICAgICAgY29uc3QgYmVnaW5UaW1lOiBQYXJzZWRDb21wb25lbnRzID0gdGltZVJlc3VsdC5zdGFydDtcbiAgICAgICAgY29uc3QgYmVnaW5EYXRlVGltZTogUGFyc2VkQ29tcG9uZW50cyA9IE1lcmdlRGF0ZVRpbWVSZWZpbmVyLm1lcmdlRGF0ZVRpbWVWYWx1ZXMoYmVnaW5EYXRlLCBiZWdpblRpbWUpO1xuXG4gICAgICAgIGlmIChkYXRlUmVzdWx0LmVuZCB8fCB0aW1lUmVzdWx0LmVuZCkge1xuICAgICAgICAgICAgY29uc3QgZW5kRGF0ZTogUGFyc2VkQ29tcG9uZW50cyA9IGRhdGVSZXN1bHQuZW5kID8gZGF0ZVJlc3VsdC5lbmQgOiBkYXRlUmVzdWx0LnN0YXJ0O1xuICAgICAgICAgICAgY29uc3QgZW5kVGltZTogUGFyc2VkQ29tcG9uZW50cyA9IHRpbWVSZXN1bHQuZW5kID8gdGltZVJlc3VsdC5lbmQgOiB0aW1lUmVzdWx0LnN0YXJ0O1xuICAgICAgICAgICAgY29uc3QgZW5kRGF0ZVRpbWU6IFBhcnNlZENvbXBvbmVudHMgPSBNZXJnZURhdGVUaW1lUmVmaW5lci5tZXJnZURhdGVUaW1lVmFsdWVzKGVuZERhdGUsIGVuZFRpbWUpO1xuXG4gICAgICAgICAgICBpZiAoIWRhdGVSZXN1bHQuZW5kICYmIGVuZERhdGVUaW1lLmRhdGUoKS5nZXRUaW1lKCkgPCBiZWdpbkRhdGVUaW1lLmRhdGUoKS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBFeC4gOXBtIC0gMWFtXG4gICAgICAgICAgICAgICAgaWYgKGVuZERhdGVUaW1lLmlzQ2VydGFpbihEQVkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZERhdGVUaW1lLmFzc2lnbihEQVksIGVuZERhdGVUaW1lLmdldChEQVkpICsgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZVRpbWUuaW1wbHkoREFZLCBlbmREYXRlVGltZS5nZXQoREFZKSArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZVJlc3VsdC5lbmQgPSBlbmREYXRlVGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGVSZXN1bHQuc3RhcnQgPSBiZWdpbkRhdGVUaW1lO1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXg6IG51bWJlciA9IE1hdGgubWluKGRhdGVSZXN1bHQuaW5kZXgsIHRpbWVSZXN1bHQuaW5kZXgpO1xuICAgICAgICBjb25zdCBlbmRJbmRleDogbnVtYmVyID0gTWF0aC5tYXgoXG4gICAgICAgICAgICBkYXRlUmVzdWx0LmluZGV4ICsgZGF0ZVJlc3VsdC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgIHRpbWVSZXN1bHQuaW5kZXggKyB0aW1lUmVzdWx0LnRleHQubGVuZ3RoKTtcblxuICAgICAgICBkYXRlUmVzdWx0LmluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgZGF0ZVJlc3VsdC50ZXh0ID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuXG4gICAgICAgIE9iamVjdC5rZXlzKHRpbWVSZXN1bHQudGFncykuZm9yRWFjaCgodGFnKSA9PiBkYXRlUmVzdWx0LnRhZ3NbdGFnXSA9IHRydWUpO1xuICAgICAgICBkYXRlUmVzdWx0LnRhZ3NbdGhpcy5UQUddID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gZGF0ZVJlc3VsdDtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNEYXRlT25seShyZXN1bHQ6IFBhcnNlZFJlc3VsdCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gIXJlc3VsdC5zdGFydC5pc0NlcnRhaW4oSE9VUik7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzVGltZU9ubHkocmVzdWx0OiBQYXJzZWRSZXN1bHQpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICFyZXN1bHQuc3RhcnQuaXNDZXJ0YWluKE1PTlRIKSAmJiAhcmVzdWx0LnN0YXJ0LmlzQ2VydGFpbihXRUVLREFZKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbWVyZ2VEYXRlVGltZVZhbHVlcyhkYXRlQ29tcG9uZW50OiBQYXJzZWRDb21wb25lbnRzLCB0aW1lQ29tcG9uZW50OiBQYXJzZWRDb21wb25lbnRzKTogUGFyc2VkQ29tcG9uZW50cyB7XG4gICAgICAgIGNvbnN0IGRhdGVUaW1lQ29tcG9uZW50OiBQYXJzZWRDb21wb25lbnRzID0gZGF0ZUNvbXBvbmVudC5jbG9uZSgpO1xuXG4gICAgICAgIGlmICh0aW1lQ29tcG9uZW50LmlzQ2VydGFpbihIT1VSKSkge1xuICAgICAgICAgICAgZGF0ZVRpbWVDb21wb25lbnQuYXNzaWduKEhPVVIsIHRpbWVDb21wb25lbnQuZ2V0KEhPVVIpKTtcbiAgICAgICAgICAgIGRhdGVUaW1lQ29tcG9uZW50LmFzc2lnbihNSU5VVEUsIHRpbWVDb21wb25lbnQuZ2V0KE1JTlVURSkpO1xuXG4gICAgICAgICAgICBpZiAodGltZUNvbXBvbmVudC5pc0NlcnRhaW4oU0VDT05EKSkge1xuICAgICAgICAgICAgICAgIGRhdGVUaW1lQ29tcG9uZW50LmFzc2lnbihTRUNPTkQsIHRpbWVDb21wb25lbnQuZ2V0KFNFQ09ORCkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVDb21wb25lbnQuaXNDZXJ0YWluKE1JTExJU0VDT05EKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlVGltZUNvbXBvbmVudC5hc3NpZ24oTUlMTElTRUNPTkQsIHRpbWVDb21wb25lbnQuZ2V0KE1JTExJU0VDT05EKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVRpbWVDb21wb25lbnQuaW1wbHkoTUlMTElTRUNPTkQsIHRpbWVDb21wb25lbnQuZ2V0KE1JTExJU0VDT05EKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRlVGltZUNvbXBvbmVudC5pbXBseShTRUNPTkQsIHRpbWVDb21wb25lbnQuZ2V0KFNFQ09ORCkpO1xuICAgICAgICAgICAgICAgIGRhdGVUaW1lQ29tcG9uZW50LmltcGx5KE1JTExJU0VDT05ELCB0aW1lQ29tcG9uZW50LmdldChNSUxMSVNFQ09ORCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlVGltZUNvbXBvbmVudC5pbXBseShIT1VSLCB0aW1lQ29tcG9uZW50LmdldChIT1VSKSk7XG4gICAgICAgICAgICBkYXRlVGltZUNvbXBvbmVudC5pbXBseShNSU5VVEUsIHRpbWVDb21wb25lbnQuZ2V0KE1JTlVURSkpO1xuICAgICAgICAgICAgZGF0ZVRpbWVDb21wb25lbnQuaW1wbHkoU0VDT05ELCB0aW1lQ29tcG9uZW50LmdldChTRUNPTkQpKTtcbiAgICAgICAgICAgIGRhdGVUaW1lQ29tcG9uZW50LmltcGx5KE1JTExJU0VDT05ELCB0aW1lQ29tcG9uZW50LmdldChNSUxMSVNFQ09ORCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRpbWVDb21wb25lbnQuaXNDZXJ0YWluKE1FUklESUVNKSkge1xuICAgICAgICAgICAgZGF0ZVRpbWVDb21wb25lbnQuYXNzaWduKE1FUklESUVNLCB0aW1lQ29tcG9uZW50LmdldChNRVJJRElFTSkpO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgdGltZUNvbXBvbmVudC5nZXQoTUVSSURJRU0sIC0xKSAhPT0gLTEgJiZcbiAgICAgICAgICAgIGRhdGVUaW1lQ29tcG9uZW50LmdldChNRVJJRElFTSwgLTEpID09PSAtMVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGRhdGVUaW1lQ29tcG9uZW50LmltcGx5KE1FUklESUVNLCB0aW1lQ29tcG9uZW50LmdldChNRVJJRElFTSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGVUaW1lQ29tcG9uZW50LmdldChNRVJJRElFTSkgPT09IDEgJiYgZGF0ZVRpbWVDb21wb25lbnQuZ2V0KEhPVVIpIDwgMTIpIHtcbiAgICAgICAgICAgIGlmICh0aW1lQ29tcG9uZW50LmlzQ2VydGFpbihIT1VSKSkge1xuICAgICAgICAgICAgICAgIGRhdGVUaW1lQ29tcG9uZW50LmFzc2lnbihIT1VSLCBkYXRlVGltZUNvbXBvbmVudC5nZXQoSE9VUikgKyAxMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGVUaW1lQ29tcG9uZW50LmltcGx5KEhPVVIsIGRhdGVUaW1lQ29tcG9uZW50LmdldChIT1VSKSArIDEyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRlVGltZUNvbXBvbmVudDtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVOTWVyZ2VEYXRlVGltZVJlZmluZXIgZXh0ZW5kcyBNZXJnZURhdGVUaW1lUmVmaW5lciB7XG4gICAgVEFHOiBzdHJpbmcgPSAnRU5NZXJnZURhdGVUaW1lUmVmaW5lcic7XG4gICAgUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cChcIl5cXFxccyooVHxhdHxhZnRlcnxiZWZvcmV8b258b2Z8LHwtKT9cXFxccyokXCIpO1xufSIsImltcG9ydCBSZWZpbmVyIGZyb20gJy4uL3JlZmluZXInO1xuaW1wb3J0IHtQYXJzZWRSZXN1bHR9IGZyb20gXCIuLi8uLi9yZXN1bHRcIjtcbmltcG9ydCB7UGFyc2VPcHRpb25zfSBmcm9tIFwiLi4vLi4vY2hyb25vXCI7XG5pbXBvcnQge0RBWSwgTU9OVEgsIFlFQVJ9IGZyb20gXCIuLi8uLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRU5Qcmlvcml0aXplU3BlY2lmaWNEYXRlUmVmaW5lciBleHRlbmRzIFJlZmluZXIge1xuICAgIHByaXZhdGUgVEFHOiBzdHJpbmcgPSAnRU5Qcmlvcml0aXplU3BlY2lmaWNEYXRlUmVmaW5lcic7XG4gICAgcHJpdmF0ZSBQQVRURVJOOiBSZWdFeHAgPSBuZXcgUmVnRXhwKFwiXlxcXFxzKihhdHxhZnRlcnxiZWZvcmV8b258LHwtfFxcXFwofFxcXFwpKT9cXFxccyokXCIpO1xuXG4gICAgcmVmaW5lKHRleHQ6IHN0cmluZywgcmVzdWx0czogUGFyc2VkUmVzdWx0W10sIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0W10ge1xuICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1lcmdlZFJlc3VsdDogUGFyc2VkUmVzdWx0W10gPSBbXTtcbiAgICAgICAgbGV0IGN1cnJSZXN1bHQ6IFBhcnNlZFJlc3VsdCB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgcHJldlJlc3VsdDogUGFyc2VkUmVzdWx0IHwgbnVsbCA9IG51bGw7XG5cblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgY3VyclJlc3VsdCA9IHJlc3VsdHNbaV07XG4gICAgICAgICAgICBwcmV2UmVzdWx0ID0gcmVzdWx0c1tpIC0gMV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzTW9yZVNwZWNpZmljKHByZXZSZXN1bHQsIGN1cnJSZXN1bHQpICYmIHRoaXMuaXNBYmxlVG9NZXJnZSh0ZXh0LCBwcmV2UmVzdWx0LCBjdXJyUmVzdWx0KSkge1xuXG4gICAgICAgICAgICAgICAgcHJldlJlc3VsdCA9IHRoaXMubWVyZ2VSZXN1bHQodGV4dCwgcHJldlJlc3VsdCwgY3VyclJlc3VsdCk7XG4gICAgICAgICAgICAgICAgY3VyclJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaSArPSAxO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNNb3JlU3BlY2lmaWMoY3VyclJlc3VsdCwgcHJldlJlc3VsdCkgJiYgdGhpcy5pc0FibGVUb01lcmdlKHRleHQsIHByZXZSZXN1bHQsIGN1cnJSZXN1bHQpKSB7XG5cbiAgICAgICAgICAgICAgICBwcmV2UmVzdWx0ID0gdGhpcy5tZXJnZVJlc3VsdCh0ZXh0LCBjdXJyUmVzdWx0LCBwcmV2UmVzdWx0KTtcbiAgICAgICAgICAgICAgICBjdXJyUmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmV2UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkUmVzdWx0LnB1c2gocHJldlJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VyclJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVyZ2VkUmVzdWx0LnB1c2goY3VyclJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWVyZ2VkUmVzdWx0O1xuICAgIH1cblxuICAgIC8vIG5vaW5zcGVjdGlvbiBKU01ldGhvZENhbkJlU3RhdGljXG4gICAgcHJpdmF0ZSBpc01vcmVTcGVjaWZpYyhwcmV2UmVzdWx0OiBQYXJzZWRSZXN1bHQsIGN1cnJSZXN1bHQ6IFBhcnNlZFJlc3VsdCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAocHJldlJlc3VsdC5zdGFydC5pc0NlcnRhaW4oWUVBUikpIHtcbiAgICAgICAgICAgIGlmICghY3VyclJlc3VsdC5zdGFydC5pc0NlcnRhaW4oWUVBUikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldlJlc3VsdC5zdGFydC5pc0NlcnRhaW4oTU9OVEgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VyclJlc3VsdC5zdGFydC5pc0NlcnRhaW4oTU9OVEgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZSZXN1bHQuc3RhcnQuaXNDZXJ0YWluKERBWSkgJiYgIWN1cnJSZXN1bHQuc3RhcnQuaXNDZXJ0YWluKERBWSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc0FibGVUb01lcmdlKHRleHQ6IHN0cmluZywgcHJldlJlc3VsdDogUGFyc2VkUmVzdWx0LCBjdXJyUmVzdWx0OiBQYXJzZWRSZXN1bHQpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgdGV4dEJldHdlZW46IHN0cmluZyA9IHRleHQuc3Vic3RyaW5nKHByZXZSZXN1bHQuaW5kZXggKyBwcmV2UmVzdWx0LnRleHQubGVuZ3RoLCBjdXJyUmVzdWx0LmluZGV4KTtcblxuICAgICAgICAvLyBPbmx5IGFjY2VwdHMgbWVyZ2UgaWYgb25lIG9mIHRoZW0gY29tZXMgZnJvbSBjYXN1YWwgcmVsYXRpdmUgZGF0ZVxuICAgICAgICBjb25zdCBpbmNsdWRlc1JlbGF0aXZlUmVzdWx0OiBib29sZWFuID0gKHByZXZSZXN1bHQudGFnc1snRU5SZWxhdGl2ZURhdGVGb3JtYXRQYXJzZXInXSB8fCBjdXJyUmVzdWx0LnRhZ3NbJ0VOUmVsYXRpdmVEYXRlRm9ybWF0UGFyc2VyJ10pO1xuXG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGV5IHJlZmVyIHRvIHRoZSBzYW1lIGRhdGUgaWYgYWxsIGRhdGUgZmllbGRzIGFyZSBpbXBsaWVkXG4gICAgICAgIGxldCByZWZlclRvU2FtZURhdGU6IGJvb2xlYW4gPSAhcHJldlJlc3VsdC5zdGFydC5pc0NlcnRhaW4oREFZKSAmJiAhcHJldlJlc3VsdC5zdGFydC5pc0NlcnRhaW4oTU9OVEgpICYmICFwcmV2UmVzdWx0LnN0YXJ0LmlzQ2VydGFpbihZRUFSKTtcblxuICAgICAgICAvLyBJZiBib3RoIHllYXJzIGFyZSBjZXJ0YWluLCB0aGF0IGRldGVybWluZXMgaWYgdGhleSByZWZlciB0byB0aGUgc2FtZSBkYXRlXG4gICAgICAgIC8vIGJ1dCB3aXRoIG9uZSBtb3JlIHNwZWNpZmljIHRoYW4gdGhlIG90aGVyXG4gICAgICAgIGlmIChwcmV2UmVzdWx0LnN0YXJ0LmlzQ2VydGFpbihZRUFSKSAmJiBjdXJyUmVzdWx0LnN0YXJ0LmlzQ2VydGFpbihZRUFSKSlcbiAgICAgICAgICAgIHJlZmVyVG9TYW1lRGF0ZSA9IChwcmV2UmVzdWx0LnN0YXJ0LmdldChZRUFSKSA9PT0gY3VyclJlc3VsdC5zdGFydC5nZXQoWUVBUikpO1xuXG4gICAgICAgIC8vIFdlIG5vdyB0ZXN0IHdpdGggdGhlIG5leHQgbGV2ZWwgKG1vbnRoKSBpZiB0aGV5IHJlZmVyIHRvIHRoZSBzYW1lIGRhdGVcbiAgICAgICAgaWYgKHByZXZSZXN1bHQuc3RhcnQuaXNDZXJ0YWluKE1PTlRIKSAmJiBjdXJyUmVzdWx0LnN0YXJ0LmlzQ2VydGFpbihNT05USCkpXG4gICAgICAgICAgICByZWZlclRvU2FtZURhdGUgPSAocHJldlJlc3VsdC5zdGFydC5nZXQoTU9OVEgpID09PSBjdXJyUmVzdWx0LnN0YXJ0LmdldChNT05USCkpICYmIHJlZmVyVG9TYW1lRGF0ZTtcblxuICAgICAgICByZXR1cm4gaW5jbHVkZXNSZWxhdGl2ZVJlc3VsdCAmJiAhIXRleHRCZXR3ZWVuLm1hdGNoKHRoaXMuUEFUVEVSTikgJiYgcmVmZXJUb1NhbWVEYXRlO1xuICAgIH1cblxuICAgIHByaXZhdGUgbWVyZ2VSZXN1bHQodGV4dDogc3RyaW5nLCBzcGVjaWZpY1Jlc3VsdDogUGFyc2VkUmVzdWx0LCBub25TcGVjaWZpY1Jlc3VsdDogUGFyc2VkUmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXg6IG51bWJlciA9IE1hdGgubWluKHNwZWNpZmljUmVzdWx0LmluZGV4LCBub25TcGVjaWZpY1Jlc3VsdC5pbmRleCk7XG4gICAgICAgIGNvbnN0IGVuZEluZGV4OiBudW1iZXIgPSBNYXRoLm1heChcbiAgICAgICAgICAgIHNwZWNpZmljUmVzdWx0LmluZGV4ICsgc3BlY2lmaWNSZXN1bHQudGV4dC5sZW5ndGgsXG4gICAgICAgICAgICBub25TcGVjaWZpY1Jlc3VsdC5pbmRleCArIG5vblNwZWNpZmljUmVzdWx0LnRleHQubGVuZ3RoKTtcblxuICAgICAgICBzcGVjaWZpY1Jlc3VsdC5pbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgICAgIHNwZWNpZmljUmVzdWx0LnRleHQgPSB0ZXh0LnN1YnN0cmluZyhzdGFydEluZGV4LCBlbmRJbmRleCk7XG5cbiAgICAgICAgT2JqZWN0LmtleXMobm9uU3BlY2lmaWNSZXN1bHQudGFncykuZm9yRWFjaCgodGFnKSA9PiBzcGVjaWZpY1Jlc3VsdC50YWdzW3RhZ10gPSB0cnVlKTtcbiAgICAgICAgc3BlY2lmaWNSZXN1bHQudGFnc1t0aGlzLlRBR10gPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBzcGVjaWZpY1Jlc3VsdDtcbiAgICB9XG59IiwiaW1wb3J0IFJlZmluZXIgZnJvbSAnLi9yZWZpbmVyJztcbmltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tIFwiLi4vcmVzdWx0XCI7XG5pbXBvcnQge1BhcnNlT3B0aW9uc30gZnJvbSBcIi4uL2Nocm9ub1wiO1xuaW1wb3J0IHtUSU1FWk9ORV9PRkZTRVR9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXh0cmFjdFRpbWV6b25lQWJiclJlZmluZXIgZXh0ZW5kcyBSZWZpbmVyIHtcbiAgICBwcml2YXRlIFRBRyA9ICdFeHRyYWN0VGltZXpvbmVBYmJyUmVmaW5lcic7XG4gICAgcHJpdmF0ZSBUSU1FWk9ORV9OQU1FX1BBVFRFUk46IFJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJeXFxcXHMqXFxcXCg/KFtBLVpdezIsNH0pXFxcXCk/KD89XFxcXFd8JClcIiwgJ2knKTtcblxuICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBzb21lIGNvbmZpZ3VyYXRpb25cbiAgICBwcml2YXRlIFRJTUVaT05FX0FCQlJfTUFQOiB7W2s6IHN0cmluZ106IG51bWJlcn0gPSB7XCJBQ0RUXCI6NjMwLFwiQUNTVFwiOjU3MCxcIkFEVFwiOi0xODAsXCJBRURUXCI6NjYwLFwiQUVTVFwiOjYwMCxcIkFGVFwiOjI3MCxcIkFLRFRcIjotNDgwLFwiQUtTVFwiOi01NDAsXCJBTE1UXCI6MzYwLFwiQU1TVFwiOi0xODAsXCJBTVRcIjotMjQwLFwiQU5BU1RcIjo3MjAsXCJBTkFUXCI6NzIwLFwiQVFUVFwiOjMwMCxcIkFSVFwiOi0xODAsXCJBU1RcIjotMjQwLFwiQVdEVFwiOjU0MCxcIkFXU1RcIjo0ODAsXCJBWk9TVFwiOjAsXCJBWk9UXCI6LTYwLFwiQVpTVFwiOjMwMCxcIkFaVFwiOjI0MCxcIkJOVFwiOjQ4MCxcIkJPVFwiOi0yNDAsXCJCUlNUXCI6LTEyMCxcIkJSVFwiOi0xODAsXCJCU1RcIjo2MCxcIkJUVFwiOjM2MCxcIkNBU1RcIjo0ODAsXCJDQVRcIjoxMjAsXCJDQ1RcIjozOTAsXCJDRFRcIjotMzAwLFwiQ0VTVFwiOjEyMCxcIkNFVFwiOjYwLFwiQ0hBRFRcIjo4MjUsXCJDSEFTVFwiOjc2NSxcIkNLVFwiOi02MDAsXCJDTFNUXCI6LTE4MCxcIkNMVFwiOi0yNDAsXCJDT1RcIjotMzAwLFwiQ1NUXCI6LTM2MCxcIkNWVFwiOi02MCxcIkNYVFwiOjQyMCxcIkNoU1RcIjo2MDAsXCJEQVZUXCI6NDIwLFwiRUFTU1RcIjotMzAwLFwiRUFTVFwiOi0zNjAsXCJFQVRcIjoxODAsXCJFQ1RcIjotMzAwLFwiRURUXCI6LTI0MCxcIkVFU1RcIjoxODAsXCJFRVRcIjoxMjAsXCJFR1NUXCI6MCxcIkVHVFwiOi02MCxcIkVTVFwiOi0zMDAsXCJFVFwiOi0zMDAsXCJGSlNUXCI6NzgwLFwiRkpUXCI6NzIwLFwiRktTVFwiOi0xODAsXCJGS1RcIjotMjQwLFwiRk5UXCI6LTEyMCxcIkdBTFRcIjotMzYwLFwiR0FNVFwiOi01NDAsXCJHRVRcIjoyNDAsXCJHRlRcIjotMTgwLFwiR0lMVFwiOjcyMCxcIkdNVFwiOjAsXCJHU1RcIjoyNDAsXCJHWVRcIjotMjQwLFwiSEFBXCI6LTE4MCxcIkhBQ1wiOi0zMDAsXCJIQURUXCI6LTU0MCxcIkhBRVwiOi0yNDAsXCJIQVBcIjotNDIwLFwiSEFSXCI6LTM2MCxcIkhBU1RcIjotNjAwLFwiSEFUXCI6LTkwLFwiSEFZXCI6LTQ4MCxcIkhLVFwiOjQ4MCxcIkhMVlwiOi0yMTAsXCJITkFcIjotMjQwLFwiSE5DXCI6LTM2MCxcIkhORVwiOi0zMDAsXCJITlBcIjotNDgwLFwiSE5SXCI6LTQyMCxcIkhOVFwiOi0xNTAsXCJITllcIjotNTQwLFwiSE9WVFwiOjQyMCxcIklDVFwiOjQyMCxcIklEVFwiOjE4MCxcIklPVFwiOjM2MCxcIklSRFRcIjoyNzAsXCJJUktTVFwiOjU0MCxcIklSS1RcIjo1NDAsXCJJUlNUXCI6MjEwLFwiSVNUXCI6NjAsXCJKU1RcIjo1NDAsXCJLR1RcIjozNjAsXCJLUkFTVFwiOjQ4MCxcIktSQVRcIjo0ODAsXCJLU1RcIjo1NDAsXCJLVVlUXCI6MjQwLFwiTEhEVFwiOjY2MCxcIkxIU1RcIjo2MzAsXCJMSU5UXCI6ODQwLFwiTUFHU1RcIjo3MjAsXCJNQUdUXCI6NzIwLFwiTUFSVFwiOi01MTAsXCJNQVdUXCI6MzAwLFwiTURUXCI6LTM2MCxcIk1FU1pcIjoxMjAsXCJNRVpcIjo2MCxcIk1IVFwiOjcyMCxcIk1NVFwiOjM5MCxcIk1TRFwiOjI0MCxcIk1TS1wiOjI0MCxcIk1TVFwiOi00MjAsXCJNVVRcIjoyNDAsXCJNVlRcIjozMDAsXCJNWVRcIjo0ODAsXCJOQ1RcIjo2NjAsXCJORFRcIjotOTAsXCJORlRcIjo2OTAsXCJOT1ZTVFwiOjQyMCxcIk5PVlRcIjozNjAsXCJOUFRcIjozNDUsXCJOU1RcIjotMTUwLFwiTlVUXCI6LTY2MCxcIk5aRFRcIjo3ODAsXCJOWlNUXCI6NzIwLFwiT01TU1RcIjo0MjAsXCJPTVNUXCI6NDIwLFwiUERUXCI6LTQyMCxcIlBFVFwiOi0zMDAsXCJQRVRTVFwiOjcyMCxcIlBFVFRcIjo3MjAsXCJQR1RcIjo2MDAsXCJQSE9UXCI6NzgwLFwiUEhUXCI6NDgwLFwiUEtUXCI6MzAwLFwiUE1EVFwiOi0xMjAsXCJQTVNUXCI6LTE4MCxcIlBPTlRcIjo2NjAsXCJQU1RcIjotNDgwLFwiUFRcIjotNDgwLFwiUFdUXCI6NTQwLFwiUFlTVFwiOi0xODAsXCJQWVRcIjotMjQwLFwiUkVUXCI6MjQwLFwiU0FNVFwiOjI0MCxcIlNBU1RcIjoxMjAsXCJTQlRcIjo2NjAsXCJTQ1RcIjoyNDAsXCJTR1RcIjo0ODAsXCJTUlRcIjotMTgwLFwiU1NUXCI6LTY2MCxcIlRBSFRcIjotNjAwLFwiVEZUXCI6MzAwLFwiVEpUXCI6MzAwLFwiVEtUXCI6NzgwLFwiVExUXCI6NTQwLFwiVE1UXCI6MzAwLFwiVFZUXCI6NzIwLFwiVUxBVFwiOjQ4MCxcIlVUQ1wiOjAsXCJVWVNUXCI6LTEyMCxcIlVZVFwiOi0xODAsXCJVWlRcIjozMDAsXCJWRVRcIjotMjEwLFwiVkxBU1RcIjo2NjAsXCJWTEFUXCI6NjYwLFwiVlVUXCI6NjYwLFwiV0FTVFwiOjEyMCxcIldBVFwiOjYwLFwiV0VTVFwiOjYwLFwiV0VTWlwiOjYwLFwiV0VUXCI6MCxcIldFWlwiOjAsXCJXRlRcIjo3MjAsXCJXR1NUXCI6LTEyMCxcIldHVFwiOi0xODAsXCJXSUJcIjo0MjAsXCJXSVRcIjo1NDAsXCJXSVRBXCI6NDgwLFwiV1NUXCI6NzgwLFwiV1RcIjowLFwiWUFLU1RcIjo2MDAsXCJZQUtUXCI6NjAwLFwiWUFQVFwiOjYwMCxcIllFS1NUXCI6MzYwLFwiWUVLVFwiOjM2MH07XG5cbiAgICByZWZpbmUodGV4dDogc3RyaW5nLCByZXN1bHRzOiBQYXJzZWRSZXN1bHRbXSwgb3B0OiBQYXJzZU9wdGlvbnMpOiBQYXJzZWRSZXN1bHRbXSB7XG5cbiAgICAgICAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQ6IFBhcnNlZFJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQudGFnc1snRU5UaW1lRXhwcmVzc2lvblBhcnNlciddICYmICFyZXN1bHQudGFnc1snWkhUaW1lRXhwcmVzc2lvblBhcnNlciddICYmICFyZXN1bHQudGFnc1snRlJUaW1lRXhwcmVzc2lvblBhcnNlciddICYmICFyZXN1bHQudGFnc1snREVUaW1lRXhwcmVzc2lvblBhcnNlciddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBtYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbCA9IHRoaXMuVElNRVpPTkVfTkFNRV9QQVRURVJOLmV4ZWModGV4dC5zdWJzdHJpbmcocmVzdWx0LmluZGV4ICsgcmVzdWx0LnRleHQubGVuZ3RoKSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lem9uZUFiYnI6IHN0cmluZyA9IG1hdGNoWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLlRJTUVaT05FX0FCQlJfTUFQLmhhc093blByb3BlcnR5KHRpbWV6b25lQWJicikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWV6b25lT2Zmc2V0OiBudW1iZXIgPSB0aGlzLlRJTUVaT05FX0FCQlJfTUFQW3RpbWV6b25lQWJicl07XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5zdGFydC5pc0NlcnRhaW4oVElNRVpPTkVfT0ZGU0VUKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKFRJTUVaT05FX09GRlNFVCwgdGltZXpvbmVPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZW5kICYmICFyZXN1bHQuZW5kLmlzQ2VydGFpbihUSU1FWk9ORV9PRkZTRVQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lbmQuYXNzaWduKFRJTUVaT05FX09GRlNFVCwgdGltZXpvbmVPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdC50ZXh0ICs9IG1hdGNoWzBdO1xuICAgICAgICAgICAgICAgIHJlc3VsdC50YWdzW3RoaXMuVEFHXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbn0iLCJpbXBvcnQgUmVmaW5lciBmcm9tICcuL3JlZmluZXInO1xuaW1wb3J0IHtQYXJzZWRSZXN1bHR9IGZyb20gXCIuLi9yZXN1bHRcIjtcbmltcG9ydCB7UGFyc2VPcHRpb25zfSBmcm9tIFwiLi4vY2hyb25vXCI7XG5pbXBvcnQge1RJTUVaT05FX09GRlNFVH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeHRyYWN0VGltZXpvbmVPZmZzZXRSZWZpbmVyIGV4dGVuZHMgUmVmaW5lciB7XG4gICAgcHJpdmF0ZSBUQUcgPSAnRXh0cmFjdFRpbWV6b25lT2Zmc2V0UmVmaW5lcic7XG4gICAgcHJpdmF0ZSBUSU1FWk9ORV9PRkZTRVRfUEFUVEVSTjogUmVnRXhwID0gbmV3IFJlZ0V4cChcIl5cXFxccyooR01UfFVUQyk/KFxcXFwrfFxcXFwtKShcXFxcZHsxLDJ9KTo/KFxcXFxkezJ9KVwiLCAnaScpO1xuXG4gICAgcHJpdmF0ZSBUSU1FWk9ORV9PRkZTRVRfU0lHTl9HUk9VUDogbnVtYmVyID0gMjtcbiAgICBwcml2YXRlIFRJTUVaT05FX09GRlNFVF9IT1VSX09GRlNFVF9HUk9VUDogbnVtYmVyID0gMztcbiAgICBwcml2YXRlIFRJTUVaT05FX09GRlNFVF9NSU5VVEVfT0ZGU0VUX0dST1VQOiBudW1iZXIgPSA0O1xuXG4gICAgcmVmaW5lKHRleHQ6IHN0cmluZywgcmVzdWx0czogUGFyc2VkUmVzdWx0W10sIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0W10ge1xuICAgICAgICByZXN1bHRzLmZvckVhY2goKHJlc3VsdDogUGFyc2VkUmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN0YXJ0LmlzQ2VydGFpbihUSU1FWk9ORV9PRkZTRVQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBtYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbCA9IHRoaXMuVElNRVpPTkVfT0ZGU0VUX1BBVFRFUk4uZXhlYyh0ZXh0LnN1YnN0cmluZyhyZXN1bHQuaW5kZXggKyByZXN1bHQudGV4dC5sZW5ndGgpKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGhvdXJPZmZzZXQ6IG51bWJlciA9IHBhcnNlSW50KG1hdGNoW3RoaXMuVElNRVpPTkVfT0ZGU0VUX0hPVVJfT0ZGU0VUX0dST1VQXSwgMTApO1xuICAgICAgICAgICAgY29uc3QgbWludXRlT2Zmc2V0OiBudW1iZXIgPSBwYXJzZUludChtYXRjaFt0aGlzLlRJTUVaT05FX09GRlNFVF9NSU5VVEVfT0ZGU0VUX0dST1VQXSwgMTApO1xuICAgICAgICAgICAgbGV0IHRpbWV6b25lT2Zmc2V0OiBudW1iZXIgPSBob3VyT2Zmc2V0ICogNjAgKyBtaW51dGVPZmZzZXQ7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaFt0aGlzLlRJTUVaT05FX09GRlNFVF9TSUdOX0dST1VQXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgdGltZXpvbmVPZmZzZXQgPSAtdGltZXpvbmVPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQuZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZW5kLmFzc2lnbihUSU1FWk9ORV9PRkZTRVQsIHRpbWV6b25lT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihUSU1FWk9ORV9PRkZTRVQsIHRpbWV6b25lT2Zmc2V0KTtcblxuICAgICAgICAgICAgcmVzdWx0LnRleHQgKz0gbWF0Y2hbMF07XG5cbiAgICAgICAgICAgIHJlc3VsdC50YWdzW3RoaXMuVEFHXSA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbn1cbiIsImltcG9ydCB7TWVyZ2VEYXRlUmFuZ2VSZWZpbmVyfSBmcm9tICcuLi9FTi9FTk1lcmdlRGF0ZVJhbmdlUmVmaW5lcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZSTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyIGV4dGVuZHMgTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyIHtcbiAgICBQQVRURVJOOiBSZWdFeHAgPSAvXlxccyooW8OgYVxcLV0pXFxzKiQvaTtcbiAgICBUQUc6IHN0cmluZyA9ICdGUk1lcmdlRGF0ZVJhbmdlUmVmaW5lcic7XG59XG4iLCJpbXBvcnQge01lcmdlRGF0ZVRpbWVSZWZpbmVyfSBmcm9tIFwiLi4vRU4vRU5NZXJnZURhdGVUaW1lUmVmaW5lclwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGUk1lcmdlRGF0ZVRpbWVSZWZpbmVyIGV4dGVuZHMgTWVyZ2VEYXRlVGltZVJlZmluZXIge1xuICAgIFRBRzogc3RyaW5nID0gJ0ZSTWVyZ2VEYXRlVGltZVJlZmluZXInO1xuICAgIFBBVFRFUk46IFJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJeXFxcXHMqKFR8w6B8YXx2ZXJzfGRlfCx8LSk/XFxcXHMqJFwiKTtcbn0iLCIvKlxuICAgIEVuZm9yY2UgJ2ZvcndhcmREYXRlJyBvcHRpb24gdG8gb24gdGhlIHJlc3VsdHMuIFdoZW4gdGhlcmUgYXJlIG1pc3NpbmcgY29tcG9uZW50LFxuICAgIGUuZy4gXCJNYXJjaCAxMi0xMyAod2l0aG91dCB5ZWFyKVwiIG9yIFwiVGh1cnNkYXlcIiwgdGhlIHJlZmluZXIgd2lsbCB0cnkgdG8gYWRqdXN0IHRoZSByZXN1bHRcbiAgICBpbnRvIHRoZSBmdXR1cmUgaW5zdGVhZCBvZiB0aGUgcGFzdC5cbiovXG5pbXBvcnQgUmVmaW5lciBmcm9tICcuL3JlZmluZXInO1xuaW1wb3J0IHtQYXJzZWRSZXN1bHR9IGZyb20gXCIuLi9yZXN1bHRcIjtcbmltcG9ydCB7UGFyc2VPcHRpb25zfSBmcm9tIFwiLi4vY2hyb25vXCI7XG5pbXBvcnQge0RBWSwgTU9OVEgsIFdFRUtEQVksIFlFQVJ9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCAqIGFzIG1vbWVudCBmcm9tIFwibW9tZW50XCI7XG5pbXBvcnQge01vbWVudH0gZnJvbSBcIm1vbWVudFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb3J3YXJkRGF0ZVJlZmluZXIgZXh0ZW5kcyBSZWZpbmVyIHtcbiAgICBwcml2YXRlIFRBRyA9ICdGb3J3YXJkRGF0ZVJlZmluZXInO1xuXG4gICAgcmVmaW5lKHRleHQ6IHN0cmluZywgcmVzdWx0czogUGFyc2VkUmVzdWx0W10sIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0W10ge1xuICAgICAgICBpZiAoIW9wdC5mb3J3YXJkRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRzLmZvckVhY2goKHJlc3VsdDogUGFyc2VkUmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWZNb21lbnQ6IE1vbWVudCA9IG1vbWVudChyZXN1bHQucmVmKTtcblxuXG4gICAgICAgICAgICAvLyBkYXkgYW5kIG1vbnRoIGFyZSBjZXJ0YWluLCBidXQgbm90IHllYXJcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhcnQuaXNDZXJ0YWluKERBWSkgJiYgcmVzdWx0LnN0YXJ0LmlzQ2VydGFpbihNT05USCkgJiYgIXJlc3VsdC5zdGFydC5pc0NlcnRhaW4oWUVBUikgJiYgcmVmTW9tZW50LmlzQWZ0ZXIocmVzdWx0LnN0YXJ0Lm1vbWVudCgpKSkge1xuICAgICAgICAgICAgICAgIC8vIEFkanVzdCB5ZWFyIGludG8gdGhlIGZ1dHVyZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMyAmJiByZWZNb21lbnQuaXNBZnRlcihyZXN1bHQuc3RhcnQubW9tZW50KCkpOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KFlFQVIsIHJlc3VsdC5zdGFydC5nZXQoWUVBUikgKyAxKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVuZCAmJiAhcmVzdWx0LmVuZC5pc0NlcnRhaW4oWUVBUikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lbmQuaW1wbHkoWUVBUiwgcmVzdWx0LmVuZC5nZXQoWUVBUikgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQudGFnc1t0aGlzLlRBR10gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkYXRlIGlzIHVuY2VydGFpbiwgYnV0IHdlZWtkYXkgaXMga25vd25cbiAgICAgICAgICAgIGlmICghcmVzdWx0LnN0YXJ0LmlzQ2VydGFpbihEQVkpICYmICFyZXN1bHQuc3RhcnQuaXNDZXJ0YWluKE1PTlRIKSAmJiAhcmVzdWx0LnN0YXJ0LmlzQ2VydGFpbihZRUFSKSAmJiByZXN1bHQuc3RhcnQuaXNDZXJ0YWluKFdFRUtEQVkpICYmIHJlZk1vbWVudC5pc0FmdGVyKHJlc3VsdC5zdGFydC5tb21lbnQoKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGp1c3QgZGF0ZSB0byB0aGUgY29taW5nIHdlZWtcbiAgICAgICAgICAgICAgICBpZiAocmVmTW9tZW50LmRheSgpID4gcmVzdWx0LnN0YXJ0LmdldChXRUVLREFZKSkge1xuICAgICAgICAgICAgICAgICAgICByZWZNb21lbnQuZGF5KHJlc3VsdC5zdGFydC5nZXQoV0VFS0RBWSkgKyA3KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWZNb21lbnQuZGF5KHJlc3VsdC5zdGFydC5nZXQoV0VFS0RBWSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShEQVksIHJlZk1vbWVudC5kYXRlKCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNT05USCwgcmVmTW9tZW50Lm1vbnRoKCkgKyAxKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoWUVBUiwgcmVmTW9tZW50LnllYXIoKSk7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQudGFnc1t0aGlzLlRBR10gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG59IiwiaW1wb3J0IHtNZXJnZURhdGVUaW1lUmVmaW5lcn0gZnJvbSBcIi4uL0VOL0VOTWVyZ2VEYXRlVGltZVJlZmluZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSlBNZXJnZURhdGVUaW1lUmVmaW5lciBleHRlbmRzIE1lcmdlRGF0ZVRpbWVSZWZpbmVyIHtcbiAgICBUQUc6IHN0cmluZyA9ICdKUE1lcmdlRGF0ZVRpbWVSZWZpbmVyJztcbiAgICBQQVRURVJOOiBSZWdFeHAgPSAvXlxccyoo44GL44KJfOODvClcXHMqJC9pO1xufSIsImltcG9ydCBSZWZpbmVyIGZyb20gJy4vcmVmaW5lcic7XG5pbXBvcnQge1BhcnNlZFJlc3VsdH0gZnJvbSBcIi4uL3Jlc3VsdFwiO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi9jaHJvbm9cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3ZlcmxhcFJlbW92YWxSZWZpbmVyIGV4dGVuZHMgUmVmaW5lciB7XG4gICAgcmVmaW5lKHRleHQ6IHN0cmluZywgcmVzdWx0czogUGFyc2VkUmVzdWx0W10sIG9wdDogUGFyc2VPcHRpb25zKTogUGFyc2VkUmVzdWx0W10ge1xuICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpbHRlcmVkUmVzdWx0czogUGFyc2VkUmVzdWx0W10gPSBbXTtcbiAgICAgICAgbGV0IHByZXZSZXN1bHQ6IFBhcnNlZFJlc3VsdCA9IHJlc3VsdHNbMF07XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogUGFyc2VkUmVzdWx0ID0gcmVzdWx0c1tpXTtcblxuICAgICAgICAgICAgLy8gSWYgb3ZlcmxhcCwgY29tcGFyZSB0aGUgbGVuZ3RoIGFuZCBkaXNjYXJkIHRoZSBzaG9ydGVyIG9uZVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5pbmRleCA8IHByZXZSZXN1bHQuaW5kZXggKyBwcmV2UmVzdWx0LnRleHQubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnRleHQubGVuZ3RoID4gcHJldlJlc3VsdC50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2UmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZFJlc3VsdHMucHVzaChwcmV2UmVzdWx0KTtcbiAgICAgICAgICAgICAgICBwcmV2UmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGxhc3Qgb25lXG4gICAgICAgIGlmIChwcmV2UmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkUmVzdWx0cy5wdXNoKHByZXZSZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkUmVzdWx0cztcbiAgICB9XG59IiwiaW1wb3J0IHtGaWx0ZXJ9IGZyb20gJy4vcmVmaW5lcic7XG5pbXBvcnQge1BhcnNlZFJlc3VsdH0gZnJvbSBcIi4uL3Jlc3VsdFwiO1xuaW1wb3J0IHtQYXJzZU9wdGlvbnN9IGZyb20gXCIuLi9jaHJvbm9cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVW5saWtlbHlGb3JtYXRGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXIge1xuICAgIHByaXZhdGUgUkVHRVg6IFJlZ0V4cCA9IC9eXFxkKihcXC5cXGQqKT8kLztcblxuICAgIGlzVmFsaWQodGV4dDogc3RyaW5nLCByZXN1bHQ6IFBhcnNlZFJlc3VsdCwgb3B0OiBQYXJzZU9wdGlvbnMpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICFyZXN1bHQudGV4dC5yZXBsYWNlKCcgJywnJykubWF0Y2godGhpcy5SRUdFWCk7XG4gICAgfVxufSIsImltcG9ydCB7UGFyc2VkUmVzdWx0fSBmcm9tIFwiLi4vcmVzdWx0XCI7XG5pbXBvcnQge1BhcnNlT3B0aW9uc30gZnJvbSBcIi4uL2Nocm9ub1wiO1xuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBSZWZpbmVyIHtcbiAgICBhYnN0cmFjdCByZWZpbmUodGV4dDogc3RyaW5nLCByZXN1bHRzOiBQYXJzZWRSZXN1bHRbXSwgb3B0OiBQYXJzZU9wdGlvbnMpOiBQYXJzZWRSZXN1bHRbXTtcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEZpbHRlciBleHRlbmRzIFJlZmluZXIge1xuICAgIGFic3RyYWN0IGlzVmFsaWQodGV4dDogc3RyaW5nLCByZXN1bHQ6IFBhcnNlZFJlc3VsdCwgb3B0OiBQYXJzZU9wdGlvbnMpOiBib29sZWFuO1xuICAgIHJlZmluZSh0ZXh0OiBzdHJpbmcsIHJlc3VsdHM6IFBhcnNlZFJlc3VsdFtdLCBvcHQ6IFBhcnNlT3B0aW9ucyk6IFBhcnNlZFJlc3VsdFtdIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHMuZmlsdGVyKChyZXN1bHQ6IFBhcnNlZFJlc3VsdCkgPT4gdGhpcy5pc1ZhbGlkKHRleHQsIHJlc3VsdCwgb3B0KSk7XG4gICAgfTtcbn1cblxuXG5cbi8vIENvbW1vbiByZWZpbmVyc1xuZXhwb3J0IHtkZWZhdWx0IGFzIE92ZXJsYXBSZW1vdmFsUmVmaW5lcn0gZnJvbSAnLi9PdmVybGFwUmVtb3ZhbFJlZmluZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEV4dHJhY3RUaW1lem9uZU9mZnNldFJlZmluZXJ9IGZyb20gJy4vRXh0cmFjdFRpbWV6b25lT2Zmc2V0UmVmaW5lcic7XG5leHBvcnQge2RlZmF1bHQgYXMgRXh0cmFjdFRpbWV6b25lQWJiclJlZmluZXJ9IGZyb20gJy4vRXh0cmFjdFRpbWV6b25lQWJiclJlZmluZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEZvcndhcmREYXRlUmVmaW5lcn0gZnJvbSAnLi9Gb3J3YXJkRGF0ZVJlZmluZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIFVubGlrZWx5Rm9ybWF0RmlsdGVyfSBmcm9tICcuL1VubGlrZWx5Rm9ybWF0RmlsdGVyJztcblxuLy8gRU4gcmVmaW5lcnNcbmV4cG9ydCB7ZGVmYXVsdCBhcyBFTk1lcmdlRGF0ZVRpbWVSZWZpbmVyfSBmcm9tICcuL0VOL0VOTWVyZ2VEYXRlVGltZVJlZmluZXInO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEVOTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyfSBmcm9tICcuL0VOL0VOTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBFTlByaW9yaXRpemVTcGVjaWZpY0RhdGVSZWZpbmVyfSBmcm9tICcuL0VOL0VOUHJpb3JpdGl6ZVNwZWNpZmljRGF0ZVJlZmluZXInO1xuXG4vLyBKUCByZWZpbmVyc1xuZXhwb3J0IHtkZWZhdWx0IGFzIEpQTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyfSBmcm9tICcuL0pQL0pQTWVyZ2VEYXRlUmFuZ2VSZWZpbmVyJztcblxuLy8gRlIgcmVmaW5lcnNcbmV4cG9ydCB7ZGVmYXVsdCBhcyBGUk1lcmdlRGF0ZVJhbmdlUmVmaW5lcn0gZnJvbSAnLi9GUi9GUk1lcmdlRGF0ZVJhbmdlUmVmaW5lcic7XG5leHBvcnQge2RlZmF1bHQgYXMgRlJNZXJnZURhdGVUaW1lUmVmaW5lcn0gZnJvbSAnLi9GUi9GUk1lcmdlRGF0ZVRpbWVSZWZpbmVyJztcblxuLy8gREUgcmVmaW5lcnNcbmV4cG9ydCB7ZGVmYXVsdCBhcyBERU1lcmdlRGF0ZVJhbmdlUmVmaW5lcn0gZnJvbSAnLi9ERS9ERU1lcmdlRGF0ZVJhbmdlUmVmaW5lcic7XG5leHBvcnQge2RlZmF1bHQgYXMgREVNZXJnZURhdGVUaW1lUmVmaW5lcn0gZnJvbSAnLi9ERS9ERU1lcmdlRGF0ZVRpbWVSZWZpbmVyJztcbiIsImltcG9ydCAqIGFzIG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHtNb21lbnR9IGZyb20gJ21vbWVudCc7XG5pbXBvcnQge0hPVVIsIE1JTlVURSwgU0VDT05ELCBNSUxMSVNFQ09ORCwgREFZLCBNT05USCwgWUVBUiwgVElNRVpPTkVfT0ZGU0VUfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCB0eXBlIFRJTUVfQ09NUE9ORU5UX05BTUUgPSAnaG91cidcbiAgICB8ICdtaW51dGUnXG4gICAgfCAnc2Vjb25kJ1xuICAgIHwgJ21pbGxpc2Vjb25kJ1xuICAgIHwgJ21lcmlkaWVtJztcblxuZXhwb3J0IHR5cGUgREFURV9DT01QT05FTlRfTkFNRSA9ICdkYXknXG4gICAgfCAnbW9udGgnXG4gICAgfCAneWVhcidcblxuZXhwb3J0IHR5cGUgQ09NUE9ORU5UX05BTUUgPVxuICAgIFRJTUVfQ09NUE9ORU5UX05BTUVcbiAgICB8IERBVEVfQ09NUE9ORU5UX05BTUVcbiAgICB8ICd3ZWVrZGF5J1xuICAgIHwgJ3RpbWV6b25lT2Zmc2V0JztcblxuZXhwb3J0IHR5cGUgQ29tcG9uZW50Q29sbGVjdGlvbiA9IHtbayBpbiBDT01QT05FTlRfTkFNRV0/OiBudW1iZXI7fVxuXG5leHBvcnQgdHlwZSBSZXN1bHRQYXJ0cyA9IHtcbiAgICByZWY6IERhdGU7XG4gICAgaW5kZXg6IG51bWJlcjtcbiAgICB0ZXh0OiBzdHJpbmc7XG4gICAgdGFncz86IHtcbiAgICAgICAgW2s6IHN0cmluZ106IHRydWU7XG4gICAgfTtcbiAgICBzdGFydD86IENvbXBvbmVudENvbGxlY3Rpb247XG4gICAgZW5kPzogQ29tcG9uZW50Q29sbGVjdGlvbjtcbn1cblxuXG5leHBvcnQgY2xhc3MgUGFyc2VkUmVzdWx0IHtcbiAgICByZWY6IERhdGU7XG4gICAgaW5kZXg6IG51bWJlcjtcbiAgICB0ZXh0OiBzdHJpbmc7XG4gICAgdGFnczoge1xuICAgICAgICBbazogc3RyaW5nXTogdHJ1ZVxuICAgIH07XG4gICAgc3RhcnQ6IFBhcnNlZENvbXBvbmVudHM7XG4gICAgZW5kPzogUGFyc2VkQ29tcG9uZW50cztcblxuICAgIGNvbnN0cnVjdG9yKHJlc3VsdDogUmVzdWx0UGFydHMpIHtcbiAgICAgICAgdGhpcy5yZWYgPSByZXN1bHQucmVmO1xuICAgICAgICB0aGlzLmluZGV4ID0gcmVzdWx0LmluZGV4O1xuICAgICAgICB0aGlzLnRleHQgPSByZXN1bHQudGV4dDtcbiAgICAgICAgdGhpcy50YWdzID0gcmVzdWx0LnRhZ3MgfHwge307XG5cbiAgICAgICAgdGhpcy5zdGFydCA9IG5ldyBQYXJzZWRDb21wb25lbnRzKHJlc3VsdC5zdGFydCwgcmVzdWx0LnJlZik7XG4gICAgICAgIGlmIChyZXN1bHQuZW5kKSB7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IG5ldyBQYXJzZWRDb21wb25lbnRzKHJlc3VsdC5lbmQsIHJlc3VsdC5yZWYpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbG9uZSgpOiBQYXJzZWRSZXN1bHQge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUGFyc2VkUmVzdWx0KHtcbiAgICAgICAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0LnRhZ3MgPSB7Li4udGhpcy50YWdzfTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0ID0gdGhpcy5zdGFydC5jbG9uZSgpO1xuICAgICAgICBpZiAodGhpcy5lbmQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lbmQgPSB0aGlzLmVuZC5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgaGFzUG9zc2libGVEYXRlcygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQuaXNQb3NzaWJsZURhdGUoKSAmJiAoIXRoaXMuZW5kIHx8IHRoaXMuZW5kLmlzUG9zc2libGVEYXRlKCkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFBhcnNlZENvbXBvbmVudHMge1xuICAgIGtub3duVmFsdWVzOiBDb21wb25lbnRDb2xsZWN0aW9uID0ge307XG4gICAgaW1wbGllZFZhbHVlczogQ29tcG9uZW50Q29sbGVjdGlvbiA9IHt9O1xuXG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50cz86IENvbXBvbmVudENvbGxlY3Rpb24sIHJlZj86IERhdGUpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIChPYmplY3Qua2V5cyhjb21wb25lbnRzKSBhcyBDT01QT05FTlRfTkFNRVtdKS5mb3JFYWNoKChrZXk6IENPTVBPTkVOVF9OQU1FKSA9PiB0aGlzLmtub3duVmFsdWVzW2tleV0gPSBjb21wb25lbnRzW2tleV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgICAgY29uc3QgcmVmTW9tZW50OiBNb21lbnQgPSBtb21lbnQocmVmKTtcbiAgICAgICAgICAgIHRoaXMuaW1wbHkoREFZLCByZWZNb21lbnQuZGF0ZSgpKTtcbiAgICAgICAgICAgIHRoaXMuaW1wbHkoTU9OVEgsIHJlZk1vbWVudC5tb250aCgpICsgMSk7XG4gICAgICAgICAgICB0aGlzLmltcGx5KFlFQVIsIHJlZk1vbWVudC55ZWFyKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbXBseShIT1VSLCAxMik7XG4gICAgICAgIHRoaXMuaW1wbHkoTUlOVVRFLCAwKTtcbiAgICAgICAgdGhpcy5pbXBseShTRUNPTkQsIDApO1xuICAgICAgICB0aGlzLmltcGx5KE1JTExJU0VDT05ELCAwKTtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50OiBQYXJzZWRDb21wb25lbnRzID0gbmV3IFBhcnNlZENvbXBvbmVudHMoKTtcbiAgICAgICAgY29tcG9uZW50Lmtub3duVmFsdWVzID0gey4uLnRoaXMua25vd25WYWx1ZXN9O1xuICAgICAgICBjb21wb25lbnQuaW1wbGllZFZhbHVlcyA9IHsuLi50aGlzLmltcGxpZWRWYWx1ZXN9O1xuICAgICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgIH1cblxuICAgIGdldChjb21wb25lbnQ6IENPTVBPTkVOVF9OQU1FLCBkZWZhdWx0UmV0dXJuOiBudW1iZXIgPSAwKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDZXJ0YWluKGNvbXBvbmVudCkgPyB0aGlzLmtub3duVmFsdWVzW2NvbXBvbmVudF0hIDogKFxuICAgICAgICAgICAgKGNvbXBvbmVudCBpbiB0aGlzLmltcGxpZWRWYWx1ZXMpID8gdGhpcy5pbXBsaWVkVmFsdWVzW2NvbXBvbmVudF0hIDogZGVmYXVsdFJldHVyblxuICAgICAgICApO1xuICAgIH1cblxuICAgIGFzc2lnbihjb21wb25lbnQ6IENPTVBPTkVOVF9OQU1FLCB2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMua25vd25WYWx1ZXNbY29tcG9uZW50XSA9IHZhbHVlO1xuICAgICAgICBkZWxldGUgdGhpcy5pbXBsaWVkVmFsdWVzW2NvbXBvbmVudF07XG4gICAgfVxuXG4gICAgaW1wbHkoY29tcG9uZW50OiBDT01QT05FTlRfTkFNRSwgdmFsdWU6IG51bWJlcikge1xuICAgICAgICBpZiAoIXRoaXMuaXNDZXJ0YWluKGNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW1wbGllZFZhbHVlc1tjb21wb25lbnRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0NlcnRhaW4oY29tcG9uZW50OiBDT01QT05FTlRfTkFNRSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50IGluIHRoaXMua25vd25WYWx1ZXM7XG4gICAgfVxuXG4gICAgaXNQb3NzaWJsZURhdGUoKSB7XG4gICAgICAgIGNvbnN0IGRhdGVNb21lbnQ6IE1vbWVudCA9IHRoaXMubW9tZW50KCk7XG4gICAgICAgIGlmICh0aGlzLmlzQ2VydGFpbihUSU1FWk9ORV9PRkZTRVQpKSB7XG4gICAgICAgICAgICBkYXRlTW9tZW50LnV0Y09mZnNldCh0aGlzLmdldChUSU1FWk9ORV9PRkZTRVQpKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGVNb21lbnQuZ2V0KCdtaW51dGUnKSA9PT0gdGhpcy5nZXQoTUlOVVRFKVxuICAgICAgICAgICAgJiYgZGF0ZU1vbWVudC5nZXQoJ2hvdXInKSA9PT0gdGhpcy5nZXQoSE9VUilcbiAgICAgICAgICAgICYmIGRhdGVNb21lbnQuZ2V0KCd5ZWFyJykgPT09IHRoaXMuZ2V0KFlFQVIpXG4gICAgICAgICAgICAmJiBkYXRlTW9tZW50LmdldCgnbW9udGgnKSA9PT0gdGhpcy5nZXQoTU9OVEgpIC0gMVxuICAgICAgICAgICAgJiYgZGF0ZU1vbWVudC5nZXQoJ2RhdGUnKSA9PT0gdGhpcy5nZXQoREFZKTtcbiAgICB9O1xuXG4gICAgZGF0ZSgpOiBEYXRlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9tZW50KCkudG9EYXRlKCk7XG4gICAgfVxuXG4gICAgbW9tZW50KCk6IE1vbWVudCB7XG4gICAgICAgIGNvbnN0IGRhdGVNb21lbnQ6IE1vbWVudCA9IG1vbWVudCgpO1xuXG4gICAgICAgIGRhdGVNb21lbnQuc2V0KCd5ZWFyJywgdGhpcy5nZXQoWUVBUikpO1xuICAgICAgICBkYXRlTW9tZW50LnNldCgnbW9udGgnLCB0aGlzLmdldChNT05USCkgLSAxKTtcbiAgICAgICAgZGF0ZU1vbWVudC5zZXQoJ2RhdGUnLCB0aGlzLmdldChEQVkpKTtcbiAgICAgICAgZGF0ZU1vbWVudC5zZXQoJ2hvdXInLCB0aGlzLmdldChIT1VSKSk7XG4gICAgICAgIGRhdGVNb21lbnQuc2V0KCdtaW51dGUnLCB0aGlzLmdldChNSU5VVEUpKTtcbiAgICAgICAgZGF0ZU1vbWVudC5zZXQoJ3NlY29uZCcsIHRoaXMuZ2V0KFNFQ09ORCkpO1xuICAgICAgICBkYXRlTW9tZW50LnNldCgnbWlsbGlzZWNvbmQnLCB0aGlzLmdldChNSUxMSVNFQ09ORCkpO1xuXG4gICAgICAgIC8vIEphdmFzY3JpcHQgRGF0ZSBPYmplY3QgcmV0dXJuIG1pbnVzIHRpbWV6b25lIG9mZnNldFxuICAgICAgICBjb25zdCBjdXJyZW50VGltZXpvbmVPZmZzZXQ6IG51bWJlciA9IGRhdGVNb21lbnQudXRjT2Zmc2V0KCk7XG4gICAgICAgIGNvbnN0IHRhcmdldFRpbWV6b25lT2Zmc2V0OiBudW1iZXIgPSB0aGlzLmdldChUSU1FWk9ORV9PRkZTRVQsIGN1cnJlbnRUaW1lem9uZU9mZnNldCk7XG5cbiAgICAgICAgY29uc3QgYWRqdXN0VGltZXpvbmVPZmZzZXQgPSB0YXJnZXRUaW1lem9uZU9mZnNldCAtIGN1cnJlbnRUaW1lem9uZU9mZnNldDtcblxuICAgICAgICBkYXRlTW9tZW50LmFkZCgtYWRqdXN0VGltZXpvbmVPZmZzZXQsICdtaW51dGVzJyk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGVNb21lbnQ7XG4gICAgfVxufSIsImltcG9ydCB7TmFtZU1hcCwgVW5pdE9mVGltZSwgVW5pdFJlZ2V4TWFwfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBjb25zdCBXRUVLREFZX09GRlNFVDogTmFtZU1hcCA9IHtcbiAgICAnc29ubnRhZyc6IDAsXG4gICAgJ3NvJzogMCxcbiAgICAnbW9udGFnJzogMSxcbiAgICAnbW8nOiAxLFxuICAgICdkaWVuc3RhZyc6IDIsXG4gICAgJ2RpJzogMixcbiAgICAnbWl0dHdvY2gnOiAzLFxuICAgICdtaSc6IDMsXG4gICAgJ2Rvbm5lcnN0YWcnOiA0LFxuICAgICdkbyc6IDQsXG4gICAgJ2ZyZWl0YWcnOiA1LFxuICAgICdmcic6IDUsXG4gICAgJ3NhbXN0YWcnOiA2LFxuICAgICdzYSc6IDZcbn07XG5cbi8vIG5vaW5zcGVjdGlvbiBOb25Bc2NpaUNoYXJhY3RlcnMsIEpTTm9uQVNDSUlOYW1lc1xuZXhwb3J0IGNvbnN0IE1PTlRIX09GRlNFVDogTmFtZU1hcCA9IHtcbiAgICAnamFudWFyJzogMSxcbiAgICAnamFuJzogMSxcbiAgICAnamFuLic6IDEsXG4gICAgJ2ZlYnJ1YXInOiAyLFxuICAgICdmZWInOiAyLFxuICAgICdmZWIuJzogMixcbiAgICAnbcOkcnonOiAzLFxuICAgICdtYWVyeic6IDMsXG4gICAgJ23DpHInOiAzLFxuICAgICdtw6RyLic6IDMsXG4gICAgJ21yeic6IDMsXG4gICAgJ21yei4nOiAzLFxuICAgICdhcHJpbCc6IDQsXG4gICAgJ2Fwcic6IDQsXG4gICAgJ2Fwci4nOiA0LFxuICAgICdtYWknOiA1LFxuICAgICdqdW5pJzogNixcbiAgICAnanVuJzogNixcbiAgICAnanVuLic6IDYsXG4gICAgJ2p1bGknOiA3LFxuICAgICdqdWwnOiA3LFxuICAgICdqdWwuJzogNyxcbiAgICAnYXVndXN0JzogOCxcbiAgICAnYXVnJzogOCxcbiAgICAnYXVnLic6IDgsXG4gICAgJ3NlcHRlbWJlcic6IDksXG4gICAgJ3NlcCc6IDksXG4gICAgJ3NlcC4nOiA5LFxuICAgICdzZXB0JzogOSxcbiAgICAnc2VwdC4nOiA5LFxuICAgICdva3RvYmVyJzogMTAsXG4gICAgJ29rdCc6IDEwLFxuICAgICdva3QuJzogMTAsXG4gICAgJ25vdmVtYmVyJzogMTEsXG4gICAgJ25vdic6IDExLFxuICAgICdub3YuJzogMTEsXG4gICAgJ2RlemVtYmVyJzogMTIsXG4gICAgJ2Rleic6IDEyLFxuICAgICdkZXouJzogMTJcbn07XG5cbmV4cG9ydCBjb25zdCBJTlRFR0VSX1dPUkRTX1BBVFRFUk46IHN0cmluZyA9ICcoPzplaW5zfHp3ZWl8ZHJlaXx2aWVyfGbDvG5mfGZ1ZW5mfHNlY2hzfHNpZWJlbnxhY2h0fG5ldW58emVobnxlbGZ8enfDtmxmfHp3b2VsZiknO1xuLy8gbm9pbnNwZWN0aW9uIE5vbkFzY2lpQ2hhcmFjdGVycywgSlNOb25BU0NJSU5hbWVzXG5leHBvcnQgY29uc3QgSU5URUdFUl9XT1JEUzogTmFtZU1hcCA9IHtcbiAgICAnZWlucyc6IDEsXG4gICAgJ3p3ZWknOiAyLFxuICAgICdkcmVpJzogMyxcbiAgICAndmllcic6IDQsXG4gICAgJ2bDvG5mJzogNSxcbiAgICAnZnVlbmYnOiA1LFxuICAgICdzZWNocyc6IDYsXG4gICAgJ3NpZWJlbic6IDcsXG4gICAgJ2FjaHQnOiA4LFxuICAgICduZXVuJzogOSxcbiAgICAnemVobic6IDEwLFxuICAgICdlbGYnOiAxMSxcbiAgICAnenfDtmxmJzogMTIsXG4gICAgJ3p3b2VsZic6IDEyXG59O1xuXG5jb25zdCBWX1JFR0VYOiBSZWdFeHAgPSAvdi9pO1xuXG5leHBvcnQgY29uc3QgeWVhckNhbGN1bGF0aW9uID0gKHllYXI6IHN0cmluZywgeWVhckJlOiBzdHJpbmcpOiBudW1iZXIgfCBudWxsID0+IHtcbiAgICBpZiAoeWVhcikge1xuICAgICAgICBsZXQgcmVzdWx0OiBudW1iZXIgPSBwYXJzZUludCh5ZWFyLCAxMCk7XG5cbiAgICAgICAgaWYgKHllYXJCZSkge1xuICAgICAgICAgICAgaWYgKFZfUkVHRVgudGVzdCh5ZWFyQmUpKSB7XG4gICAgICAgICAgICAgICAgLy8gdi5DaHIuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gLXJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPCAxMDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgKyAyMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcblxuY29uc3QgSEFMRl9SRUdFWDogUmVnRXhwID0gL2hhbGJlbi87XG5cbmV4cG9ydCBjb25zdCBtYXRjaEludGVnZXIgPSAodGV4dDogc3RyaW5nKTogbnVtYmVyID0+IHtcbiAgICBsZXQgbnVtOiBudW1iZXIgPSAwO1xuICAgIGlmIChJTlRFR0VSX1dPUkRTLmhhc093blByb3BlcnR5KHRleHQpKSB7XG4gICAgICAgIG51bSA9IElOVEVHRVJfV09SRFNbdGV4dF07XG4gICAgfSBlbHNlIGlmICh0ZXh0ID09PSAnZWluZXInIHx8IHRleHQgPT09ICdlaW5lbScpIHtcbiAgICAgICAgbnVtID0gMTtcbiAgICB9IGVsc2UgaWYgKHRleHQgPT09ICdlaW5pZ2VuJykge1xuICAgICAgICBudW0gPSAzO1xuICAgIH0gZWxzZSBpZiAoSEFMRl9SRUdFWC50ZXN0KHRleHQpKSB7XG4gICAgICAgIG51bSA9IDAuNTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBudW0gPSBwYXJzZUludCh0ZXh0LCAxMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bTtcbn07XG5cbmNvbnN0IHVuaXRQYXR0ZXJuczogVW5pdFJlZ2V4TWFwID0ge1xuICAgICdob3VyJzogL3N0dW5kZS8sXG4gICAgJ21pbnV0ZSc6IC9taW4vLFxuICAgICdzZWNvbmQnOiAvc2VrdW5kZS8sXG4gICAgJ3dlZWsnOiAvd29jaGUvLFxuICAgICdkYXknOiAvdGFnLyxcbiAgICAnbW9udGgnOiAvbW9uYXQvLFxuICAgICd5ZWFyJzogL2phaHIvXG59O1xuXG5leHBvcnQgY29uc3QgbWF0Y2hVbml0ID0gKHRleHQ6IHN0cmluZyk6IFVuaXRPZlRpbWUgfCB1bmRlZmluZWQgPT4gKE9iamVjdC5rZXlzKHVuaXRQYXR0ZXJucykgYXMgVW5pdE9mVGltZVtdKS5maW5kKFxuICAgICh1bml0OiBVbml0T2ZUaW1lKTogYm9vbGVhbiA9PiB1bml0UGF0dGVybnNbdW5pdF0hLnRlc3QodGV4dClcbik7IiwiaW1wb3J0IHtOYW1lTWFwLCBVbml0T2ZUaW1lLCBVbml0UmVnZXhNYXB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcblxuZXhwb3J0IGNvbnN0IFdFRUtEQVlfT0ZGU0VUOiBOYW1lTWFwID0ge1xuICAgICdzdW5kYXknOiAwLFxuICAgICdzdW4nOiAwLFxuICAgICdtb25kYXknOiAxLFxuICAgICdtb24nOiAxLFxuICAgICd0dWVzZGF5JzogMixcbiAgICAndHVlJzogMixcbiAgICAnd2VkbmVzZGF5JzogMyxcbiAgICAnd2VkJzogMyxcbiAgICAndGh1cnNkYXknOiA0LFxuICAgICd0aHVyJzogNCxcbiAgICAndGh1cnMnOiA0LFxuICAgICd0aHUnOiA0LFxuICAgICdmcmlkYXknOiA1LFxuICAgICdmcmknOiA1LFxuICAgICdzYXR1cmRheSc6IDYsXG4gICAgJ3NhdCc6IDZcbn07XG5cbmV4cG9ydCBjb25zdCBNT05USF9PRkZTRVQ6IE5hbWVNYXAgPSB7XG4gICAgJ2phbnVhcnknOiAxLFxuICAgICdqYW4nOiAxLFxuICAgICdqYW4uJzogMSxcbiAgICAnZmVicnVhcnknOiAyLFxuICAgICdmZWInOiAyLFxuICAgICdmZWIuJzogMixcbiAgICAnbWFyY2gnOiAzLFxuICAgICdtYXInOiAzLFxuICAgICdtYXIuJzogMyxcbiAgICAnYXByaWwnOiA0LFxuICAgICdhcHInOiA0LFxuICAgICdhcHIuJzogNCxcbiAgICAnbWF5JzogNSxcbiAgICAnanVuZSc6IDYsXG4gICAgJ2p1bic6IDYsXG4gICAgJ2p1bi4nOiA2LFxuICAgICdqdWx5JzogNyxcbiAgICAnanVsJzogNyxcbiAgICAnanVsLic6IDcsXG4gICAgJ2F1Z3VzdCc6IDgsXG4gICAgJ2F1Zyc6IDgsXG4gICAgJ2F1Zy4nOiA4LFxuICAgICdzZXB0ZW1iZXInOiA5LFxuICAgICdzZXAnOiA5LFxuICAgICdzZXAuJzogOSxcbiAgICAnc2VwdCc6IDksXG4gICAgJ3NlcHQuJzogOSxcbiAgICAnb2N0b2Jlcic6IDEwLFxuICAgICdvY3QnOiAxMCxcbiAgICAnb2N0Lic6IDEwLFxuICAgICdub3ZlbWJlcic6IDExLFxuICAgICdub3YnOiAxMSxcbiAgICAnbm92Lic6IDExLFxuICAgICdkZWNlbWJlcic6IDEyLFxuICAgICdkZWMnOiAxMixcbiAgICAnZGVjLic6IDEyXG59O1xuXG5leHBvcnQgY29uc3QgSU5URUdFUl9XT1JEUzogTmFtZU1hcCA9IHtcbiAgICAnb25lJzogMSxcbiAgICAndHdvJzogMixcbiAgICAndGhyZWUnOiAzLFxuICAgICdmb3VyJzogNCxcbiAgICAnZml2ZSc6IDUsXG4gICAgJ3NpeCc6IDYsXG4gICAgJ3NldmVuJzogNyxcbiAgICAnZWlnaHQnOiA4LFxuICAgICduaW5lJzogOSxcbiAgICAndGVuJzogMTAsXG4gICAgJ2VsZXZlbic6IDExLFxuICAgICd0d2VsdmUnOiAxMlxufTtcblxuZXhwb3J0IGNvbnN0IElOVEVHRVJfV09SRFNfUEFUVEVSTjogc3RyaW5nID0gJyg/OidcbiAgICArIE9iamVjdC5rZXlzKElOVEVHRVJfV09SRFMpLmpvaW4oJ3wnKVxuICAgICsgJyknO1xuXG5leHBvcnQgY29uc3QgT1JESU5BTF9XT1JEUzogTmFtZU1hcCA9IHtcbiAgICAnZmlyc3QnOiAxLFxuICAgICdzZWNvbmQnOiAyLFxuICAgICd0aGlyZCc6IDMsXG4gICAgJ2ZvdXJ0aCc6IDQsXG4gICAgJ2ZpZnRoJzogNSxcbiAgICAnc2l4dGgnOiA2LFxuICAgICdzZXZlbnRoJzogNyxcbiAgICAnZWlnaHRoJzogOCxcbiAgICAnbmludGgnOiA5LFxuICAgICd0ZW50aCc6IDEwLFxuICAgICdlbGV2ZW50aCc6IDExLFxuICAgICd0d2VsZnRoJzogMTIsXG4gICAgJ3RoaXJ0ZWVudGgnOiAxMyxcbiAgICAnZm91cnRlZW50aCc6IDE0LFxuICAgICdmaWZ0ZWVudGgnOiAxNSxcbiAgICAnc2l4dGVlbnRoJzogMTYsXG4gICAgJ3NldmVudGVlbnRoJzogMTcsXG4gICAgJ2VpZ2h0ZWVudGgnOiAxOCxcbiAgICAnbmluZXRlZW50aCc6IDE5LFxuICAgICd0d2VudGlldGgnOiAyMCxcbiAgICAndHdlbnR5IGZpcnN0JzogMjEsXG4gICAgJ3R3ZW50eSBzZWNvbmQnOiAyMixcbiAgICAndHdlbnR5IHRoaXJkJzogMjMsXG4gICAgJ3R3ZW50eSBmb3VydGgnOiAyNCxcbiAgICAndHdlbnR5IGZpZnRoJzogMjUsXG4gICAgJ3R3ZW50eSBzaXh0aCc6IDI2LFxuICAgICd0d2VudHkgc2V2ZW50aCc6IDI3LFxuICAgICd0d2VudHkgZWlnaHRoJzogMjgsXG4gICAgJ3R3ZW50eSBuaW50aCc6IDI5LFxuICAgICd0aGlydGlldGgnOiAzMCxcbiAgICAndGhpcnR5IGZpcnN0JzogMzFcbn07XG5leHBvcnQgY29uc3QgT1JESU5BTF9XT1JEU19QQVRURVJOOiBzdHJpbmcgPSAnKD86J1xuICAgICsgT2JqZWN0LmtleXMoT1JESU5BTF9XT1JEUykuam9pbignfCcpLnJlcGxhY2UoLyAvZywgJ1sgLV0nKVxuICAgICsgJyknO1xuXG5jb25zdCBUSU1FX1VOSVQ6IHN0cmluZyA9XG4gICAgJygnICsgSU5URUdFUl9XT1JEU19QQVRURVJOICsgJ3xbMC05XSt8YW4/KD86XFxcXHMqZmV3KT98aGFsZig/OlxcXFxzKmFuPyk/KVxcXFxzKicgK1xuICAgICcoc2VjKD86b25kcz8pP3xtaW4oPzp1dGUpP3M/fGhvdXJzP3x3ZWVrcz98ZGF5cz98bW9udGhzP3x5ZWFycz8pXFxcXHMqJztcblxuY29uc3QgVElNRV9VTklUX1NUUklDVDogc3RyaW5nID1cbiAgICAnKFswLTldK3xhbj8pXFxcXHMqJyArXG4gICAgJyhzZWNvbmRzP3xtaW51dGVzP3xob3Vycz98ZGF5cz8pXFxcXHMqJztcblxuY29uc3QgUEFUVEVSTl9USU1FX1VOSVQ6IFJlZ0V4cCA9IG5ldyBSZWdFeHAoVElNRV9VTklULCAnaScpO1xuXG5leHBvcnQgY29uc3QgVElNRV9VTklUX1BBVFRFUk46IHN0cmluZyA9ICcoPzonICsgVElNRV9VTklUICsgJykrJztcbmV4cG9ydCBjb25zdCBUSU1FX1VOSVRfU1RSSUNUX1BBVFRFUk46IHN0cmluZyA9ICcoPzonICsgVElNRV9VTklUX1NUUklDVCArICcpKyc7XG5cbmV4cG9ydCB0eXBlIEZyYWdtZW50TmFtZSA9ICdob3VyJyB8XG4gICAgJ21pbnV0ZScgfFxuICAgICdzZWNvbmQnIHxcbiAgICAnd2VlaycgfFxuICAgICdkJyB8XG4gICAgJ21vbnRoJyB8XG4gICAgJ3llYXInO1xuXG5leHBvcnQgdHlwZSBGcmFnbWVudE1hcCA9IHtcbiAgICBbayBpbiBGcmFnbWVudE5hbWVdPzogbnVtYmVyXG59XG5cbmV4cG9ydCBjb25zdCBleHRyYWN0RGF0ZVRpbWVVbml0RnJhZ21lbnRzID0gKHRpbWV1bml0VGV4dDogc3RyaW5nKTogRnJhZ21lbnRNYXAgPT4ge1xuICAgIGNvbnN0IGZyYWdtZW50czogRnJhZ21lbnRNYXAgPSB7fTtcbiAgICBsZXQgcmVtYWluaW5nVGV4dDogc3RyaW5nID0gdGltZXVuaXRUZXh0O1xuICAgIGxldCBtYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbCA9IFBBVFRFUk5fVElNRV9VTklULmV4ZWMocmVtYWluaW5nVGV4dCk7XG4gICAgd2hpbGUgKG1hdGNoKSB7XG4gICAgICAgIGNvbGxlY3REYXRlVGltZUZyYWdtZW50KG1hdGNoLCBmcmFnbWVudHMpO1xuICAgICAgICByZW1haW5pbmdUZXh0ID0gcmVtYWluaW5nVGV4dC5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2ggPSBQQVRURVJOX1RJTUVfVU5JVC5leGVjKHJlbWFpbmluZ1RleHQpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnRzO1xufTtcblxuZnVuY3Rpb24gY29sbGVjdERhdGVUaW1lRnJhZ21lbnQobWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSwgZnJhZ21lbnRzOiBGcmFnbWVudE1hcCkge1xuICAgIGNvbnN0IG1hdGNoZWROdW1iZXIgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IG1hdGNoZWRVbml0ID0gbWF0Y2hbMl0udG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgbnVtOiBudW1iZXIgPSAwO1xuICAgIGlmIChJTlRFR0VSX1dPUkRTLmhhc093blByb3BlcnR5KG1hdGNoZWROdW1iZXIpKSB7XG4gICAgICAgIG51bSA9IElOVEVHRVJfV09SRFNbbWF0Y2hlZE51bWJlcl07XG4gICAgfSBlbHNlIGlmIChtYXRjaGVkTnVtYmVyID09PSAnYScgfHwgbWF0Y2hlZE51bWJlciA9PT0gJ2FuJykge1xuICAgICAgICBudW0gPSAxO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hlZE51bWJlci5tYXRjaCgvZmV3LykpIHtcbiAgICAgICAgbnVtID0gMztcbiAgICB9IGVsc2UgaWYgKG1hdGNoZWROdW1iZXIubWF0Y2goL2hhbGYvKSkge1xuICAgICAgICBudW0gPSAwLjU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbnVtID0gcGFyc2VJbnQobWF0Y2hlZE51bWJlciwgMTApO1xuICAgIH1cblxuICAgIGlmIChtYXRjaGVkVW5pdC5tYXRjaCgvaG91ci8pKSB7XG4gICAgICAgIGZyYWdtZW50c1snaG91ciddID0gbnVtO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hlZFVuaXQubWF0Y2goL21pbi8pKSB7XG4gICAgICAgIGZyYWdtZW50c1snbWludXRlJ10gPSBudW07XG4gICAgfSBlbHNlIGlmIChtYXRjaGVkVW5pdC5tYXRjaCgvc2VjLykpIHtcbiAgICAgICAgZnJhZ21lbnRzWydzZWNvbmQnXSA9IG51bTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoZWRVbml0Lm1hdGNoKC93ZWVrLykpIHtcbiAgICAgICAgZnJhZ21lbnRzWyd3ZWVrJ10gPSBudW07XG4gICAgfSBlbHNlIGlmIChtYXRjaGVkVW5pdC5tYXRjaCgvZGF5LykpIHtcbiAgICAgICAgZnJhZ21lbnRzWydkJ10gPSBudW07XG4gICAgfSBlbHNlIGlmIChtYXRjaGVkVW5pdC5tYXRjaCgvbW9udGgvKSkge1xuICAgICAgICBmcmFnbWVudHNbJ21vbnRoJ10gPSBudW07XG4gICAgfSBlbHNlIGlmIChtYXRjaGVkVW5pdC5tYXRjaCgveWVhci8pKSB7XG4gICAgICAgIGZyYWdtZW50c1sneWVhciddID0gbnVtO1xuICAgIH1cblxuICAgIHJldHVybiBmcmFnbWVudHM7XG59XG5cbmNvbnN0IEhBTEZfUkVHRVg6IFJlZ0V4cCA9IC9oYWxmLztcbmNvbnN0IEZFV19SRUdFWDogUmVnRXhwID0gL2Zldy87XG5cbmV4cG9ydCBjb25zdCBtYXRjaEludGVnZXIgPSAodGV4dDogc3RyaW5nKTogbnVtYmVyID0+IHtcbiAgICBsZXQgbnVtOiBudW1iZXIgPSAwO1xuICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGlmIChJTlRFR0VSX1dPUkRTLmhhc093blByb3BlcnR5KHRleHQpKSB7XG4gICAgICAgICAgICBudW0gPSBJTlRFR0VSX1dPUkRTW3RleHRdO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQgPT09ICdhJyB8fCB0ZXh0ID09PSAnYW4nKSB7XG4gICAgICAgICAgICBudW0gPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQubWF0Y2goRkVXX1JFR0VYKSkge1xuICAgICAgICAgICAgbnVtID0gMztcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0Lm1hdGNoKEhBTEZfUkVHRVgpKSB7XG4gICAgICAgICAgICBudW0gPSAwLjU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBudW0gPSBwYXJzZUludCh0ZXh0LCAxMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVtO1xufTtcblxuY29uc3QgdW5pdFBhdHRlcm5zOiBVbml0UmVnZXhNYXAgPSB7XG4gICAgJ2hvdXInOiAvaG91ci8sXG4gICAgJ21pbnV0ZSc6IC9taW4vLFxuICAgICdzZWNvbmQnOiAvc2Vjb25kLyxcbiAgICAnd2Vlayc6IC93ZWVrLyxcbiAgICAnZGF5JzogL2RheS8sXG4gICAgJ21vbnRoJzogL21vbnRoLyxcbiAgICAneWVhcic6IC95ZWFyL1xufTtcblxuZXhwb3J0IGNvbnN0IG1hdGNoVW5pdCA9ICh0ZXh0OiBzdHJpbmcpOiBVbml0T2ZUaW1lIHwgdW5kZWZpbmVkID0+IChPYmplY3Qua2V5cyh1bml0UGF0dGVybnMpIGFzIFVuaXRPZlRpbWVbXSkuZmluZChcbiAgICAodW5pdDogVW5pdE9mVGltZSk6IGJvb2xlYW4gPT4gdW5pdFBhdHRlcm5zW3VuaXRdIS50ZXN0KHRleHQpXG4pO1xuXG5jb25zdCBCRV9SRUdFWDogUmVnRXhwID0gL0JFL2k7XG5jb25zdCBCQ19SRUdFWDogUmVnRXhwID0gL0JDL2k7XG5jb25zdCBBRF9SRUdFWDogUmVnRXhwID0gL0FEL2k7XG5cbmV4cG9ydCBjb25zdCB5ZWFyQ2FsY3VsYXRpb24gPSAoeWVhcjogc3RyaW5nLCBtYXliZVllYXJCZT86IHN0cmluZyk6IG51bWJlciB8IG51bGwgPT4ge1xuICAgIGlmICh5ZWFyKSB7XG4gICAgICAgIGlmIChCRV9SRUdFWC50ZXN0KG1heWJlWWVhckJlIHx8IHllYXIpKSB7XG4gICAgICAgICAgICAvLyBCdWRkaGlzdCBFcmFcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChtYXliZVllYXJCZSA/IHllYXIgOiB5ZWFyLnJlcGxhY2UoQkVfUkVHRVgsICcnKSwgMTApIC0gNTQzO1xuICAgICAgICB9IGVsc2UgaWYgKEJDX1JFR0VYLnRlc3QobWF5YmVZZWFyQmUgfHwgeWVhcikpe1xuICAgICAgICAgICAgLy8gQmVmb3JlIENocmlzdFxuICAgICAgICAgICAgcmV0dXJuIC1wYXJzZUludChtYXliZVllYXJCZSA/IHllYXIgOiB5ZWFyLnJlcGxhY2UoQkNfUkVHRVgsICcnKSwgMTApO1xuICAgICAgICB9IGVsc2UgaWYgKEFEX1JFR0VYLnRlc3QobWF5YmVZZWFyQmUgfHwgeWVhcikpe1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG1heWJlWWVhckJlID8geWVhciA6IHllYXIucmVwbGFjZShBRF9SRUdFWCwgJycpLCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0OiBudW1iZXIgPSBwYXJzZUludCh5ZWFyLCAxMCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IDwgMTAwKXtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gMjAwMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTsiLCJpbXBvcnQge05hbWVNYXAsIFVuaXRPZlRpbWUsIFVuaXRSZWdleE1hcH0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG4vLyBub2luc3BlY3Rpb24gTm9uQXNjaWlDaGFyYWN0ZXJzLCBKU05vbkFTQ0lJTmFtZXNcbmV4cG9ydCBjb25zdCBXRUVLREFZX09GRlNFVDogTmFtZU1hcCA9IHtcbiAgICAnZG9taW5nbyc6IDAsXG4gICAgJ2RvbSc6IDAsXG4gICAgJ2x1bmVzJzogMSxcbiAgICAnbHVuJzogMSxcbiAgICAnbWFydGVzJzogMixcbiAgICAnbWFyJzogMixcbiAgICAnbWnDqXJjb2xlcyc6IDMsXG4gICAgJ21pZXJjb2xlcyc6IDMsXG4gICAgJ21pZSc6IDMsXG4gICAgJ2p1ZXZlcyc6IDQsXG4gICAgJ2p1ZSc6IDQsXG4gICAgJ3ZpZXJuZXMnOiA1LFxuICAgICd2aWUnOiA1LFxuICAgICdzw6FiYWRvJzogNixcbiAgICAnc2FiYWRvJzogNixcbiAgICAnc2FiJzogNixcbn07XG4vLyBub2luc3BlY3Rpb24gTm9uQXNjaWlDaGFyYWN0ZXJzLCBKU05vbkFTQ0lJTmFtZXNcbmV4cG9ydCBjb25zdCBNT05USF9PRkZTRVQ6IE5hbWVNYXAgPSB7XG4gICAgJ2VuZXJvJzogMSxcbiAgICAnZW5lJzogMSxcbiAgICAnZW5lLic6IDEsXG4gICAgJ2ZlYnJlcm8nOiAyLFxuICAgICdmZWInOiAyLFxuICAgICdmZWIuJzogMixcbiAgICAnbWFyem8nOiAzLFxuICAgICdtYXInOiAzLFxuICAgICdtYXIuJzogMyxcbiAgICAnYWJyaWwnOiA0LFxuICAgICdhYnInOiA0LFxuICAgICdhYnIuJzogNCxcbiAgICAnbWF5byc6IDUsXG4gICAgJ21heSc6IDUsXG4gICAgJ21heS4nOiA1LFxuICAgICdqdW5pbyc6IDYsXG4gICAgJ2p1bic6IDYsXG4gICAgJ2p1bi4nOiA2LFxuICAgICdqdWxpbyc6IDcsXG4gICAgJ2p1bCc6IDcsXG4gICAgJ2p1bC4nOiA3LFxuICAgICdhZ29zdG8nOiA4LFxuICAgICdhZ28nOiA4LFxuICAgICdhZ28uJzogOCxcbiAgICAnc2VwdGllbWJyZSc6IDksXG4gICAgJ3NlcCc6IDksXG4gICAgJ3NlcHQnOiA5LFxuICAgICdzZXAuJzogOSxcbiAgICAnc2VwdC4nOiA5LFxuICAgICdvY3R1YnJlJzogMTAsXG4gICAgJ29jdCc6IDEwLFxuICAgICdvY3QuJzogMTAsXG4gICAgJ25vdmllbWJyZSc6IDExLFxuICAgICdub3YnOiAxMSxcbiAgICAnbm92Lic6IDExLFxuICAgICdkaWNpZW1icmUnOiAxMixcbiAgICAnZGljJzogMTIsXG4gICAgJ2RpYy4nOiAxMixcbn07XG5cbmNvbnN0IHVuaXRQYXR0ZXJuczogVW5pdFJlZ2V4TWFwID0ge1xuICAgIGRheTogL2RbacOtXWEvLFxuICAgIGhvdXI6IC9ob3JhLyxcbiAgICBtaW51dGU6IC9taW51dG8vLFxuICAgIHdlZWs6IC9zZW1hbmEvLFxuICAgIG1vbnRoOiAvbWVzLyxcbiAgICB5ZWFyOiAvYcOxby9cbn07XG5cbmV4cG9ydCBjb25zdCBtYXRjaFVuaXQgPSAodGV4dDogc3RyaW5nKTogVW5pdE9mVGltZSB8IHVuZGVmaW5lZCA9PiAoT2JqZWN0LmtleXModW5pdFBhdHRlcm5zKSBhcyBVbml0T2ZUaW1lW10pLmZpbmQoXG4gICAgKHVuaXQ6IFVuaXRPZlRpbWUpOiBib29sZWFuID0+IHVuaXRQYXR0ZXJuc1t1bml0XSEudGVzdCh0ZXh0KVxuKTtcblxuY29uc3QgQURfUkVHRVg6IFJlZ0V4cCA9IC9hXFwuP1xccypjXFwuPy9pO1xuXG5leHBvcnQgY29uc3QgeWVhckNhbGN1bGF0aW9uID0gKHllYXI6IHN0cmluZywgeWVhckJlOiBzdHJpbmcpOiBudW1iZXIgfCBudWxsID0+IHtcbiAgICBpZiAoeWVhcikge1xuICAgICAgICBsZXQgcmVzdWx0OiBudW1iZXIgPSBwYXJzZUludCh5ZWFyLCAxMCk7XG4gICAgICAgIGlmICh5ZWFyQmUgJiYgQURfUkVHRVgudGVzdCh5ZWFyQmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gLXJlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmICgheWVhckJlKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0IDwgMTAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIDIwMDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBIQUxGX1JFR0VYOiBSZWdFeHAgPSAvbWVkaS87XG5cbmV4cG9ydCBjb25zdCBtYXRjaE51bWJlciA9ICh0ZXh0OiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICAgIGNvbnN0IG51bTogbnVtYmVyID0gcGFyc2VJbnQodGV4dCwgMTApO1xuICAgIGlmIChpc05hTihudW0pKSB7XG4gICAgICAgIGlmICh0ZXh0Lm1hdGNoKEhBTEZfUkVHRVgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMC41O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVtXG59OyIsImltcG9ydCB7TmFtZU1hcCwgVW5pdE9mVGltZSwgVW5pdFJlZ2V4TWFwfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBjb25zdCBXRUVLREFZX09GRlNFVDogTmFtZU1hcCA9IHtcbiAgICAnZGltYW5jaGUnOiAwLFxuICAgICdkaW0nOiAwLFxuICAgICdsdW5kaSc6IDEsXG4gICAgJ2x1bic6IDEsXG4gICAgJ21hcmRpJzogMixcbiAgICAnbWFyJzogMixcbiAgICAnbWVyY3JlZGknOiAzLFxuICAgICdtZXInOiAzLFxuICAgICdqZXVkaSc6IDQsXG4gICAgJ2pldSc6IDQsXG4gICAgJ3ZlbmRyZWRpJzogNSxcbiAgICAndmVuJzogNSxcbiAgICAnc2FtZWRpJzogNixcbiAgICAnc2FtJzogNlxufTtcblxuLy8gbm9pbnNwZWN0aW9uIE5vbkFzY2lpQ2hhcmFjdGVycywgSlNOb25BU0NJSU5hbWVzXG5leHBvcnQgY29uc3QgTU9OVEhfT0ZGU0VUOiBOYW1lTWFwID0ge1xuICAgICdqYW52aWVyJzogMSxcbiAgICAnamFuJzogMSxcbiAgICAnamFuLic6IDEsXG4gICAgJ2bDqXZyaWVyJzogMixcbiAgICAnZsOpdic6IDIsXG4gICAgJ2bDqXYuJzogMixcbiAgICAnZmV2cmllcic6IDIsXG4gICAgJ2Zldic6IDIsXG4gICAgJ2Zldi4nOiAyLFxuICAgICdtYXJzJzogMyxcbiAgICAnbWFyJzogMyxcbiAgICAnbWFyLic6IDMsXG4gICAgJ2F2cmlsJzogNCxcbiAgICAnYXZyJzogNCxcbiAgICAnYXZyLic6IDQsXG4gICAgJ21haSc6IDUsXG4gICAgJ2p1aW4nOiA2LFxuICAgICdqdW4nOiA2LFxuICAgICdqdWlsJzogNyxcbiAgICAnanVpbGxldCc6IDcsXG4gICAgJ2p1bCc6IDcsXG4gICAgJ2p1bC4nOiA3LFxuICAgICdhb8O7dCc6IDgsXG4gICAgJ2FvdXQnOiA4LFxuICAgICdzZXB0ZW1icmUnOiA5LFxuICAgICdzZXAnOiA5LFxuICAgICdzZXAuJzogOSxcbiAgICAnc2VwdCc6IDksXG4gICAgJ3NlcHQuJzogOSxcbiAgICAnb2N0b2JyZSc6IDEwLFxuICAgICdvY3QnOiAxMCxcbiAgICAnb2N0Lic6IDEwLFxuICAgICdub3ZlbWJyZSc6IDExLFxuICAgICdub3YnOiAxMSxcbiAgICAnbm92Lic6IDExLFxuICAgICdkw6ljZW1icmUnOiAxMixcbiAgICAnZGVjZW1icmUnOiAxMixcbiAgICAnZGVjJzogMTIsXG4gICAgJ2RlYy4nOiAxMlxufTtcblxuZXhwb3J0IGNvbnN0IElOVEVHRVJfV09SRFNfUEFUVEVSTjogc3RyaW5nID0gJyg/OnVufGRldXh8dHJvaXN8cXVhdHJlfGNpbnF8c2l4fHNlcHR8aHVpdHxuZXVmfGRpeHxvbnplfGRvdXplfHRyZWl6ZSknO1xuZXhwb3J0IGNvbnN0IElOVEVHRVJfV09SRFM6IE5hbWVNYXAgPSB7XG4gICAgJ3VuJzogMSxcbiAgICAnZGV1eCc6IDIsXG4gICAgJ3Ryb2lzJzogMyxcbiAgICAncXVhdHJlJzogNCxcbiAgICAnY2lucSc6IDUsXG4gICAgJ3NpeCc6IDYsXG4gICAgJ3NlcHQnOiA3LFxuICAgICdodWl0JzogOCxcbiAgICAnbmV1Zic6IDksXG4gICAgJ2RpeCc6IDEwLFxuICAgICdvbnplJzogMTEsXG4gICAgJ2RvdXplJzogMTIsXG4gICAgJ3RyZWl6ZSc6IDEzLFxufTtcblxuY29uc3QgdW5pdFBhdHRlcm5zOiBVbml0UmVnZXhNYXAgPSB7XG4gICAgZGF5OiAvam91cnM/LyxcbiAgICBob3VyOiAvaGV1cmVzPy8sXG4gICAgbWludXRlOiAvbWluKD86dXRlKT9zPy8sXG4gICAgc2Vjb25kOiAvc2Vjb25kZXM/LyxcbiAgICB3ZWVrOiAvc2VtYWluZXM/LyxcbiAgICBtb250aDogL21vaXM/LyxcbiAgICB5ZWFyOiAvYW4oPzpuw6llKT9zPy9cbn07XG5cbmV4cG9ydCBjb25zdCBtYXRjaFVuaXQgPSAodGV4dDogc3RyaW5nKTogVW5pdE9mVGltZSB8IHVuZGVmaW5lZCA9PiAoT2JqZWN0LmtleXModW5pdFBhdHRlcm5zKSBhcyBVbml0T2ZUaW1lW10pLmZpbmQoXG4gICAgKHVuaXQ6IFVuaXRPZlRpbWUpOiBib29sZWFuID0+IHVuaXRQYXR0ZXJuc1t1bml0XSEudGVzdCh0ZXh0KVxuKTtcblxuY29uc3QgVEhSRUVfUkVHRVg6IFJlZ0V4cCA9IC9xdWVscXVlcz8vO1xuY29uc3QgSEFMRl9SRUdFWDogUmVnRXhwID0gL2RlbWktPy87XG5cbmV4cG9ydCBjb25zdCBtYXRjaE51bWJlciA9ICh0ZXh0OiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICAgIGlmICghdGV4dCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKElOVEVHRVJfV09SRFMuaGFzT3duUHJvcGVydHkodGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIElOVEVHRVJfV09SRFNbdGV4dF07XG4gICAgfSBlbHNlIGlmICh0ZXh0ID09PSAndW4nIHx8IHRleHQgPT09ICd1bmUnKXtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmICh0ZXh0Lm1hdGNoKFRIUkVFX1JFR0VYKSkge1xuICAgICAgICByZXR1cm4gMztcbiAgICB9IGVsc2UgaWYgKHRleHQubWF0Y2goSEFMRl9SRUdFWCkpIHtcbiAgICAgICAgcmV0dXJuIDAuNTtcbiAgICB9XG5cbiAgICBjb25zdCBudW06IG51bWJlciA9IHBhcnNlSW50KHRleHQsIDEwKTtcbiAgICBpZiAoaXNOYU4obnVtKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtO1xufTtcblxuY29uc3QgQURfUkVHRVg6IFJlZ0V4cCA9IC9hL2k7XG5cbmV4cG9ydCBjb25zdCB5ZWFyQ2FsY3VsYXRpb24gPSAoeWVhcjogc3RyaW5nLCB5ZWFyQmU6IHN0cmluZyk6IG51bWJlciB8IG51bGwgPT4ge1xuICAgIGlmICh5ZWFyKSB7XG4gICAgICAgIGxldCByZXN1bHQ6IG51bWJlciA9IHBhcnNlSW50KHllYXIsIDEwKTtcbiAgICAgICAgaWYgKHllYXJCZSAmJiBBRF9SRUdFWC50ZXN0KHllYXJCZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAtcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKCF5ZWFyQmUpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPCAxMDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgMjAwMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07IiwiLyoqXG4gKiB0by1oYW5rYWt1LmpzXG4gKiBjb252ZXJ0IHRvIGFzY2lpIGNvZGUgc3RyaW5ncy5cbiAqXG4gKiBAdmVyc2lvbiAxLjAuMVxuICogQGF1dGhvciB0aGluazQ5XG4gKiBAdXJsIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzk2NDU5MlxuICogQGxpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAgKFRoZSBNSVQgTGljZW5zZSlcbiAqL1xuXG5leHBvcnQgY29uc3QgdG9IYW5rYWt1OiAoczogc3RyaW5nKSA9PiBzdHJpbmcgPSAoXG4gICAgKFN0cmluZzogU3RyaW5nQ29uc3RydWN0b3IsIGZyb21DaGFyQ29kZTogKG46IG51bWJlcikgPT4gc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IGFscGhhTnVtID0gKHRva2VuOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21DaGFyQ29kZSh0b2tlbi5jaGFyQ29kZUF0KDApIC0gNjUyNDgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAoc3RyaW5nOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhzdHJpbmcpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcdTIwMTkvZywgJ1xcdTAwMjcnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUyMDFEL2csICdcXHUwMDIyJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx1MzAwMC9nLCAnXFx1MDAyMCcpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcdUZGRTUvZywgJ1xcdTAwQTUnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx1RkYwMVxcdUZGMDMtXFx1RkYwNlxcdUZGMDhcXHVGRjA5XFx1RkYwQy1cXHVGRjE5XFx1RkYxQy1cXHVGRjFGXFx1RkYyMS1cXHVGRjNCXFx1RkYzRFxcdUZGM0ZcXHVGRjQxLVxcdUZGNUJcXHVGRjVEXFx1RkY1RV0vZywgYWxwaGFOdW0pO1xuICAgICAgICB9O1xuICAgIH1cbikoU3RyaW5nLCBTdHJpbmcuZnJvbUNoYXJDb2RlKTtcblxuLyoqXG4gKiB0by16ZW5rYWt1LmpzXG4gKiBjb252ZXJ0IHRvIG11bHRpIGJ5dGUgc3RyaW5ncy5cbiAqXG4gKiBAdmVyc2lvbiAxLjAuMlxuICogQGF1dGhvciB0aGluazQ5XG4gKiBAdXJsIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzk2NDU5MlxuICogQGxpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAgKFRoZSBNSVQgTGljZW5zZSlcbiAqL1xuZXhwb3J0IGNvbnN0IHRvWmVua2FrdTogKHM6IHN0cmluZykgPT4gc3RyaW5nID0gKFxuICAgIChTdHJpbmc6IFN0cmluZ0NvbnN0cnVjdG9yLCBmcm9tQ2hhckNvZGU6IChuOiBudW1iZXIpID0+IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBhbHBoYU51bSA9ICh0b2tlbjogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUodG9rZW4uY2hhckNvZGVBdCgwKSArIDY1MjQ4KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gKHN0cmluZzogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoc3RyaW5nKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUwMDIwL2csICdcXHUzMDAwJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFx1MDAyMi9nLCAnXFx1MjAxRCcpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcdTAwMjcvZywgJ1xcdTIwMTknKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUwMEE1L2csICdcXHVGRkU1JylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvWyEjLSYoKSwtOVxcdTAwM0MtP0EtW1xcdTAwNURfYS17fX5dL2csIGFscGhhTnVtKTtcbiAgICAgICAgfTtcbiAgICB9XG4pKFN0cmluZywgU3RyaW5nLmZyb21DaGFyQ29kZSk7IiwiaW1wb3J0IHtOYW1lTWFwfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5cbi8vIG5vaW5zcGVjdGlvbiBOb25Bc2NpaUNoYXJhY3RlcnNcbmV4cG9ydCBjb25zdCBOVU1CRVI6IE5hbWVNYXAgPSB7XG4gICAgJ+mbtic6IDAsXG4gICAgJ+S4gCc6IDEsXG4gICAgJ+S6jCc6IDIsXG4gICAgJ+WFqSc6IDIsXG4gICAgJ+S4iSc6IDMsXG4gICAgJ+Wbmyc6IDQsXG4gICAgJ+S6lCc6IDUsXG4gICAgJ+WFrSc6IDYsXG4gICAgJ+S4gyc6IDcsXG4gICAgJ+WFqyc6IDgsXG4gICAgJ+S5nSc6IDksXG4gICAgJ+WNgSc6IDEwLFxuICAgICflu78nOiAyMCxcbiAgICAn5Y2FJzogMzAsXG59O1xuXG4vLyBub2luc3BlY3Rpb24gTm9uQXNjaWlDaGFyYWN0ZXJzXG5leHBvcnQgY29uc3QgV0VFS0RBWV9PRkZTRVQ6IE5hbWVNYXAgPSB7XG4gICAgJ+WkqSc6IDAsXG4gICAgJ+aXpSc6IDAsXG4gICAgJ+S4gCc6IDEsXG4gICAgJ+S6jCc6IDIsXG4gICAgJ+S4iSc6IDMsXG4gICAgJ+Wbmyc6IDQsXG4gICAgJ+S6lCc6IDUsXG4gICAgJ+WFrSc6IDYsXG59O1xuXG5leHBvcnQgY29uc3QgemhTdHJpbmdUb051bWJlciA9ICh0ZXh0OiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICAgIGNvbnN0IGxlbjogbnVtYmVyID0gdGV4dC5sZW5ndGg7XG4gICAgbGV0IG51bWJlcjogbnVtYmVyID0gMDtcbiAgICBsZXQgaTogbnVtYmVyID0gMDtcbiAgICBmb3IgKDtpIDwgbGVuO2krKykge1xuICAgICAgICBsZXQgY2hhcjogc3RyaW5nID0gdGV4dFtpXTtcbiAgICAgICAgaWYgKGNoYXIgPT09ICfljYEnKSB7XG4gICAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPT09IDAgPyBOVU1CRVJbY2hhcl0gOiAobnVtYmVyICogTlVNQkVSW2NoYXJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG51bWJlciArPSBOVU1CRVJbY2hhcl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bWJlcjtcbn07XG5cbmV4cG9ydCBjb25zdCB6aFN0cmluZ1RvWWVhciA9ICh0ZXh0OiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICAgIGNvbnN0IGxlbjogbnVtYmVyID0gdGV4dC5sZW5ndGg7XG4gICAgbGV0IHN0cmluZzogc3RyaW5nID0gJyc7XG4gICAgbGV0IGk6IG51bWJlciA9IDA7XG4gICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdHJpbmcgPSBzdHJpbmcgKyBOVU1CRVJbdGV4dFtpXV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlSW50KHN0cmluZywgMTApO1xufTtcbiIsImltcG9ydCAqIGFzIG1vbWVudCBmcm9tIFwibW9tZW50XCI7XG5pbXBvcnQge01vbWVudH0gZnJvbSBcIm1vbWVudFwiO1xuaW1wb3J0IHtEQVksIEhPVVIsIE1JTlVURSwgTU9OVEgsIFNFQ09ORCwgVW5pdE9mVGltZSwgV0VFSywgV0VFS0RBWSwgWUVBUn0gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHtQYXJzZWRDb21wb25lbnRzLCBQYXJzZWRSZXN1bHR9IGZyb20gXCIuLi9yZXN1bHRcIjtcblxuZXhwb3J0IGNvbnN0IGdldEFwcHJvcHJpYXRlWWVhciA9IChjdXJyZW50OiBQYXJzZWRDb21wb25lbnRzLCByZWY6IERhdGUpOiB2b2lkID0+IHtcbiAgICBjb25zdCBkYXk6IG51bWJlciA9IGN1cnJlbnQuZ2V0KERBWSwgLTEpO1xuICAgIGNvbnN0IG1vbnRoOiBudW1iZXIgPSBjdXJyZW50LmdldChNT05USCwgLTEpO1xuICAgIGlmIChkYXkgIT09IC0xICYmIG1vbnRoICE9PSAtMSkge1xuICAgICAgICAvL0ZpbmQgdGhlIG1vc3QgYXBwcm9wcmlhdGVkIHllYXJcbiAgICAgICAgY29uc3QgcmVmTW9tZW50OiBNb21lbnQgPSBtb21lbnQocmVmKTtcbiAgICAgICAgY29uc3QgcmVmTW9tZW50Q2xvbmU6IE1vbWVudCA9IHJlZk1vbWVudC5jbG9uZSgpO1xuICAgICAgICByZWZNb21lbnQubW9udGgobW9udGggLSAxKTtcbiAgICAgICAgcmVmTW9tZW50LmRhdGUoZGF5KTtcblxuICAgICAgICBjb25zdCBuZXh0WWVhcjogTW9tZW50ID0gcmVmTW9tZW50LmNsb25lKCkuYWRkKDEsICd5Jyk7XG4gICAgICAgIGNvbnN0IGxhc3RZZWFyOiBNb21lbnQgPSByZWZNb21lbnQuY2xvbmUoKS5hZGQoLTEsICd5Jyk7XG4gICAgICAgIGNvbnN0IGRpZmY6IG51bWJlciA9IE1hdGguYWJzKHJlZk1vbWVudC5kaWZmKHJlZk1vbWVudENsb25lKSk7XG4gICAgICAgIGlmIChNYXRoLmFicyhuZXh0WWVhci5kaWZmKHJlZk1vbWVudENsb25lKSkgPCBkaWZmKSB7XG4gICAgICAgICAgICBjdXJyZW50LmltcGx5KFlFQVIsIG5leHRZZWFyLnllYXIoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMobGFzdFllYXIuZGlmZihyZWZNb21lbnRDbG9uZSkpIDwgZGlmZikge1xuICAgICAgICAgICAgY3VycmVudC5pbXBseShZRUFSLCBsYXN0WWVhci55ZWFyKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudC5pbXBseShZRUFSLCByZWZNb21lbnQueWVhcigpKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmVudW0gRGVhZGxpbmVNb2RlIHtcbiAgICBUSU1FLFxuICAgIERBVEUsXG4gICAgTk9ORSxcbn1cblxuZXhwb3J0IGNvbnN0IGRlYWRsaW5lQ2FsY3VsYXRpb25zID0gKG51bTogbnVtYmVyLCB1bml0OiBVbml0T2ZUaW1lLCByZXN1bHQ6IFBhcnNlZFJlc3VsdCwgbW9tZW50UmVmOiBNb21lbnQpOiBib29sZWFuID0+IHtcbiAgICBsZXQgbW9kZTogRGVhZGxpbmVNb2RlID0gRGVhZGxpbmVNb2RlLk5PTkU7XG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICAgIGNhc2UgSE9VUjpcbiAgICAgICAgICAgIG1vbWVudFJlZi5hZGQobnVtLCAnaG91cicpO1xuICAgICAgICAgICAgbW9kZSA9IERlYWRsaW5lTW9kZS5USU1FO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTUlOVVRFOlxuICAgICAgICAgICAgbW9tZW50UmVmLmFkZChudW0sICdtaW51dGUnKTtcbiAgICAgICAgICAgIG1vZGUgPSBEZWFkbGluZU1vZGUuVElNRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNFQ09ORDpcbiAgICAgICAgICAgIG1vbWVudFJlZi5hZGQobnVtLCAnc2Vjb25kJyk7XG4gICAgICAgICAgICBtb2RlID0gRGVhZGxpbmVNb2RlLlRJTUU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBEQVk6XG4gICAgICAgICAgICBtb21lbnRSZWYuYWRkKG51bSwgJ2QnKTtcbiAgICAgICAgICAgIG1vZGUgPSBEZWFkbGluZU1vZGUuREFURTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1PTlRIOlxuICAgICAgICAgICAgbW9tZW50UmVmLmFkZChudW0sICdtb250aCcpO1xuICAgICAgICAgICAgbW9kZSA9IERlYWRsaW5lTW9kZS5EQVRFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWUVBUjpcbiAgICAgICAgICAgIG1vbWVudFJlZi5hZGQobnVtLCAneWVhcicpO1xuICAgICAgICAgICAgbW9kZSA9IERlYWRsaW5lTW9kZS5EQVRFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgV0VFSzpcbiAgICAgICAgICAgIG1vbWVudFJlZi5hZGQobnVtICogNywgJ2QnKTtcbiAgICAgICAgICAgIG1vZGUgPSBEZWFkbGluZU1vZGUuREFURTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChtb2RlICE9PSBEZWFkbGluZU1vZGUuTk9ORSkge1xuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgRGVhZGxpbmVNb2RlLkRBVEU6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmFzc2lnbihZRUFSLCBtb21lbnRSZWYueWVhcigpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1PTlRILCBtb21lbnRSZWYubW9udGgoKSArIDEpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oREFZLCBtb21lbnRSZWYuZGF0ZSgpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRGVhZGxpbmVNb2RlLlRJTUU6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KFlFQVIsIG1vbWVudFJlZi55ZWFyKCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5pbXBseShNT05USCwgbW9tZW50UmVmLm1vbnRoKCkgKyAxKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoREFZLCBtb21lbnRSZWYuZGF0ZSgpKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKEhPVVIsIG1vbWVudFJlZi5ob3VyKCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oTUlOVVRFLCBtb21lbnRSZWYubWludXRlKCkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oU0VDT05ELCBtb21lbnRSZWYuc2Vjb25kKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGNvbnN0IGNoZWNrTW9udGhEYXlzVmFsaWQgPSAoZGF5OiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIHllYXI6IG51bWJlcik6IGJvb2xlYW4gPT4ge1xuICAgIHJldHVybiBkYXkgPD0gbW9tZW50KCkuZGF0ZSgxKS5tb250aChtb250aCkueWVhcih5ZWFyKS5kYXlzSW5Nb250aCgpO1xufTtcblxuZXhwb3J0IGVudW0gTW9kaWZpZXIge1xuICAgIExBU1QsXG4gICAgVEhJUyxcbiAgICBORVhULFxuICAgIFVOS05PV05cbn1cblxuZXhwb3J0IGNvbnN0IHVwZGF0ZVBhcnNlZENvbXBvbmVudCA9IChyZXN1bHQ6IFBhcnNlZFJlc3VsdCwgcmVmOiBEYXRlLCBvZmZzZXQ6IG51bWJlciwgbW9kaWZpZXI6IE1vZGlmaWVyKSA9PiB7XG4gICAgY29uc3Qgc3RhcnRNb21lbnQ6IE1vbWVudCA9IG1vbWVudChyZWYpO1xuICAgIGNvbnN0IHJlZk9mZnNldDogbnVtYmVyID0gc3RhcnRNb21lbnQuZGF5KCk7XG4gICAgbGV0IHN0YXJ0TW9tZW50Rml4ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIGlmIChtb2RpZmllciA9PT0gTW9kaWZpZXIuTEFTVCkge1xuICAgICAgICBzdGFydE1vbWVudC5kYXkob2Zmc2V0IC0gNyk7XG4gICAgICAgIHN0YXJ0TW9tZW50Rml4ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobW9kaWZpZXIgPT09IE1vZGlmaWVyLk5FWFQpIHtcbiAgICAgICAgc3RhcnRNb21lbnQuZGF5KG9mZnNldCArIDcpO1xuICAgICAgICBzdGFydE1vbWVudEZpeGVkID0gdHJ1ZTtcbiAgICB9ICBlbHNlIGlmIChtb2RpZmllciA9PSBNb2RpZmllci5USElTKSB7XG4gICAgICAgIHN0YXJ0TW9tZW50LmRheShvZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNhbGNPZmZzZXQgPSBvZmZzZXQgLSByZWZPZmZzZXQ7XG4gICAgICAgIGNvbnN0IGFic09mZnNldCA9IE1hdGguYWJzKGNhbGNPZmZzZXQpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoY2FsY09mZnNldCAtIDcpIDwgYWJzT2Zmc2V0KSB7XG4gICAgICAgICAgICBzdGFydE1vbWVudC5kYXkob2Zmc2V0IC0gNyk7XG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoY2FsY09mZnNldCArIDcpIDwgYWJzT2Zmc2V0KSB7XG4gICAgICAgICAgICBzdGFydE1vbWVudC5kYXkob2Zmc2V0ICsgNyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydE1vbWVudC5kYXkob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oV0VFS0RBWSwgb2Zmc2V0KTtcblxuICAgIGlmIChzdGFydE1vbWVudEZpeGVkKSB7XG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oREFZLCBzdGFydE1vbWVudC5kYXRlKCkpO1xuICAgICAgICByZXN1bHQuc3RhcnQuYXNzaWduKE1PTlRILCBzdGFydE1vbWVudC5tb250aCgpICsgMSk7XG4gICAgICAgIHJlc3VsdC5zdGFydC5hc3NpZ24oWUVBUiwgc3RhcnRNb21lbnQueWVhcigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoREFZLCBzdGFydE1vbWVudC5kYXRlKCkpO1xuICAgICAgICByZXN1bHQuc3RhcnQuaW1wbHkoTU9OVEgsIHN0YXJ0TW9tZW50Lm1vbnRoKCkgKyAxKTtcbiAgICAgICAgcmVzdWx0LnN0YXJ0LmltcGx5KFlFQVIsIHN0YXJ0TW9tZW50LnllYXIoKSk7XG4gICAgfVxufTsiXX0=
